{"ast":null,"code":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.getRoutes=getRoutes;exports.getIgnoreList=getIgnoreList;exports.extrapolateGroups=extrapolateGroups;exports.generateDynamic=generateDynamic;const matchers_1=require(\"./matchers\");const url_1=require(\"./utils/url\");const validPlatforms=new Set(['android','ios','native','web']);function getRoutes(contextModule,options){const directoryTree=getDirectoryTree(contextModule,options);if(!directoryTree){return null;}const rootNode=flattenDirectoryTreeToRoutes(directoryTree,options);if(!options.ignoreEntryPoints){crawlAndAppendInitialRoutesAndEntryFiles(rootNode,options);}return rootNode;}function getDirectoryTree(contextModule,options){const importMode=options.importMode||\"sync\";const ignoreList=[/^\\.\\/\\+(html|native-intent)\\.[tj]sx?$/];if(options.ignore){ignoreList.push(...options.ignore);}if(!options.preserveApiRoutes){ignoreList.push(/\\+api$/,/\\+api\\.[tj]sx?$/);}const rootDirectory={files:new Map(),subdirectories:new Map()};let hasRoutes=false;let isValid=false;const contextKeys=contextModule.keys();const redirects={};const rewrites={};let validRedirectDestinations;if(options.preserveRedirectAndRewrites){if(options.redirects){for(const redirect of options.redirects){const source=redirect.source.replace(/^\\.?\\//,'');const isExternalRedirect=(0,url_1.shouldLinkExternally)(redirect.destination);const targetDestination=isExternalRedirect?redirect.destination:(0,matchers_1.stripInvisibleSegmentsFromPath)((0,matchers_1.removeFileSystemDots)((0,matchers_1.removeFileSystemExtensions)(redirect.destination.replace(/^\\.?\\/?/,''))));const normalizedSource=(0,matchers_1.removeFileSystemDots)((0,matchers_1.removeSupportedExtensions)(source));if(ignoreList.some(regex=>regex.test(normalizedSource))){continue;}validRedirectDestinations??=contextKeys.map(key=>{return[(0,matchers_1.stripInvisibleSegmentsFromPath)((0,matchers_1.removeFileSystemDots)((0,matchers_1.removeSupportedExtensions)(key))),key];});const destination=isExternalRedirect?targetDestination:validRedirectDestinations.find(key=>key[0]===targetDestination)?.[1];if(!destination){if(options.preserveApiRoutes){throw new Error(`Redirect destination \"${redirect.destination}\" does not exist.`);}continue;}const fakeContextKey=(0,matchers_1.removeFileSystemDots)((0,matchers_1.removeSupportedExtensions)(source));contextKeys.push(fakeContextKey);redirects[fakeContextKey]={source,destination,permanent:Boolean(redirect.permanent),external:isExternalRedirect,methods:redirect.methods};}}if(options.rewrites){for(const rewrite of options.rewrites){const source=rewrite.source.replace(/^\\.?\\//,'');const targetDestination=(0,matchers_1.stripInvisibleSegmentsFromPath)((0,matchers_1.removeFileSystemDots)((0,matchers_1.removeSupportedExtensions)(rewrite.destination)));const normalizedSource=(0,matchers_1.removeFileSystemDots)((0,matchers_1.removeSupportedExtensions)(source));if(ignoreList.some(regex=>regex.test(normalizedSource))){continue;}validRedirectDestinations??=contextKeys.map(key=>{return[(0,matchers_1.stripInvisibleSegmentsFromPath)((0,matchers_1.removeFileSystemDots)((0,matchers_1.removeSupportedExtensions)(key))),key];});const destination=validRedirectDestinations.find(key=>key[0]===targetDestination)?.[1];if(!destination){if(options.preserveApiRoutes){throw new Error(`Redirect destination \"${rewrite.destination}\" does not exist.`);}continue;}const fakeContextKey=`./${source}.tsx`;contextKeys.push(fakeContextKey);rewrites[fakeContextKey]={source,destination,methods:rewrite.methods};}}}for(const filePath of contextKeys){if(ignoreList.some(regex=>regex.test(filePath))){continue;}isValid=true;const meta=getFileMeta(filePath,options,redirects,rewrites);if(meta.specificity<0){continue;}let node={type:meta.isApi?'api':meta.isLayout?'layout':'route',loadRoute(){let routeModule;if(options.ignoreRequireErrors){try{routeModule=contextModule(filePath);}catch{routeModule={};}}else{routeModule=contextModule(filePath);}if(false&&importMode==='sync'){if(routeModule instanceof Promise){throw new Error(`Route \"${filePath}\" cannot be a promise when async routes is disabled.`);}const defaultExport=routeModule?.default;if(defaultExport instanceof Promise){throw new Error(`The default export from route \"${filePath}\" is a promise. Ensure the React Component does not use async or promises.`);}if(defaultExport instanceof Function&&defaultExport.constructor.name==='AsyncFunction'){throw new Error(`The default export from route \"${filePath}\" is an async function. Ensure the React Component does not use async or promises.`);}}return routeModule;},contextKey:filePath,route:'',dynamic:null,children:[]};if(meta.isRedirect){node.destinationContextKey=redirects[filePath].destination;node.permanent=redirects[filePath].permanent;node.generated=true;if(node.type==='route'){node=options.getSystemRoute({type:'redirect',route:(0,matchers_1.removeFileSystemDots)((0,matchers_1.removeSupportedExtensions)(node.destinationContextKey))},node);}if(redirects[filePath].methods){node.methods=redirects[filePath].methods;}node.type='redirect';}if(meta.isRewrite){node.destinationContextKey=rewrites[filePath].destination;node.generated=true;if(node.type==='route'){node=options.getSystemRoute({type:'rewrite',route:(0,matchers_1.removeFileSystemDots)((0,matchers_1.removeSupportedExtensions)(node.destinationContextKey))},node);}if(redirects[filePath].methods){node.methods=redirects[filePath].methods;}node.type='rewrite';}if(false){if(node.type!=='api'&&importMode==='sync'){const routeItem=node.loadRoute();const route=routeItem?.default;if(route==null){console.warn(`Route \"${filePath}\" is missing the required default export. Ensure a React component is exported as default.`);continue;}if(['boolean','number','string'].includes(typeof route)){throw new Error(`The default export from route \"${filePath}\" is an unsupported type: \"${typeof route}\". Only React Components are supported as default exports from route files.`);}}}for(const route of extrapolateGroups(meta.route)){const subdirectoryParts=route.split('/').slice(0,-1);let directory=rootDirectory;for(const part of subdirectoryParts){let subDirectory=directory.subdirectories.get(part);if(!subDirectory){subDirectory={files:new Map(),subdirectories:new Map()};directory.subdirectories.set(part,subDirectory);}directory=subDirectory;}node=Object.assign({},node,{route});if(meta.isLayout){directory.layout??=[];const existing=directory.layout[meta.specificity];if(existing){if(false){throw new Error(`The layouts \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Please remove or rename one of these files.`);}}else{node=getLayoutNode(node,options);directory.layout[meta.specificity]=node;}}else if(meta.isApi){const fileKey=`${route}+api`;let nodes=directory.files.get(fileKey);if(!nodes){nodes=[];directory.files.set(fileKey,nodes);}const existing=nodes[0];if(existing){if(false){throw new Error(`The API route file \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Please remove or rename one of these files.`);}}else{nodes[0]=node;}}else{let nodes=directory.files.get(route);if(!nodes){nodes=[];directory.files.set(route,nodes);}const existing=nodes[meta.specificity];if(existing){if(false){throw new Error(`The route files \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Please remove or rename one of these files.`);}}else{hasRoutes||=true;nodes[meta.specificity]=node;}}}}if(!isValid){return null;}if(!rootDirectory.layout){rootDirectory.layout=[options.getSystemRoute({type:'layout',route:''})];}if(!options.skipGenerated){if(hasRoutes&&options.sitemap!==false){appendSitemapRoute(rootDirectory,options);}if(options.notFound!==false){appendNotFoundRoute(rootDirectory,options);}}return rootDirectory;}function flattenDirectoryTreeToRoutes(directory,options,layout,pathToRemove=''){if(directory.layout){const previousLayout=layout;layout=getMostSpecific(directory.layout);if(previousLayout){previousLayout.children.push(layout);}if(options.internal_stripLoadRoute){delete layout.loadRoute;}const newRoute=layout.route.replace(pathToRemove,'');pathToRemove=layout.route?`${layout.route}/`:'';layout.route=newRoute;layout.dynamic=generateDynamic(layout.contextKey.slice(0));}if(!layout)throw new Error('Expo Router Internal Error: No nearest layout');for(const routes of directory.files.values()){const routeNode=getMostSpecific(routes);routeNode.route=routeNode.route.replace(pathToRemove,'');routeNode.dynamic=generateDynamic(routeNode.route);if(options.internal_stripLoadRoute){delete routeNode.loadRoute;}layout.children.push(routeNode);}for(const child of directory.subdirectories.values()){flattenDirectoryTreeToRoutes(child,options,layout,pathToRemove);}return layout;}function getFileMeta(originalKey,options,redirects,rewrites){const key=(0,matchers_1.removeSupportedExtensions)((0,matchers_1.removeFileSystemDots)(originalKey));let route=key;const parts=(0,matchers_1.removeFileSystemDots)(originalKey).split('/');const filename=parts[parts.length-1];const[filenameWithoutExtensions,platformExtension]=(0,matchers_1.removeSupportedExtensions)(filename).split('.');const isLayout=filenameWithoutExtensions==='_layout';const isApi=originalKey.match(/\\+api\\.(\\w+\\.)?[jt]sx?$/);if(filenameWithoutExtensions.startsWith('(')&&filenameWithoutExtensions.endsWith(')')){throw new Error(`Invalid route ${originalKey}. Routes cannot end with '(group)' syntax`);}if(!isApi&&filename.startsWith('+')&&filenameWithoutExtensions!=='+not-found'){const renamedRoute=[...parts.slice(0,-1),filename.slice(1)].join('/');throw new Error(`Invalid route ${originalKey}. Route nodes cannot start with the '+' character. \"Please rename to ${renamedRoute}\"`);}let specificity=0;const hasPlatformExtension=validPlatforms.has(platformExtension);const usePlatformRoutes=options.platformRoutes??true;if(hasPlatformExtension){if(!usePlatformRoutes){specificity=-1;}else if(!options.platform){specificity=-1;}else if(platformExtension===options.platform){specificity=2;}else if(platformExtension==='native'&&options.platform!=='web'){specificity=1;}else if(platformExtension!==options.platform){specificity=-1;}if(isApi&&specificity!==0){throw new Error(`Api routes cannot have platform extensions. Please remove '.${platformExtension}' from '${originalKey}'`);}route=route.replace(new RegExp(`.${platformExtension}$`),'');}return{route,specificity,isLayout,isApi,isRedirect:key in redirects,isRewrite:key in rewrites};}function getIgnoreList(options){const ignore=[/^\\.\\/\\+html\\.[tj]sx?$/,...(options?.ignore??[])];if(options?.preserveApiRoutes!==true){ignore.push(/\\+api\\.[tj]sx?$/);}return ignore;}function extrapolateGroups(key,keys=new Set()){const match=(0,matchers_1.matchArrayGroupName)(key);if(!match){keys.add(key);return keys;}const groups=match.split(',');const groupsSet=new Set(groups);if(groupsSet.size!==groups.length){throw new Error(`Array syntax cannot contain duplicate group name \"${groups}\" in \"${key}\".`);}if(groups.length===1){keys.add(key);return keys;}for(const group of groups){extrapolateGroups(key.replace(match,group.trim()),keys);}return keys;}function generateDynamic(path){const dynamic=path.split('/').map(part=>{if(part==='+not-found'){return{name:'+not-found',deep:true,notFound:true};}const deepDynamicName=(0,matchers_1.matchDeepDynamicRouteName)(part);const dynamicName=deepDynamicName??(0,matchers_1.matchDynamicName)(part);if(!dynamicName)return null;return{name:dynamicName,deep:!!deepDynamicName};}).filter(part=>!!part);return dynamic.length===0?null:dynamic;}function appendSitemapRoute(directory,options){if(!directory.files.has('_sitemap')&&options.getSystemRoute){directory.files.set('_sitemap',[options.getSystemRoute({type:'route',route:'_sitemap'})]);}}function appendNotFoundRoute(directory,options){if(!directory.files.has('+not-found')&&options.getSystemRoute){directory.files.set('+not-found',[options.getSystemRoute({type:'route',route:'+not-found'})]);}}function getLayoutNode(node,options){const groupName=(0,matchers_1.matchLastGroupName)(node.route);const childMatchingGroup=node.children.find(child=>{return child.route.replace(/\\/index$/,'')===groupName;});let anchor=childMatchingGroup?.route;const loaded=node.loadRoute();if(loaded?.unstable_settings){try{anchor=loaded.unstable_settings.anchor??loaded.unstable_settings.initialRouteName??anchor;}catch(error){if(error instanceof Error){if(!error.message.match(/You cannot dot into a client module/)){throw error;}}}if(groupName){const groupSpecificInitialRouteName=loaded.unstable_settings?.[groupName]?.anchor??loaded.unstable_settings?.[groupName]?.initialRouteName;anchor=groupSpecificInitialRouteName??anchor;}}return Object.assign({},node,{route:node.route.replace(/\\/?_layout$/,''),children:[],initialRouteName:anchor});}function crawlAndAppendInitialRoutesAndEntryFiles(node,options,entryPoints=[]){if(node.type==='route'){node.entryPoints=[...new Set([...entryPoints,node.contextKey])];}else if(node.type==='redirect'){node.entryPoints=[...new Set([...entryPoints,node.destinationContextKey])];}else if(node.type==='layout'){if(!node.children){throw new Error(`Layout \"${node.contextKey}\" does not contain any child routes`);}entryPoints=[...entryPoints,node.contextKey];const groupName=(0,matchers_1.matchGroupName)(node.route);const childMatchingGroup=node.children.find(child=>{return child.route.replace(/\\/index$/,'')===groupName;});let anchor=childMatchingGroup?.route;if(!options.internal_stripLoadRoute){const loaded=node.loadRoute();if(loaded?.unstable_settings){try{anchor=loaded.unstable_settings.anchor??loaded.unstable_settings.initialRouteName??anchor;}catch(error){if(error instanceof Error){if(!error.message.match(/You cannot dot into a client module/)){throw error;}}}if(groupName){const groupSpecificInitialRouteName=loaded.unstable_settings?.[groupName]?.anchor??loaded.unstable_settings?.[groupName]?.initialRouteName;anchor=groupSpecificInitialRouteName??anchor;}}}if(anchor){const anchorRoute=node.children.find(child=>child.route===anchor);if(!anchorRoute){const validAnchorRoutes=node.children.filter(child=>!child.generated).map(child=>`'${child.route}'`).join(', ');if(groupName){throw new Error(`Layout ${node.contextKey} has invalid anchor '${anchor}' for group '(${groupName})'. Valid options are: ${validAnchorRoutes}`);}else{throw new Error(`Layout ${node.contextKey} has invalid anchor '${anchor}'. Valid options are: ${validAnchorRoutes}`);}}node.initialRouteName=anchor;entryPoints.push(anchorRoute.contextKey);}for(const child of node.children){crawlAndAppendInitialRoutesAndEntryFiles(child,options,entryPoints);}}}function getMostSpecific(routes){const route=routes[routes.length-1];if(!routes[0]){throw new Error(`The file ${route.contextKey} does not have a fallback sibling file without a platform extension.`);}return routes[routes.length-1];}","map":{"version":3,"names":["exports","getRoutes","getIgnoreList","extrapolateGroups","generateDynamic","matchers_1","require","url_1","validPlatforms","Set","contextModule","options","directoryTree","getDirectoryTree","rootNode","flattenDirectoryTreeToRoutes","ignoreEntryPoints","crawlAndAppendInitialRoutesAndEntryFiles","importMode","ignoreList","ignore","push","preserveApiRoutes","rootDirectory","files","Map","subdirectories","hasRoutes","isValid","contextKeys","keys","redirects","rewrites","validRedirectDestinations","preserveRedirectAndRewrites","redirect","source","replace","isExternalRedirect","shouldLinkExternally","destination","targetDestination","stripInvisibleSegmentsFromPath","removeFileSystemDots","removeFileSystemExtensions","normalizedSource","removeSupportedExtensions","some","regex","test","map","key","find","Error","fakeContextKey","permanent","Boolean","external","methods","rewrite","filePath","meta","getFileMeta","specificity","node","type","isApi","isLayout","loadRoute","routeModule","ignoreRequireErrors","Promise","defaultExport","default","Function","constructor","name","contextKey","route","dynamic","children","isRedirect","destinationContextKey","generated","getSystemRoute","isRewrite","routeItem","console","warn","includes","subdirectoryParts","split","slice","directory","part","subDirectory","get","set","Object","assign","layout","existing","getLayoutNode","fileKey","nodes","skipGenerated","sitemap","appendSitemapRoute","notFound","appendNotFoundRoute","pathToRemove","previousLayout","getMostSpecific","internal_stripLoadRoute","newRoute","routes","values","routeNode","child","originalKey","parts","filename","length","filenameWithoutExtensions","platformExtension","match","startsWith","endsWith","renamedRoute","join","hasPlatformExtension","has","usePlatformRoutes","platformRoutes","platform","RegExp","matchArrayGroupName","add","groups","groupsSet","size","group","trim","path","deep","deepDynamicName","matchDeepDynamicRouteName","dynamicName","matchDynamicName","filter","groupName","matchLastGroupName","childMatchingGroup","anchor","loaded","unstable_settings","initialRouteName","error","message","groupSpecificInitialRouteName","entryPoints","matchGroupName","anchorRoute","validAnchorRoutes"],"sources":["/home/user/rork-vibesync-458/node_modules/expo-router/src/getRoutesCore.ts"],"sourcesContent":["import type { DynamicConvention, RouteNode } from './Route';\nimport {\n  matchArrayGroupName,\n  matchDeepDynamicRouteName,\n  matchDynamicName,\n  matchGroupName,\n  matchLastGroupName,\n  removeFileSystemDots,\n  removeFileSystemExtensions,\n  removeSupportedExtensions,\n  stripInvisibleSegmentsFromPath,\n} from './matchers';\nimport type { RequireContext } from './types';\nimport { shouldLinkExternally } from './utils/url';\n\nexport type Options = {\n  ignore?: RegExp[];\n  preserveApiRoutes?: boolean;\n  ignoreRequireErrors?: boolean;\n  ignoreEntryPoints?: boolean;\n  /* Used to simplify testing for toEqual() comparison */\n  internal_stripLoadRoute?: boolean;\n  /* Used to simplify by skipping the generated routes */\n  skipGenerated?: boolean;\n  /* Skip the generated not found route  */\n  notFound?: boolean;\n  importMode?: string;\n  platformRoutes?: boolean;\n  sitemap?: boolean;\n  platform?: string;\n  redirects?: RedirectConfig[];\n  rewrites?: RewriteConfig[];\n  /* Keep redirects as valid routes within the RouteConfig tree */\n  preserveRedirectAndRewrites?: boolean;\n\n  /** Get the system route for a location. Useful for shimming React Native imports in SSR environments. */\n  getSystemRoute: (route: Pick<RouteNode, 'route' | 'type'>, defaults?: RouteNode) => RouteNode;\n};\n\ntype DirectoryNode = {\n  layout?: RouteNode[];\n  files: Map<string, RouteNode[]>;\n  subdirectories: Map<string, DirectoryNode>;\n};\n\nexport type RedirectConfig = {\n  source: string;\n  destination: string;\n  permanent?: boolean;\n  methods?: string[];\n  external?: boolean;\n};\n\nexport type RewriteConfig = {\n  source: string;\n  destination: string;\n  methods?: string[];\n};\n\nconst validPlatforms = new Set(['android', 'ios', 'native', 'web']);\n\n/**\n * Given a Metro context module, return an array of nested routes.\n *\n * This is a two step process:\n *  1. Convert the RequireContext keys (file paths) into a directory tree.\n *      - This should extrapolate array syntax into multiple routes\n *      - Routes are given a specificity score\n *  2. Flatten the directory tree into routes\n *      - Routes in directories without _layout files are hoisted to the nearest _layout\n *      - The name of the route is relative to the nearest _layout\n *      - If multiple routes have the same name, the most specific route is used\n */\nexport function getRoutes(contextModule: RequireContext, options: Options): RouteNode | null {\n  const directoryTree = getDirectoryTree(contextModule, options);\n\n  // If there are no routes\n  if (!directoryTree) {\n    return null;\n  }\n\n  const rootNode = flattenDirectoryTreeToRoutes(directoryTree, options);\n\n  if (!options.ignoreEntryPoints) {\n    crawlAndAppendInitialRoutesAndEntryFiles(rootNode, options);\n  }\n\n  return rootNode;\n}\n\n/**\n * Converts the RequireContext keys (file paths) into a directory tree.\n */\nfunction getDirectoryTree(contextModule: RequireContext, options: Options) {\n  const importMode = options.importMode || process.env.EXPO_ROUTER_IMPORT_MODE;\n\n  const ignoreList: RegExp[] = [/^\\.\\/\\+(html|native-intent)\\.[tj]sx?$/]; // Ignore the top level ./+html file\n\n  if (options.ignore) {\n    ignoreList.push(...options.ignore);\n  }\n  if (!options.preserveApiRoutes) {\n    ignoreList.push(/\\+api$/, /\\+api\\.[tj]sx?$/);\n  }\n\n  const rootDirectory: DirectoryNode = {\n    files: new Map(),\n    subdirectories: new Map(),\n  };\n\n  let hasRoutes = false;\n  let isValid = false;\n\n  const contextKeys = contextModule.keys();\n  const redirects: Record<string, RedirectConfig> = {};\n  const rewrites: Record<string, RewriteConfig> = {};\n\n  let validRedirectDestinations: [string, string][] | undefined;\n\n  // If we are keeping redirects as valid routes, then we need to add them to the contextKeys\n  // This is useful for generating a sitemap with redirects, or static site generation that includes redirects\n  if (options.preserveRedirectAndRewrites) {\n    if (options.redirects) {\n      for (const redirect of options.redirects) {\n        // Remove the leading `./` or `/`\n        const source = redirect.source.replace(/^\\.?\\//, '');\n\n        const isExternalRedirect = shouldLinkExternally(redirect.destination);\n\n        const targetDestination = isExternalRedirect\n          ? redirect.destination\n          : stripInvisibleSegmentsFromPath(\n              removeFileSystemDots(\n                removeFileSystemExtensions(redirect.destination.replace(/^\\.?\\/?/, ''))\n              )\n            );\n\n        const normalizedSource = removeFileSystemDots(removeSupportedExtensions(source));\n\n        if (ignoreList.some((regex) => regex.test(normalizedSource))) {\n          continue;\n        }\n\n        // Loop over this once and cache the valid destinations\n        validRedirectDestinations ??= contextKeys.map((key) => {\n          return [\n            stripInvisibleSegmentsFromPath(removeFileSystemDots(removeSupportedExtensions(key))),\n            key,\n          ];\n        });\n\n        const destination = isExternalRedirect\n          ? targetDestination\n          : validRedirectDestinations.find((key) => key[0] === targetDestination)?.[1];\n\n        if (!destination) {\n          /*\n           * Only throw the error when we are preserving the api routes\n           * When doing a static export, API routes will not exist so the redirect destination may not exist.\n           * The desired behavior for this error is to warn the user when running `expo start`, so its ok if\n           * `expo export` swallows this error.\n           */\n          if (options.preserveApiRoutes) {\n            throw new Error(`Redirect destination \"${redirect.destination}\" does not exist.`);\n          }\n\n          continue;\n        }\n\n        const fakeContextKey = removeFileSystemDots(removeSupportedExtensions(source));\n        contextKeys.push(fakeContextKey);\n        redirects[fakeContextKey] = {\n          source,\n          destination,\n          permanent: Boolean(redirect.permanent),\n          external: isExternalRedirect,\n          methods: redirect.methods,\n        };\n      }\n    }\n\n    if (options.rewrites) {\n      for (const rewrite of options.rewrites) {\n        // Remove the leading `./` or `/`\n        const source = rewrite.source.replace(/^\\.?\\//, '');\n        const targetDestination = stripInvisibleSegmentsFromPath(\n          removeFileSystemDots(removeSupportedExtensions(rewrite.destination))\n        );\n\n        const normalizedSource = removeFileSystemDots(removeSupportedExtensions(source));\n\n        if (ignoreList.some((regex) => regex.test(normalizedSource))) {\n          continue;\n        }\n\n        // Loop over this once and cache the valid destinations\n        validRedirectDestinations ??= contextKeys.map((key) => {\n          return [\n            stripInvisibleSegmentsFromPath(removeFileSystemDots(removeSupportedExtensions(key))),\n            key,\n          ];\n        });\n\n        const destination = validRedirectDestinations.find(\n          (key) => key[0] === targetDestination\n        )?.[1];\n\n        if (!destination) {\n          /*\n           * Only throw the error when we are preserving the api routes\n           * When doing a static export, API routes will not exist so the redirect destination may not exist.\n           * The desired behavior for this error is to warn the user when running `expo start`, so its ok if\n           * `expo export` swallows this error.\n           */\n          if (options.preserveApiRoutes) {\n            throw new Error(`Redirect destination \"${rewrite.destination}\" does not exist.`);\n          }\n\n          continue;\n        }\n\n        // Add a fake context key\n        const fakeContextKey = `./${source}.tsx`;\n        contextKeys.push(fakeContextKey);\n        rewrites[fakeContextKey] = { source, destination, methods: rewrite.methods };\n      }\n    }\n  }\n\n  for (const filePath of contextKeys) {\n    if (ignoreList.some((regex) => regex.test(filePath))) {\n      continue;\n    }\n\n    isValid = true;\n\n    const meta = getFileMeta(filePath, options, redirects, rewrites);\n\n    // This is a file that should be ignored. e.g maybe it has an invalid platform?\n    if (meta.specificity < 0) {\n      continue;\n    }\n\n    let node: RouteNode = {\n      type: meta.isApi ? 'api' : meta.isLayout ? 'layout' : 'route',\n      loadRoute() {\n        let routeModule: any;\n        if (options.ignoreRequireErrors) {\n          try {\n            routeModule = contextModule(filePath);\n          } catch {\n            routeModule = {};\n          }\n        } else {\n          routeModule = contextModule(filePath);\n        }\n\n        if (process.env.NODE_ENV === 'development' && importMode === 'sync') {\n          // In development mode, when async routes are disabled, add some extra error handling to improve the developer experience.\n          // This can be useful when you accidentally use an async function in a route file for the default export.\n          if (routeModule instanceof Promise) {\n            throw new Error(\n              `Route \"${filePath}\" cannot be a promise when async routes is disabled.`\n            );\n          }\n\n          const defaultExport = routeModule?.default;\n          if (defaultExport instanceof Promise) {\n            throw new Error(\n              `The default export from route \"${filePath}\" is a promise. Ensure the React Component does not use async or promises.`\n            );\n          }\n\n          // check if default is an async function without invoking it\n          if (\n            defaultExport instanceof Function &&\n            // This only works on web because Hermes support async functions so we have to transform them out.\n            defaultExport.constructor.name === 'AsyncFunction'\n          ) {\n            throw new Error(\n              `The default export from route \"${filePath}\" is an async function. Ensure the React Component does not use async or promises.`\n            );\n          }\n        }\n\n        return routeModule;\n      },\n      contextKey: filePath,\n      route: '', // This is overwritten during hoisting based upon the _layout\n      dynamic: null,\n      children: [], // While we are building the directory tree, we don't know the node's children just yet. This is added during hoisting\n    };\n\n    if (meta.isRedirect) {\n      node.destinationContextKey = redirects[filePath].destination;\n      node.permanent = redirects[filePath].permanent;\n      node.generated = true;\n      if (node.type === 'route') {\n        node = options.getSystemRoute(\n          {\n            type: 'redirect',\n            route: removeFileSystemDots(removeSupportedExtensions(node.destinationContextKey)),\n          },\n          node\n        );\n      }\n      if (redirects[filePath].methods) {\n        node.methods = redirects[filePath].methods;\n      }\n      node.type = 'redirect';\n    }\n\n    if (meta.isRewrite) {\n      node.destinationContextKey = rewrites[filePath].destination;\n      node.generated = true;\n      if (node.type === 'route') {\n        node = options.getSystemRoute(\n          {\n            type: 'rewrite',\n            route: removeFileSystemDots(removeSupportedExtensions(node.destinationContextKey)),\n          },\n          node\n        );\n      }\n      if (redirects[filePath].methods) {\n        node.methods = redirects[filePath].methods;\n      }\n      node.type = 'rewrite';\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      // If the user has set the `EXPO_ROUTER_IMPORT_MODE` to `sync` then we should\n      // filter the missing routes.\n      if (node.type !== 'api' && importMode === 'sync') {\n        const routeItem = node.loadRoute();\n        // Have a warning for nullish ex\n        const route = routeItem?.default;\n        if (route == null) {\n          // Do not throw an error since a user may just be creating a new route.\n          console.warn(\n            `Route \"${filePath}\" is missing the required default export. Ensure a React component is exported as default.`\n          );\n          continue;\n        }\n        if (['boolean', 'number', 'string'].includes(typeof route)) {\n          throw new Error(\n            `The default export from route \"${filePath}\" is an unsupported type: \"${typeof route}\". Only React Components are supported as default exports from route files.`\n          );\n        }\n      }\n    }\n\n    /**\n     * A single filepath may be extrapolated into multiple routes if it contains array syntax.\n     * Another way to thinking about is that a filepath node is present in multiple leaves of the directory tree.\n     */\n    for (const route of extrapolateGroups(meta.route)) {\n      // Traverse the directory tree to its leaf node, creating any missing directories along the way\n      const subdirectoryParts = route.split('/').slice(0, -1);\n\n      // Start at the root directory and traverse the path to the leaf directory\n      let directory = rootDirectory;\n\n      for (const part of subdirectoryParts) {\n        let subDirectory = directory.subdirectories.get(part);\n\n        // Create any missing subdirectories\n        if (!subDirectory) {\n          subDirectory = {\n            files: new Map(),\n            subdirectories: new Map(),\n          };\n          directory.subdirectories.set(part, subDirectory);\n        }\n\n        directory = subDirectory;\n      }\n\n      // Clone the node for this route\n      node = { ...node, route };\n\n      if (meta.isLayout) {\n        directory.layout ??= [];\n        const existing = directory.layout[meta.specificity];\n        if (existing) {\n          // In production, use the first route found\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(\n              `The layouts \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Please remove or rename one of these files.`\n            );\n          }\n        } else {\n          node = getLayoutNode(node, options);\n          directory.layout[meta.specificity] = node;\n        }\n      } else if (meta.isApi) {\n        const fileKey = `${route}+api`;\n        let nodes = directory.files.get(fileKey);\n\n        if (!nodes) {\n          nodes = [];\n          directory.files.set(fileKey, nodes);\n        }\n\n        // API Routes have no specificity, they are always the first node\n        const existing = nodes[0];\n\n        if (existing) {\n          // In production, use the first route found\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(\n              `The API route file \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Please remove or rename one of these files.`\n            );\n          }\n        } else {\n          nodes[0] = node;\n        }\n      } else {\n        let nodes = directory.files.get(route);\n\n        if (!nodes) {\n          nodes = [];\n          directory.files.set(route, nodes);\n        }\n\n        /**\n         * If there is an existing node with the same specificity, then we have a conflict.\n         * NOTE(Platform Routes):\n         *    We cannot check for specificity conflicts here, as we haven't processed all the context keys yet!\n         *    This will be checked during hoisting, as well as enforcing that all routes have a non-platform route.\n         */\n        const existing = nodes[meta.specificity];\n        if (existing) {\n          // In production, use the first route found\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(\n              `The route files \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Please remove or rename one of these files.`\n            );\n          }\n        } else {\n          hasRoutes ||= true;\n          nodes[meta.specificity] = node;\n        }\n      }\n    }\n  }\n\n  // If there are no routes/layouts then we should display the tutorial.\n  if (!isValid) {\n    return null;\n  }\n\n  /**\n   * If there are no top-level _layout, add a default _layout\n   * While this is a generated route, it will still be generated even if skipGenerated is true.\n   */\n  if (!rootDirectory.layout) {\n    rootDirectory.layout = [\n      options.getSystemRoute({\n        type: 'layout',\n        route: '',\n      }),\n    ];\n  }\n\n  // Only include the sitemap if there are routes.\n  if (!options.skipGenerated) {\n    if (hasRoutes && options.sitemap !== false) {\n      appendSitemapRoute(rootDirectory, options);\n    }\n    if (options.notFound !== false) {\n      appendNotFoundRoute(rootDirectory, options);\n    }\n  }\n  return rootDirectory;\n}\n\n/**\n * Flatten the directory tree into routes, hoisting routes to the nearest _layout.\n */\nfunction flattenDirectoryTreeToRoutes(\n  directory: DirectoryNode,\n  options: Options,\n  /* The nearest _layout file in the directory tree */\n  layout?: RouteNode,\n  /* Route names are relative to their layout */\n  pathToRemove = ''\n) {\n  /**\n   * This directory has a _layout file so it becomes the new target for hoisting routes.\n   */\n  if (directory.layout) {\n    const previousLayout = layout;\n    layout = getMostSpecific(directory.layout);\n\n    // Add the new layout as a child of its parent\n    if (previousLayout) {\n      previousLayout.children.push(layout);\n    }\n\n    if (options.internal_stripLoadRoute) {\n      delete (layout as any).loadRoute;\n    }\n\n    // `route` is the absolute pathname. We need to make this relative to the last _layout\n    const newRoute = layout.route.replace(pathToRemove, '');\n    pathToRemove = layout.route ? `${layout.route}/` : '';\n\n    // Now update this layout with the new relative route and dynamic conventions\n    layout.route = newRoute;\n    layout.dynamic = generateDynamic(layout.contextKey.slice(0));\n  }\n\n  // This should never occur as there will always be a root layout, but it makes the type system happy\n  if (!layout) throw new Error('Expo Router Internal Error: No nearest layout');\n\n  for (const routes of directory.files.values()) {\n    const routeNode = getMostSpecific(routes);\n\n    // `route` is the absolute pathname. We need to make this relative to the nearest layout\n    routeNode.route = routeNode.route.replace(pathToRemove, '');\n    routeNode.dynamic = generateDynamic(routeNode.route);\n\n    if (options.internal_stripLoadRoute) {\n      delete (routeNode as any).loadRoute;\n    }\n\n    layout.children.push(routeNode);\n  }\n\n  // Recursively flatten the subdirectories\n  for (const child of directory.subdirectories.values()) {\n    flattenDirectoryTreeToRoutes(child, options, layout, pathToRemove);\n  }\n\n  return layout;\n}\n\nfunction getFileMeta(\n  originalKey: string,\n  options: Options,\n  redirects: Record<string, RedirectConfig>,\n  rewrites: Record<string, RedirectConfig>\n) {\n  // Remove the leading `./`\n  const key = removeSupportedExtensions(removeFileSystemDots(originalKey));\n  let route = key;\n\n  const parts = removeFileSystemDots(originalKey).split('/');\n  const filename = parts[parts.length - 1];\n  const [filenameWithoutExtensions, platformExtension] =\n    removeSupportedExtensions(filename).split('.');\n\n  const isLayout = filenameWithoutExtensions === '_layout';\n  const isApi = originalKey.match(/\\+api\\.(\\w+\\.)?[jt]sx?$/);\n\n  if (filenameWithoutExtensions.startsWith('(') && filenameWithoutExtensions.endsWith(')')) {\n    throw new Error(`Invalid route ${originalKey}. Routes cannot end with '(group)' syntax`);\n  }\n\n  // Nested routes cannot start with the '+' character, except for the '+not-found' route\n  if (!isApi && filename.startsWith('+') && filenameWithoutExtensions !== '+not-found') {\n    const renamedRoute = [...parts.slice(0, -1), filename.slice(1)].join('/');\n    throw new Error(\n      `Invalid route ${originalKey}. Route nodes cannot start with the '+' character. \"Please rename to ${renamedRoute}\"`\n    );\n  }\n  let specificity = 0;\n\n  const hasPlatformExtension = validPlatforms.has(platformExtension);\n  const usePlatformRoutes = options.platformRoutes ?? true;\n\n  if (hasPlatformExtension) {\n    if (!usePlatformRoutes) {\n      // If the user has disabled platform routes, then we should ignore this file\n      specificity = -1;\n    } else if (!options.platform) {\n      // If we don't have a platform, then we should ignore this file\n      // This used by typed routes, sitemap, etc\n      specificity = -1;\n    } else if (platformExtension === options.platform) {\n      // If the platform extension is the same as the options.platform, then it is the most specific\n      specificity = 2;\n    } else if (platformExtension === 'native' && options.platform !== 'web') {\n      // `native` is allow but isn't as specific as the platform\n      specificity = 1;\n    } else if (platformExtension !== options.platform) {\n      // Somehow we have a platform extension that doesn't match the options.platform and it isn't native\n      // This is an invalid file and we will ignore it\n      specificity = -1;\n    }\n\n    if (isApi && specificity !== 0) {\n      throw new Error(\n        `Api routes cannot have platform extensions. Please remove '.${platformExtension}' from '${originalKey}'`\n      );\n    }\n\n    route = route.replace(new RegExp(`.${platformExtension}$`), '');\n  }\n\n  return {\n    route,\n    specificity,\n    isLayout,\n    isApi,\n    isRedirect: key in redirects,\n    isRewrite: key in rewrites,\n  };\n}\n\nexport function getIgnoreList(options?: Options) {\n  const ignore: RegExp[] = [/^\\.\\/\\+html\\.[tj]sx?$/, ...(options?.ignore ?? [])];\n  if (options?.preserveApiRoutes !== true) {\n    ignore.push(/\\+api\\.[tj]sx?$/);\n  }\n  return ignore;\n}\n\n/**\n * Generates a set of strings which have the router array syntax extrapolated.\n *\n * /(a,b)/(c,d)/e.tsx => new Set(['a/c/e.tsx', 'a/d/e.tsx', 'b/c/e.tsx', 'b/d/e.tsx'])\n */\nexport function extrapolateGroups(key: string, keys: Set<string> = new Set()): Set<string> {\n  const match = matchArrayGroupName(key);\n\n  if (!match) {\n    keys.add(key);\n    return keys;\n  }\n  const groups = match.split(',');\n  const groupsSet = new Set(groups);\n\n  if (groupsSet.size !== groups.length) {\n    throw new Error(`Array syntax cannot contain duplicate group name \"${groups}\" in \"${key}\".`);\n  }\n\n  if (groups.length === 1) {\n    keys.add(key);\n    return keys;\n  }\n\n  for (const group of groups) {\n    extrapolateGroups(key.replace(match, group.trim()), keys);\n  }\n\n  return keys;\n}\n\nexport function generateDynamic(path: string): DynamicConvention[] | null {\n  const dynamic = path\n    .split('/')\n    .map((part): DynamicConvention | null => {\n      if (part === '+not-found') {\n        return {\n          name: '+not-found',\n          deep: true,\n          notFound: true,\n        };\n      }\n\n      const deepDynamicName = matchDeepDynamicRouteName(part);\n      const dynamicName = deepDynamicName ?? matchDynamicName(part);\n\n      if (!dynamicName) return null;\n      return { name: dynamicName, deep: !!deepDynamicName };\n    })\n    .filter((part): part is DynamicConvention => !!part);\n\n  return dynamic.length === 0 ? null : dynamic;\n}\n\nfunction appendSitemapRoute(directory: DirectoryNode, options: Options) {\n  if (!directory.files.has('_sitemap') && options.getSystemRoute) {\n    directory.files.set('_sitemap', [\n      options.getSystemRoute({\n        type: 'route',\n        route: '_sitemap',\n      }),\n    ]);\n  }\n}\n\nfunction appendNotFoundRoute(directory: DirectoryNode, options: Options) {\n  if (!directory.files.has('+not-found') && options.getSystemRoute) {\n    directory.files.set('+not-found', [\n      options.getSystemRoute({\n        type: 'route',\n        route: '+not-found',\n      }),\n    ]);\n  }\n}\n\nfunction getLayoutNode(node: RouteNode, options: Options) {\n  /**\n   * A file called `(a,b)/(c)/_layout.tsx` will generate two _layout routes: `(a)/(c)/_layout` and `(b)/(c)/_layout`.\n   * Each of these layouts will have a different anchor based upon the first group name.\n   */\n  // We may strip loadRoute during testing\n  const groupName = matchLastGroupName(node.route);\n  const childMatchingGroup = node.children.find((child) => {\n    return child.route.replace(/\\/index$/, '') === groupName;\n  });\n  let anchor = childMatchingGroup?.route;\n  const loaded = node.loadRoute();\n  if (loaded?.unstable_settings) {\n    try {\n      // Allow unstable_settings={ initialRouteName: '...' } to override the default initial route name.\n      anchor =\n        loaded.unstable_settings.anchor ?? loaded.unstable_settings.initialRouteName ?? anchor;\n    } catch (error: any) {\n      if (error instanceof Error) {\n        if (!error.message.match(/You cannot dot into a client module/)) {\n          throw error;\n        }\n      }\n    }\n\n    if (groupName) {\n      // Allow unstable_settings={ 'custom': { initialRouteName: '...' } } to override the less specific initial route name.\n      const groupSpecificInitialRouteName =\n        loaded.unstable_settings?.[groupName]?.anchor ??\n        loaded.unstable_settings?.[groupName]?.initialRouteName;\n\n      anchor = groupSpecificInitialRouteName ?? anchor;\n    }\n  }\n\n  return {\n    ...node,\n    route: node.route.replace(/\\/?_layout$/, ''),\n    children: [], // Each layout should have its own children\n    initialRouteName: anchor,\n  };\n}\n\nfunction crawlAndAppendInitialRoutesAndEntryFiles(\n  node: RouteNode,\n  options: Options,\n  entryPoints: string[] = []\n) {\n  if (node.type === 'route') {\n    node.entryPoints = [...new Set([...entryPoints, node.contextKey])];\n  } else if (node.type === 'redirect') {\n    node.entryPoints = [...new Set([...entryPoints, node.destinationContextKey!])];\n  } else if (node.type === 'layout') {\n    if (!node.children) {\n      throw new Error(`Layout \"${node.contextKey}\" does not contain any child routes`);\n    }\n\n    // Every node below this layout will have it as an entryPoint\n    entryPoints = [...entryPoints, node.contextKey];\n\n    /**\n     * Calculate the initialRouteNode\n     *\n     * A file called `(a,b)/(c)/_layout.tsx` will generate two _layout routes: `(a)/(c)/_layout` and `(b)/(c)/_layout`.\n     * Each of these layouts will have a different anchor based upon the first group.\n     */\n    const groupName = matchGroupName(node.route);\n    const childMatchingGroup = node.children.find((child) => {\n      return child.route.replace(/\\/index$/, '') === groupName;\n    });\n    let anchor = childMatchingGroup?.route;\n    // We may strip loadRoute during testing\n    if (!options.internal_stripLoadRoute) {\n      const loaded = node.loadRoute();\n      if (loaded?.unstable_settings) {\n        try {\n          // Allow unstable_settings={ initialRouteName: '...' } to override the default initial route name.\n          anchor =\n            loaded.unstable_settings.anchor ?? loaded.unstable_settings.initialRouteName ?? anchor;\n        } catch (error: any) {\n          if (error instanceof Error) {\n            if (!error.message.match(/You cannot dot into a client module/)) {\n              throw error;\n            }\n          }\n        }\n\n        if (groupName) {\n          // Allow unstable_settings={ 'custom': { initialRouteName: '...' } } to override the less specific initial route name.\n          const groupSpecificInitialRouteName =\n            loaded.unstable_settings?.[groupName]?.anchor ??\n            loaded.unstable_settings?.[groupName]?.initialRouteName;\n\n          anchor = groupSpecificInitialRouteName ?? anchor;\n        }\n      }\n    }\n\n    if (anchor) {\n      const anchorRoute = node.children.find((child) => child.route === anchor);\n      if (!anchorRoute) {\n        const validAnchorRoutes = node.children\n          .filter((child) => !child.generated)\n          .map((child) => `'${child.route}'`)\n          .join(', ');\n\n        if (groupName) {\n          throw new Error(\n            `Layout ${node.contextKey} has invalid anchor '${anchor}' for group '(${groupName})'. Valid options are: ${validAnchorRoutes}`\n          );\n        } else {\n          throw new Error(\n            `Layout ${node.contextKey} has invalid anchor '${anchor}'. Valid options are: ${validAnchorRoutes}`\n          );\n        }\n      }\n\n      // Navigators can add initialsRoutes into the history, so they need to be to be included in the entryPoints\n      node.initialRouteName = anchor;\n      entryPoints.push(anchorRoute.contextKey);\n    }\n\n    for (const child of node.children) {\n      crawlAndAppendInitialRoutesAndEntryFiles(child, options, entryPoints);\n    }\n  }\n}\n\nfunction getMostSpecific(routes: RouteNode[]) {\n  const route = routes[routes.length - 1];\n\n  if (!routes[0]) {\n    throw new Error(\n      `The file ${route.contextKey} does not have a fallback sibling file without a platform extension.`\n    );\n  }\n\n  // This works even tho routes is holey array (e.g it might have index 0 and 2 but not 1)\n  // `.length` includes the holes in its count\n  return routes[routes.length - 1];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}