{"ast":null,"code":"import _objectWithoutPropertiesLoose from\"@babel/runtime/helpers/objectWithoutPropertiesLoose\";const _excluded=[\"uri\"];import{PermissionStatus}from'expo-modules-core';import DeviceEventEmitter from\"react-native-web/dist/exports/DeviceEventEmitter\";import{RecordingOptionsPresets}from'./Audio/RecordingConstants';async function getPermissionWithQueryAsync(name){if(!navigator||!navigator.permissions||!navigator.permissions.query)return null;try{const{state}=await navigator.permissions.query({name});switch(state){case'granted':return PermissionStatus.GRANTED;case'denied':return PermissionStatus.DENIED;default:return PermissionStatus.UNDETERMINED;}}catch{return PermissionStatus.UNDETERMINED;}}function getUserMedia(constraints){if(navigator.mediaDevices&&navigator.mediaDevices.getUserMedia){return navigator.mediaDevices.getUserMedia(constraints);}const getUserMedia=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||function(){const error=new Error('Permission unimplemented');error.code=0;error.name='NotAllowedError';throw error;};return new Promise((resolve,reject)=>{getUserMedia.call(navigator,constraints,resolve,reject);});}function getStatusFromMedia(media){if(!media){return{isLoaded:false,error:undefined};}const isPlaying=!!(media.currentTime>0&&!media.paused&&!media.ended&&media.readyState>2);const status={isLoaded:true,uri:media.src,progressUpdateIntervalMillis:100,durationMillis:media.duration*1000,positionMillis:media.currentTime*1000,shouldPlay:media.autoplay,isPlaying,isBuffering:false,rate:media.playbackRate,shouldCorrectPitch:false,volume:media.volume,audioPan:0,isMuted:media.muted,isLooping:media.loop,didJustFinish:media.ended};return status;}async function setStatusForMedia(media,status){if(status.positionMillis!==undefined){media.currentTime=status.positionMillis/1000;}if(status.shouldPlay!==undefined){if(status.shouldPlay){await media.play();}else{await media.pause();}}if(status.rate!==undefined){media.playbackRate=status.rate;}if(status.shouldCorrectPitch!==undefined){media.preservesPitch=status.shouldCorrectPitch;}if(status.volume!==undefined){media.volume=status.volume;}if(status.isMuted!==undefined){media.muted=status.isMuted;}if(status.isLooping!==undefined){media.loop=status.isLooping;}return getStatusFromMedia(media);}let mediaRecorder=null;let mediaRecorderUptimeOfLastStartResume=0;let mediaRecorderDurationAlreadyRecorded=0;let mediaRecorderIsRecording=false;function getAudioRecorderDurationMillis(){let duration=mediaRecorderDurationAlreadyRecorded;if(mediaRecorderIsRecording&&mediaRecorderUptimeOfLastStartResume>0){duration+=Date.now()-mediaRecorderUptimeOfLastStartResume;}return duration;}export default{async getStatusForVideo(element){return getStatusFromMedia(element);},async loadForVideo(element,nativeSource,fullInitialStatus){return getStatusFromMedia(element);},async unloadForVideo(element){return getStatusFromMedia(element);},async setStatusForVideo(element,status){return setStatusForMedia(element,status);},async replayVideo(element,status){return setStatusForMedia(element,status);},async setAudioMode(){},async setAudioIsEnabled(){},async getStatusForSound(element){return getStatusFromMedia(element);},async loadForSound(nativeSource,fullInitialStatus){const source=typeof nativeSource==='string'?nativeSource:nativeSource.uri;const media=new Audio(source);media.ontimeupdate=()=>{DeviceEventEmitter.emit('didUpdatePlaybackStatus',{key:media,status:getStatusFromMedia(media)});};media.onerror=()=>{DeviceEventEmitter.emit('ExponentAV.onError',{key:media,error:media.error.message});};const status=await setStatusForMedia(media,fullInitialStatus);return[media,status];},async unloadForSound(element){element.pause();element.removeAttribute('src');element.load();return getStatusFromMedia(element);},async setStatusForSound(element,status){return setStatusForMedia(element,status);},async replaySound(element,status){return setStatusForMedia(element,status);},async getAudioRecordingStatus(){return{canRecord:mediaRecorder?.state==='recording'||mediaRecorder?.state==='inactive',isRecording:mediaRecorder?.state==='recording',isDoneRecording:false,durationMillis:getAudioRecorderDurationMillis(),uri:null};},async prepareAudioRecorder(options){if(typeof navigator!=='undefined'&&!navigator.mediaDevices){throw new Error('No media devices available');}mediaRecorderUptimeOfLastStartResume=0;mediaRecorderDurationAlreadyRecorded=0;const stream=await getUserMedia({audio:true});mediaRecorder=new window.MediaRecorder(stream,options?.web||RecordingOptionsPresets.HIGH_QUALITY.web);mediaRecorder.addEventListener('pause',()=>{mediaRecorderDurationAlreadyRecorded=getAudioRecorderDurationMillis();mediaRecorderIsRecording=false;});mediaRecorder.addEventListener('resume',()=>{mediaRecorderUptimeOfLastStartResume=Date.now();mediaRecorderIsRecording=true;});mediaRecorder.addEventListener('start',()=>{mediaRecorderUptimeOfLastStartResume=Date.now();mediaRecorderDurationAlreadyRecorded=0;mediaRecorderIsRecording=true;});mediaRecorder.addEventListener('stop',()=>{mediaRecorderDurationAlreadyRecorded=getAudioRecorderDurationMillis();mediaRecorderIsRecording=false;stream.getTracks().forEach(track=>track.stop());});const _await$this$getAudioR=await this.getAudioRecordingStatus(),status=_objectWithoutPropertiesLoose(_await$this$getAudioR,_excluded);return{uri:null,status};},async startAudioRecording(){if(mediaRecorder===null){throw new Error('Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.');}if(mediaRecorder.state==='paused'){mediaRecorder.resume();}else{mediaRecorder.start();}return this.getAudioRecordingStatus();},async pauseAudioRecording(){if(mediaRecorder===null){throw new Error('Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.');}mediaRecorder.pause();return this.getAudioRecordingStatus();},async stopAudioRecording(){const _mediaRecorder=mediaRecorder;if(_mediaRecorder===null){throw new Error('Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.');}if(_mediaRecorder.state==='inactive'){return this.getAudioRecordingStatus();}const dataPromise=new Promise(resolve=>_mediaRecorder.addEventListener('dataavailable',e=>resolve(e.data)));_mediaRecorder.stop();const data=await dataPromise;const url=URL.createObjectURL(data);return Object.assign({},await this.getAudioRecordingStatus(),{uri:url});},async unloadAudioRecorder(){mediaRecorder=null;},async getPermissionsAsync(){const maybeStatus=await getPermissionWithQueryAsync('microphone');switch(maybeStatus){case PermissionStatus.GRANTED:return{status:PermissionStatus.GRANTED,expires:'never',canAskAgain:true,granted:true};case PermissionStatus.DENIED:return{status:PermissionStatus.DENIED,expires:'never',canAskAgain:true,granted:false};default:return await this.requestPermissionsAsync();}},async requestPermissionsAsync(){try{const stream=await getUserMedia({audio:true});stream.getTracks().forEach(track=>track.stop());return{status:PermissionStatus.GRANTED,expires:'never',canAskAgain:true,granted:true};}catch{return{status:PermissionStatus.DENIED,expires:'never',canAskAgain:true,granted:false};}}};","map":{"version":3,"names":["PermissionStatus","DeviceEventEmitter","RecordingOptionsPresets","getPermissionWithQueryAsync","name","navigator","permissions","query","state","GRANTED","DENIED","UNDETERMINED","getUserMedia","constraints","mediaDevices","webkitGetUserMedia","mozGetUserMedia","error","Error","code","Promise","resolve","reject","call","getStatusFromMedia","media","isLoaded","undefined","isPlaying","currentTime","paused","ended","readyState","status","uri","src","progressUpdateIntervalMillis","durationMillis","duration","positionMillis","shouldPlay","autoplay","isBuffering","rate","playbackRate","shouldCorrectPitch","volume","audioPan","isMuted","muted","isLooping","loop","didJustFinish","setStatusForMedia","play","pause","preservesPitch","mediaRecorder","mediaRecorderUptimeOfLastStartResume","mediaRecorderDurationAlreadyRecorded","mediaRecorderIsRecording","getAudioRecorderDurationMillis","Date","now","getStatusForVideo","element","loadForVideo","nativeSource","fullInitialStatus","unloadForVideo","setStatusForVideo","replayVideo","setAudioMode","setAudioIsEnabled","getStatusForSound","loadForSound","source","Audio","ontimeupdate","emit","key","onerror","message","unloadForSound","removeAttribute","load","setStatusForSound","replaySound","getAudioRecordingStatus","canRecord","isRecording","isDoneRecording","prepareAudioRecorder","options","stream","audio","window","MediaRecorder","web","HIGH_QUALITY","addEventListener","getTracks","forEach","track","stop","_await$this$getAudioR","_objectWithoutPropertiesLoose","_excluded","startAudioRecording","resume","start","pauseAudioRecording","stopAudioRecording","_mediaRecorder","dataPromise","e","data","url","URL","createObjectURL","Object","assign","unloadAudioRecorder","getPermissionsAsync","maybeStatus","expires","canAskAgain","granted","requestPermissionsAsync"],"sources":["/home/user/rork-vibesync-458/node_modules/expo-av/src/ExponentAV.web.ts"],"sourcesContent":["import { PermissionResponse, PermissionStatus } from 'expo-modules-core';\nimport { DeviceEventEmitter } from 'react-native';\n\nimport type { AVPlaybackNativeSource, AVPlaybackStatus, AVPlaybackStatusToSet } from './AV.types';\nimport type { RecordingStatus } from './Audio/Recording.types';\nimport { RecordingOptionsPresets } from './Audio/RecordingConstants';\n\nasync function getPermissionWithQueryAsync(\n  name: PermissionNameWithAdditionalValues\n): Promise<PermissionStatus | null> {\n  if (!navigator || !navigator.permissions || !navigator.permissions.query) return null;\n\n  try {\n    const { state } = await navigator.permissions.query({ name });\n    switch (state) {\n      case 'granted':\n        return PermissionStatus.GRANTED;\n      case 'denied':\n        return PermissionStatus.DENIED;\n      default:\n        return PermissionStatus.UNDETERMINED;\n    }\n  } catch {\n    // Firefox - TypeError: 'microphone' (value of 'name' member of PermissionDescriptor) is not a valid value for enumeration PermissionName.\n    return PermissionStatus.UNDETERMINED;\n  }\n}\n\nfunction getUserMedia(constraints: MediaStreamConstraints): Promise<MediaStream> {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n\n  // Some browsers partially implement mediaDevices. We can't just assign an object\n  // with getUserMedia as it would overwrite existing properties.\n  // Here, we will just add the getUserMedia property if it's missing.\n\n  // First get ahold of the legacy getUserMedia, if present\n  const getUserMedia =\n    // TODO: this method is deprecated, migrate to https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n    navigator.getUserMedia ||\n    navigator.webkitGetUserMedia ||\n    navigator.mozGetUserMedia ||\n    function () {\n      const error: any = new Error('Permission unimplemented');\n      error.code = 0;\n      error.name = 'NotAllowedError';\n      throw error;\n    };\n\n  return new Promise((resolve, reject) => {\n    // TODO(@kitten): The types indicates that this is incorrect.\n    // Please check whether this is correct!\n    // @ts-expect-error: The `successCallback` doesn't match a `resolve` function\n    getUserMedia.call(navigator, constraints, resolve, reject);\n  });\n}\n\nfunction getStatusFromMedia(media?: HTMLMediaElement): AVPlaybackStatus {\n  if (!media) {\n    return {\n      isLoaded: false,\n      error: undefined,\n    };\n  }\n\n  const isPlaying = !!(\n    media.currentTime > 0 &&\n    !media.paused &&\n    !media.ended &&\n    media.readyState > 2\n  );\n\n  const status: AVPlaybackStatus = {\n    isLoaded: true,\n    uri: media.src,\n    progressUpdateIntervalMillis: 100, //TODO: Bacon: Add interval between calls\n    durationMillis: media.duration * 1000,\n    positionMillis: media.currentTime * 1000,\n    // playableDurationMillis: media.buffered * 1000,\n    // seekMillisToleranceBefore?: number\n    // seekMillisToleranceAfter?: number\n    shouldPlay: media.autoplay,\n    isPlaying,\n    isBuffering: false, //media.waiting,\n    rate: media.playbackRate,\n    // TODO: Bacon: This seems too complicated right now: https://webaudio.github.io/web-audio-api/#dom-biquadfilternode-frequency\n    shouldCorrectPitch: false,\n    volume: media.volume,\n    audioPan: 0,\n    isMuted: media.muted,\n    isLooping: media.loop,\n    didJustFinish: media.ended,\n  };\n\n  return status;\n}\n\nasync function setStatusForMedia(\n  media: HTMLMediaElement,\n  status: AVPlaybackStatusToSet\n): Promise<AVPlaybackStatus> {\n  if (status.positionMillis !== undefined) {\n    media.currentTime = status.positionMillis / 1000;\n  }\n  // if (status.progressUpdateIntervalMillis !== undefined) {\n  //   media.progressUpdateIntervalMillis = status.progressUpdateIntervalMillis;\n  // }\n  // if (status.seekMillisToleranceBefore !== undefined) {\n  //   media.seekMillisToleranceBefore = status.seekMillisToleranceBefore;\n  // }\n  // if (status.seekMillisToleranceAfter !== undefined) {\n  //   media.seekMillisToleranceAfter = status.seekMillisToleranceAfter;\n  // }\n  // if (status.shouldCorrectPitch !== undefined) {\n  //   media.shouldCorrectPitch = status.shouldCorrectPitch;\n  // }\n  if (status.shouldPlay !== undefined) {\n    if (status.shouldPlay) {\n      await media.play();\n    } else {\n      await media.pause();\n    }\n  }\n  if (status.rate !== undefined) {\n    media.playbackRate = status.rate;\n  }\n  if (status.shouldCorrectPitch !== undefined) {\n    media.preservesPitch = status.shouldCorrectPitch;\n  }\n  if (status.volume !== undefined) {\n    media.volume = status.volume;\n  }\n  if (status.isMuted !== undefined) {\n    media.muted = status.isMuted;\n  }\n  if (status.isLooping !== undefined) {\n    media.loop = status.isLooping;\n  }\n\n  return getStatusFromMedia(media);\n}\n\nlet mediaRecorder: null | MediaRecorder = null;\nlet mediaRecorderUptimeOfLastStartResume: number = 0;\nlet mediaRecorderDurationAlreadyRecorded: number = 0;\nlet mediaRecorderIsRecording: boolean = false;\n\nfunction getAudioRecorderDurationMillis() {\n  let duration = mediaRecorderDurationAlreadyRecorded;\n  if (mediaRecorderIsRecording && mediaRecorderUptimeOfLastStartResume > 0) {\n    duration += Date.now() - mediaRecorderUptimeOfLastStartResume;\n  }\n  return duration;\n}\n\nexport default {\n  async getStatusForVideo(element: HTMLMediaElement): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async loadForVideo(\n    element: HTMLMediaElement,\n    nativeSource: AVPlaybackNativeSource,\n    fullInitialStatus: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async unloadForVideo(element: HTMLMediaElement): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async setStatusForVideo(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  async replayVideo(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  /* Audio */\n  async setAudioMode() {},\n  async setAudioIsEnabled() {},\n  async getStatusForSound(element: HTMLMediaElement) {\n    return getStatusFromMedia(element);\n  },\n  async loadForSound(\n    nativeSource: string | { uri: string; [key: string]: any },\n    fullInitialStatus: AVPlaybackStatusToSet\n  ): Promise<[HTMLMediaElement, AVPlaybackStatus]> {\n    const source = typeof nativeSource === 'string' ? nativeSource : nativeSource.uri;\n    const media = new Audio(source);\n\n    media.ontimeupdate = () => {\n      DeviceEventEmitter.emit('didUpdatePlaybackStatus', {\n        key: media,\n        status: getStatusFromMedia(media),\n      });\n    };\n\n    media.onerror = () => {\n      DeviceEventEmitter.emit('ExponentAV.onError', {\n        key: media,\n        error: media.error!.message,\n      });\n    };\n\n    const status = await setStatusForMedia(media, fullInitialStatus);\n\n    return [media, status];\n  },\n  async unloadForSound(element: HTMLMediaElement) {\n    element.pause();\n    element.removeAttribute('src');\n    element.load();\n    return getStatusFromMedia(element);\n  },\n  async setStatusForSound(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  async replaySound(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n\n  /* Recording */\n  //   async setUnloadedCallbackForAndroidRecording() {},\n  async getAudioRecordingStatus(): Promise<RecordingStatus> {\n    return {\n      canRecord: mediaRecorder?.state === 'recording' || mediaRecorder?.state === 'inactive',\n      isRecording: mediaRecorder?.state === 'recording',\n      isDoneRecording: false,\n      durationMillis: getAudioRecorderDurationMillis(),\n      uri: null,\n    };\n  },\n  // TODO(@kitten): Needs to be typed\n  async prepareAudioRecorder(options: any): Promise<{\n    uri: string | null;\n    // status is of type RecordingStatus, but without the canRecord field populated\n    status: Pick<RecordingStatus, Exclude<keyof RecordingStatus, 'canRecord'>>;\n  }> {\n    if (typeof navigator !== 'undefined' && !navigator.mediaDevices) {\n      throw new Error('No media devices available');\n    }\n\n    mediaRecorderUptimeOfLastStartResume = 0;\n    mediaRecorderDurationAlreadyRecorded = 0;\n\n    const stream = await getUserMedia({ audio: true });\n\n    mediaRecorder = new window.MediaRecorder(\n      stream,\n      options?.web || RecordingOptionsPresets.HIGH_QUALITY.web\n    );\n\n    mediaRecorder.addEventListener('pause', () => {\n      mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n      mediaRecorderIsRecording = false;\n    });\n\n    mediaRecorder.addEventListener('resume', () => {\n      mediaRecorderUptimeOfLastStartResume = Date.now();\n      mediaRecorderIsRecording = true;\n    });\n\n    mediaRecorder.addEventListener('start', () => {\n      mediaRecorderUptimeOfLastStartResume = Date.now();\n      mediaRecorderDurationAlreadyRecorded = 0;\n      mediaRecorderIsRecording = true;\n    });\n\n    mediaRecorder.addEventListener('stop', () => {\n      mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n      mediaRecorderIsRecording = false;\n\n      // Clears recording icon in Chrome tab\n      stream.getTracks().forEach((track) => track.stop());\n    });\n\n    const { uri, ...status } = await this.getAudioRecordingStatus();\n\n    return { uri: null, status };\n  },\n  async startAudioRecording(): Promise<RecordingStatus> {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    if (mediaRecorder.state === 'paused') {\n      mediaRecorder.resume();\n    } else {\n      mediaRecorder.start();\n    }\n\n    return this.getAudioRecordingStatus();\n  },\n  async pauseAudioRecording(): Promise<RecordingStatus> {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    // Set status to paused\n    mediaRecorder.pause();\n\n    return this.getAudioRecordingStatus();\n  },\n  async stopAudioRecording(): Promise<RecordingStatus> {\n    const _mediaRecorder = mediaRecorder;\n    if (_mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    if (_mediaRecorder.state === 'inactive') {\n      return this.getAudioRecordingStatus();\n    }\n\n    const dataPromise = new Promise<Blob>((resolve) =>\n      _mediaRecorder.addEventListener('dataavailable', (e) => resolve(e.data))\n    );\n\n    _mediaRecorder.stop();\n\n    const data = await dataPromise;\n    const url = URL.createObjectURL(data);\n\n    return {\n      ...(await this.getAudioRecordingStatus()),\n      uri: url,\n    };\n  },\n  async unloadAudioRecorder(): Promise<void> {\n    mediaRecorder = null;\n  },\n\n  async getPermissionsAsync(): Promise<PermissionResponse> {\n    const maybeStatus = await getPermissionWithQueryAsync('microphone');\n    switch (maybeStatus) {\n      case PermissionStatus.GRANTED:\n        return {\n          status: PermissionStatus.GRANTED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: true,\n        };\n      case PermissionStatus.DENIED:\n        return {\n          status: PermissionStatus.DENIED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: false,\n        };\n      default:\n        return await this.requestPermissionsAsync();\n    }\n  },\n  async requestPermissionsAsync(): Promise<PermissionResponse> {\n    try {\n      const stream = await getUserMedia({ audio: true });\n      stream.getTracks().forEach((track) => track.stop());\n      return {\n        status: PermissionStatus.GRANTED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: true,\n      };\n    } catch {\n      return {\n        status: PermissionStatus.DENIED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: false,\n      };\n    }\n  },\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}