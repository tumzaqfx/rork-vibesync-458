{"ast":null,"code":"\"use strict\";import*as queryString from'query-string';import{getPatternParts}from\"./getPatternParts.js\";import{validatePathConfig}from\"./validatePathConfig.js\";const getActiveRoute=state=>{const route=typeof state.index==='number'?state.routes[state.index]:state.routes[state.routes.length-1];if(route.state){return getActiveRoute(route.state);}return route;};const cachedNormalizedConfigs=new WeakMap();const getNormalizedConfigs=options=>{if(!options?.screens)return{};const cached=cachedNormalizedConfigs.get(options?.screens);if(cached)return cached;const normalizedConfigs=createNormalizedConfigs(options.screens);cachedNormalizedConfigs.set(options.screens,normalizedConfigs);return normalizedConfigs;};export function getPathFromState(state,options){if(state==null){throw Error(`Got '${String(state)}' for the navigation state. You must pass a valid state object.`);}if(options){validatePathConfig(options);}const configs=getNormalizedConfigs(options);let path='/';let current=state;const allParams={};while(current){let index=typeof current.index==='number'?current.index:0;let route=current.routes[index];let parts;let focusedParams;let currentOptions=configs;const focusedRoute=getActiveRoute(state);const nestedRouteNames=[];let hasNext=true;while(route.name in currentOptions&&hasNext){parts=currentOptions[route.name].parts;nestedRouteNames.push(route.name);if(route.params){const options=currentOptions[route.name];const currentParams=Object.fromEntries(Object.entries(route.params).map(([key,value])=>{if(value===undefined){if(options){const optional=options.parts?.find(part=>part.param===key)?.optional;if(optional){return null;}}else{return null;}}const stringify=options?.stringify?.[key]??String;return[key,stringify(value)];}).filter(entry=>entry!=null));if(parts?.length){Object.assign(allParams,currentParams);}if(focusedRoute===route){focusedParams=Object.assign({},currentParams);parts?.forEach(({param})=>{if(param){if(focusedParams){delete focusedParams[param];}}});}}if(!currentOptions[route.name].screens||route.state===undefined){hasNext=false;}else{index=typeof route.state.index==='number'?route.state.index:route.state.routes.length-1;const nextRoute=route.state.routes[index];const nestedConfig=currentOptions[route.name].screens;if(nestedConfig&&nextRoute.name in nestedConfig){route=nextRoute;currentOptions=nestedConfig;}else{hasNext=false;}}}if(currentOptions[route.name]!==undefined){path+=parts?.map(({segment,param,optional})=>{if(segment==='*'){return route.name;}if(param){const value=allParams[param];if(value===undefined&&optional){return'';}return String(value).replace(/[^A-Za-z0-9\\-._~!$&'()*+,;=:@]/g,char=>encodeURIComponent(char));}return encodeURIComponent(segment);}).join('/');}else{path+=encodeURIComponent(route.name);}if(!focusedParams&&focusedRoute.params){focusedParams=Object.fromEntries(Object.entries(focusedRoute.params).map(([key,value])=>[key,String(value)]));}if(route.state){path+='/';}else if(focusedParams){for(const param in focusedParams){if(focusedParams[param]==='undefined'){delete focusedParams[param];}}const query=queryString.stringify(focusedParams,{sort:false});if(query){path+=`?${query}`;}}current=route.state;}if(options?.path){path=`${options.path}/${path}`;}path=path.replace(/\\/+/g,'/');path=path.length>1?path.replace(/\\/$/,''):path;if(!path.startsWith('/')){path=`/${path}`;}return path;}const createConfigItem=(config,parentParts)=>{if(typeof config==='string'){const parts=getPatternParts(config);if(parentParts){return{parts:[...parentParts,...parts]};}return{parts};}if(config.exact&&config.path===undefined){throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");}const parts=config.exact!==true?[...(parentParts||[]),...(config.path?getPatternParts(config.path):[])]:config.path?getPatternParts(config.path):undefined;const screens=config.screens?createNormalizedConfigs(config.screens,parts):undefined;return{parts,stringify:config.stringify,screens};};const createNormalizedConfigs=(options,parts)=>Object.fromEntries(Object.entries(options).map(([name,c])=>{const result=createConfigItem(c,parts);return[name,result];}));","map":{"version":3,"names":["queryString","getPatternParts","validatePathConfig","getActiveRoute","state","route","index","routes","length","cachedNormalizedConfigs","WeakMap","getNormalizedConfigs","options","screens","cached","get","normalizedConfigs","createNormalizedConfigs","set","getPathFromState","Error","String","configs","path","current","allParams","parts","focusedParams","currentOptions","focusedRoute","nestedRouteNames","hasNext","name","push","params","currentParams","Object","fromEntries","entries","map","key","value","undefined","optional","find","part","param","stringify","filter","entry","assign","forEach","nextRoute","nestedConfig","segment","replace","char","encodeURIComponent","join","query","sort","startsWith","createConfigItem","config","parentParts","exact","c","result"],"sources":["/home/user/rork-vibesync-458/node_modules/@react-navigation/core/src/getPathFromState.tsx"],"sourcesContent":["import type {\n  NavigationState,\n  PartialState,\n  Route,\n} from '@react-navigation/routers';\nimport * as queryString from 'query-string';\n\nimport { getPatternParts, type PatternPart } from './getPatternParts';\nimport type { PathConfig, PathConfigMap } from './types';\nimport { validatePathConfig } from './validatePathConfig';\n\ntype Options<ParamList extends {}> = {\n  path?: string;\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n};\n\ntype State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\n\ntype StringifyConfig = Record<string, (value: unknown) => string>;\n\ntype ConfigItem = {\n  parts?: PatternPart[];\n  stringify?: StringifyConfig;\n  screens?: Record<string, ConfigItem>;\n};\n\nconst getActiveRoute = (state: State): { name: string; params?: object } => {\n  const route =\n    typeof state.index === 'number'\n      ? state.routes[state.index]\n      : state.routes[state.routes.length - 1];\n\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n\n  return route;\n};\n\nconst cachedNormalizedConfigs = new WeakMap<\n  PathConfigMap<{}>,\n  Record<string, ConfigItem>\n>();\n\nconst getNormalizedConfigs = (options?: Options<{}>) => {\n  if (!options?.screens) return {};\n\n  const cached = cachedNormalizedConfigs.get(options?.screens);\n\n  if (cached) return cached;\n\n  const normalizedConfigs = createNormalizedConfigs(options.screens);\n\n  cachedNormalizedConfigs.set(options.screens, normalizedConfigs);\n\n  return normalizedConfigs;\n};\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * @example\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         stringify: { author: author => author.toLowerCase() }\n *       }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport function getPathFromState<ParamList extends {}>(\n  state: State,\n  options?: Options<ParamList>\n): string {\n  if (state == null) {\n    throw Error(\n      `Got '${String(state)}' for the navigation state. You must pass a valid state object.`\n    );\n  }\n\n  if (options) {\n    validatePathConfig(options);\n  }\n\n  const configs = getNormalizedConfigs(options);\n\n  let path = '/';\n  let current: State | undefined = state;\n\n  const allParams: Record<string, string> = {};\n\n  while (current) {\n    let index = typeof current.index === 'number' ? current.index : 0;\n    let route = current.routes[index] as Route<string> & {\n      state?: State;\n    };\n\n    let parts: PatternPart[] | undefined;\n\n    let focusedParams: Record<string, string> | undefined;\n    let currentOptions = configs;\n\n    const focusedRoute = getActiveRoute(state);\n\n    // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined\n    const nestedRouteNames = [];\n\n    let hasNext = true;\n\n    while (route.name in currentOptions && hasNext) {\n      parts = currentOptions[route.name].parts;\n\n      nestedRouteNames.push(route.name);\n\n      if (route.params) {\n        const options = currentOptions[route.name];\n\n        const currentParams = Object.fromEntries(\n          Object.entries(route.params)\n            .map(([key, value]): [string, string] | null => {\n              if (value === undefined) {\n                if (options) {\n                  const optional = options.parts?.find(\n                    (part) => part.param === key\n                  )?.optional;\n\n                  if (optional) {\n                    return null;\n                  }\n                } else {\n                  return null;\n                }\n              }\n\n              const stringify = options?.stringify?.[key] ?? String;\n\n              return [key, stringify(value)];\n            })\n            .filter((entry) => entry != null)\n        );\n\n        if (parts?.length) {\n          Object.assign(allParams, currentParams);\n        }\n\n        if (focusedRoute === route) {\n          // If this is the focused route, keep the params for later use\n          // We save it here since it's been stringified already\n          focusedParams = { ...currentParams };\n\n          parts\n            // eslint-disable-next-line no-loop-func\n            ?.forEach(({ param }) => {\n              if (param) {\n                // Remove the params present in the pattern since we'll only use the rest for query string\n                if (focusedParams) {\n                  // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                  delete focusedParams[param];\n                }\n              }\n            });\n        }\n      }\n\n      // If there is no `screens` property or no nested state, we return pattern\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index =\n          typeof route.state.index === 'number'\n            ? route.state.index\n            : route.state.routes.length - 1;\n\n        const nextRoute = route.state.routes[index];\n        const nestedConfig = currentOptions[route.name].screens;\n\n        // if there is config for next route name, we go deeper\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute as Route<string> & { state?: State };\n          currentOptions = nestedConfig;\n        } else {\n          // If not, there is no sense in going deeper in config\n          hasNext = false;\n        }\n      }\n    }\n\n    if (currentOptions[route.name] !== undefined) {\n      path += parts\n        ?.map(({ segment, param, optional }) => {\n          // We don't know what to show for wildcard patterns\n          // Showing the route name seems ok, though whatever we show here will be incorrect\n          // Since the page doesn't actually exist\n          if (segment === '*') {\n            return route.name;\n          }\n\n          // If the path has a pattern for a param, put the param in the path\n          if (param) {\n            const value = allParams[param];\n\n            if (value === undefined && optional) {\n              // Optional params without value assigned in route.params should be ignored\n              return '';\n            }\n\n            // Valid characters according to\n            // https://datatracker.ietf.org/doc/html/rfc3986#section-3.3 (see pchar definition)\n            return String(value).replace(\n              /[^A-Za-z0-9\\-._~!$&'()*+,;=:@]/g,\n              (char) => encodeURIComponent(char)\n            );\n          }\n\n          return encodeURIComponent(segment);\n        })\n        .join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n\n    if (!focusedParams && focusedRoute.params) {\n      focusedParams = Object.fromEntries(\n        Object.entries(focusedRoute.params).map(([key, value]) => [\n          key,\n          String(value),\n        ])\n      );\n    }\n\n    if (route.state) {\n      path += '/';\n    } else if (focusedParams) {\n      for (const param in focusedParams) {\n        if (focusedParams[param] === 'undefined') {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete focusedParams[param];\n        }\n      }\n\n      const query = queryString.stringify(focusedParams, { sort: false });\n\n      if (query) {\n        path += `?${query}`;\n      }\n    }\n\n    current = route.state;\n  }\n\n  // Include the root path if specified\n  if (options?.path) {\n    path = `${options.path}/${path}`;\n  }\n\n  // Remove multiple as well as trailing slashes\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n\n  // If path doesn't start with a slash, add it\n  // This makes sure that history.pushState will update the path correctly instead of appending\n  if (!path.startsWith('/')) {\n    path = `/${path}`;\n  }\n\n  return path;\n}\n\nconst createConfigItem = (\n  config: PathConfig<object> | string,\n  parentParts?: PatternPart[]\n): ConfigItem => {\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const parts = getPatternParts(config);\n\n    if (parentParts) {\n      return { parts: [...parentParts, ...parts] };\n    }\n\n    return { parts };\n  }\n\n  if (config.exact && config.path === undefined) {\n    throw new Error(\n      \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n    );\n  }\n\n  // If an object is specified as the value (e.g. Foo: { ... }),\n  // It can have `path` property and `screens` prop which has nested configs\n  const parts =\n    config.exact !== true\n      ? [\n          ...(parentParts || []),\n          ...(config.path ? getPatternParts(config.path) : []),\n        ]\n      : config.path\n        ? getPatternParts(config.path)\n        : undefined;\n\n  const screens = config.screens\n    ? createNormalizedConfigs(config.screens, parts)\n    : undefined;\n\n  return {\n    parts,\n    stringify: config.stringify,\n    screens,\n  };\n};\n\nconst createNormalizedConfigs = (\n  options: PathConfigMap<object>,\n  parts?: PatternPart[]\n): Record<string, ConfigItem> =>\n  Object.fromEntries(\n    Object.entries(options).map(([name, c]) => {\n      const result = createConfigItem(c, parts);\n\n      return [name, result];\n    })\n  );\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}