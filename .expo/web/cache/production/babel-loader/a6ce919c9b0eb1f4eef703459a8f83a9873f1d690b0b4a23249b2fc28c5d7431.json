{"ast":null,"code":"import{registerHandler}from'../../handlersRegistry';import RNGestureHandlerModule from'../../../RNGestureHandlerModule';import{filterConfig,scheduleFlushOperations}from'../../utils';import{ghQueueMicrotask}from'../../../ghQueueMicrotask';import{extractGestureRelations,checkGestureCallbacksForWorklets,ALLOWED_PROPS}from'./utils';export function updateHandlers(preparedGesture,gestureConfig,newGestures){gestureConfig.prepare();for(let i=0;i<newGestures.length;i++){const handler=preparedGesture.attachedGestures[i];checkGestureCallbacksForWorklets(handler);if(newGestures[i].handlerTag!==handler.handlerTag){newGestures[i].handlerTag=handler.handlerTag;newGestures[i].handlers.handlerTag=handler.handlerTag;}}ghQueueMicrotask(()=>{if(!preparedGesture.isMounted){return;}let shouldUpdateSharedValueIfUsed=preparedGesture.attachedGestures.length!==newGestures.length;for(let i=0;i<newGestures.length;i++){const handler=preparedGesture.attachedGestures[i];if(handler.handlers.gestureId!==newGestures[i].handlers.gestureId&&(newGestures[i].shouldUseReanimated||handler.shouldUseReanimated)){shouldUpdateSharedValueIfUsed=true;}handler.config=newGestures[i].config;handler.handlers=newGestures[i].handlers;RNGestureHandlerModule.updateGestureHandler(handler.handlerTag,filterConfig(handler.config,ALLOWED_PROPS,extractGestureRelations(handler)));registerHandler(handler.handlerTag,handler,handler.config.testId);}if(preparedGesture.animatedHandlers&&shouldUpdateSharedValueIfUsed){const newHandlersValue=preparedGesture.attachedGestures.filter(g=>g.shouldUseReanimated).map(g=>g.handlers);preparedGesture.animatedHandlers.value=newHandlersValue;}scheduleFlushOperations();});}","map":{"version":3,"names":["registerHandler","RNGestureHandlerModule","filterConfig","scheduleFlushOperations","ghQueueMicrotask","extractGestureRelations","checkGestureCallbacksForWorklets","ALLOWED_PROPS","updateHandlers","preparedGesture","gestureConfig","newGestures","prepare","i","length","handler","attachedGestures","handlerTag","handlers","isMounted","shouldUpdateSharedValueIfUsed","gestureId","shouldUseReanimated","config","updateGestureHandler","testId","animatedHandlers","newHandlersValue","filter","g","map","value"],"sources":["/home/user/rork-vibesync-458/node_modules/react-native-gesture-handler/lib/module/handlers/gestures/GestureDetector/updateHandlers.ts"],"sourcesContent":["import { GestureType, HandlerCallbacks } from '../gesture';\nimport { registerHandler } from '../../handlersRegistry';\nimport RNGestureHandlerModule from '../../../RNGestureHandlerModule';\nimport { filterConfig, scheduleFlushOperations } from '../../utils';\nimport { ComposedGesture } from '../gestureComposition';\nimport { ghQueueMicrotask } from '../../../ghQueueMicrotask';\nimport { AttachedGestureState } from './types';\nimport {\n  extractGestureRelations,\n  checkGestureCallbacksForWorklets,\n  ALLOWED_PROPS,\n} from './utils';\n\nexport function updateHandlers(\n  preparedGesture: AttachedGestureState,\n  gestureConfig: ComposedGesture | GestureType,\n  newGestures: GestureType[]\n) {\n  gestureConfig.prepare();\n\n  for (let i = 0; i < newGestures.length; i++) {\n    const handler = preparedGesture.attachedGestures[i];\n    checkGestureCallbacksForWorklets(handler);\n\n    // Only update handlerTag when it's actually different, it may be the same\n    // if gesture config object is wrapped with useMemo\n    if (newGestures[i].handlerTag !== handler.handlerTag) {\n      newGestures[i].handlerTag = handler.handlerTag;\n      newGestures[i].handlers.handlerTag = handler.handlerTag;\n    }\n  }\n\n  // Use queueMicrotask to extract handlerTags, because when it's ran, all refs should be updated\n  // and handlerTags in BaseGesture references should be updated in the loop above (we need to wait\n  // in case of external relations)\n  ghQueueMicrotask(() => {\n    if (!preparedGesture.isMounted) {\n      return;\n    }\n\n    // If amount of gesture configs changes, we need to update the callbacks in shared value\n    let shouldUpdateSharedValueIfUsed =\n      preparedGesture.attachedGestures.length !== newGestures.length;\n\n    for (let i = 0; i < newGestures.length; i++) {\n      const handler = preparedGesture.attachedGestures[i];\n\n      // If the gestureId is different (gesture isn't wrapped with useMemo or its dependencies changed),\n      // we need to update the shared value, assuming the gesture runs on UI thread or the thread changed\n      if (\n        handler.handlers.gestureId !== newGestures[i].handlers.gestureId &&\n        (newGestures[i].shouldUseReanimated || handler.shouldUseReanimated)\n      ) {\n        shouldUpdateSharedValueIfUsed = true;\n      }\n\n      handler.config = newGestures[i].config;\n      handler.handlers = newGestures[i].handlers;\n\n      RNGestureHandlerModule.updateGestureHandler(\n        handler.handlerTag,\n        filterConfig(\n          handler.config,\n          ALLOWED_PROPS,\n          extractGestureRelations(handler)\n        )\n      );\n\n      registerHandler(handler.handlerTag, handler, handler.config.testId);\n    }\n\n    if (preparedGesture.animatedHandlers && shouldUpdateSharedValueIfUsed) {\n      const newHandlersValue = preparedGesture.attachedGestures\n        .filter((g) => g.shouldUseReanimated) // Ignore gestures that shouldn't run on UI\n        .map((g) => g.handlers) as unknown as HandlerCallbacks<\n        Record<string, unknown>\n      >[];\n\n      preparedGesture.animatedHandlers.value = newHandlersValue;\n    }\n\n    scheduleFlushOperations();\n  });\n}\n"],"mappings":"AACA,OAASA,eAAT,KAAgC,wBAAhC,CACA,MAAO,CAAAC,sBAAP,KAAmC,iCAAnC,CACA,OAASC,YAAT,CAAuBC,uBAAvB,KAAsD,aAAtD,CAEA,OAASC,gBAAT,KAAiC,2BAAjC,CAEA,OACEC,uBADF,CAEEC,gCAFF,CAGEC,aAHF,KAIO,SAJP,CAMA,MAAO,SAAS,CAAAC,cAATA,CACLC,eADK,CAELC,aAFK,CAGLC,WAHK,CAIL,CACAD,aAAa,CAACE,OAAd,GAEA,IAAK,GAAI,CAAAC,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGF,WAAW,CAACG,MAAhC,CAAwCD,CAAC,EAAzC,CAA6C,CAC3C,KAAM,CAAAE,OAAO,CAAGN,eAAe,CAACO,gBAAhB,CAAiCH,CAAjC,CAAhB,CACAP,gCAAgC,CAACS,OAAD,CAAhC,CAIA,GAAIJ,WAAW,CAACE,CAAD,CAAX,CAAeI,UAAf,GAA8BF,OAAO,CAACE,UAA1C,CAAsD,CACpDN,WAAW,CAACE,CAAD,CAAX,CAAeI,UAAf,CAA4BF,OAAO,CAACE,UAApC,CACAN,WAAW,CAACE,CAAD,CAAX,CAAeK,QAAf,CAAwBD,UAAxB,CAAqCF,OAAO,CAACE,UAA7C,CACD,CACF,CAKDb,gBAAgB,CAAC,IAAM,CACrB,GAAI,CAACK,eAAe,CAACU,SAArB,CAAgC,CAC9B,OACD,CAGD,GAAI,CAAAC,6BAA6B,CAC/BX,eAAe,CAACO,gBAAhB,CAAiCF,MAAjC,GAA4CH,WAAW,CAACG,MAD1D,CAGA,IAAK,GAAI,CAAAD,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGF,WAAW,CAACG,MAAhC,CAAwCD,CAAC,EAAzC,CAA6C,CAC3C,KAAM,CAAAE,OAAO,CAAGN,eAAe,CAACO,gBAAhB,CAAiCH,CAAjC,CAAhB,CAIA,GACEE,OAAO,CAACG,QAAR,CAAiBG,SAAjB,GAA+BV,WAAW,CAACE,CAAD,CAAX,CAAeK,QAAf,CAAwBG,SAAvD,GACCV,WAAW,CAACE,CAAD,CAAX,CAAeS,mBAAf,EAAsCP,OAAO,CAACO,mBAD/C,CADF,CAGE,CACAF,6BAA6B,CAAG,IAAhC,CACD,CAEDL,OAAO,CAACQ,MAAR,CAAiBZ,WAAW,CAACE,CAAD,CAAX,CAAeU,MAAhC,CACAR,OAAO,CAACG,QAAR,CAAmBP,WAAW,CAACE,CAAD,CAAX,CAAeK,QAAlC,CAEAjB,sBAAsB,CAACuB,oBAAvB,CACET,OAAO,CAACE,UADV,CAEEf,YAAY,CACVa,OAAO,CAACQ,MADE,CAEVhB,aAFU,CAGVF,uBAAuB,CAACU,OAAD,CAHb,CAFd,EASAf,eAAe,CAACe,OAAO,CAACE,UAAT,CAAqBF,OAArB,CAA8BA,OAAO,CAACQ,MAAR,CAAeE,MAA7C,CAAf,CACD,CAED,GAAIhB,eAAe,CAACiB,gBAAhB,EAAoCN,6BAAxC,CAAuE,CACrE,KAAM,CAAAO,gBAAgB,CAAGlB,eAAe,CAACO,gBAAhB,CACtBY,MADsB,CACdC,CAAD,EAAOA,CAAC,CAACP,mBADM,EAEtBQ,GAFsB,CAEjBD,CAAD,EAAOA,CAAC,CAACX,QAFS,CAAzB,CAMAT,eAAe,CAACiB,gBAAhB,CAAiCK,KAAjC,CAAyCJ,gBAAzC,CACD,CAEDxB,uBAAuB,GACxB,CA/Ce,CAAhB,CAgDD","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}