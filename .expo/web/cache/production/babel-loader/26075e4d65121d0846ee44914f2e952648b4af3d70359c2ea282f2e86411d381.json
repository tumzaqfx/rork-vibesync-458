{"ast":null,"code":"import _objectWithoutPropertiesLoose from\"@babel/runtime/helpers/objectWithoutPropertiesLoose\";const _excluded=[\"enabled\"];function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}import Hammer from'@egjs/hammerjs';import findNodeHandle from\"react-native-web/dist/exports/findNodeHandle\";import{State}from'../State';import{EventMap}from'./constants';import*as NodeManager from'./NodeManager';import{ghQueueMicrotask}from'../ghQueueMicrotask';let gestureInstances=0;class GestureHandler{get id(){return`${this.name}${this.gestureInstance}`;}get isNative(){return false;}get isDiscrete(){return false;}get shouldEnableGestureOnSetup(){throw new Error('Must override GestureHandler.shouldEnableGestureOnSetup');}constructor(){_defineProperty(this,\"handlerTag\",void 0);_defineProperty(this,\"isGestureRunning\",false);_defineProperty(this,\"view\",null);_defineProperty(this,\"hasCustomActivationCriteria\",void 0);_defineProperty(this,\"hasGestureFailed\",false);_defineProperty(this,\"hammer\",null);_defineProperty(this,\"initialRotation\",null);_defineProperty(this,\"__initialX\",void 0);_defineProperty(this,\"__initialY\",void 0);_defineProperty(this,\"config\",{});_defineProperty(this,\"previousState\",State.UNDETERMINED);_defineProperty(this,\"pendingGestures\",{});_defineProperty(this,\"oldState\",State.UNDETERMINED);_defineProperty(this,\"lastSentState\",null);_defineProperty(this,\"gestureInstance\",void 0);_defineProperty(this,\"_stillWaiting\",void 0);_defineProperty(this,\"propsRef\",void 0);_defineProperty(this,\"ref\",void 0);_defineProperty(this,\"clearSelfAsPending\",()=>{if(Array.isArray(this.config.waitFor)){for(const gesture of this.config.waitFor){gesture.removePendingGesture(this.id);}}});_defineProperty(this,\"destroy\",()=>{this.clearSelfAsPending();if(this.hammer){this.hammer.stop(false);this.hammer.destroy();}this.hammer=null;});_defineProperty(this,\"isPointInView\",({x,y})=>{const rect=this.view.getBoundingClientRect();const pointerInside=x>=rect.left&&x<=rect.right&&y>=rect.top&&y<=rect.bottom;return pointerInside;});_defineProperty(this,\"sendEvent\",nativeEvent=>{const{onGestureHandlerEvent,onGestureHandlerStateChange}=this.propsRef.current;const event=this.transformEventData(nativeEvent);invokeNullableMethod(onGestureHandlerEvent,event);if(this.lastSentState!==event.nativeEvent.state){this.lastSentState=event.nativeEvent.state;invokeNullableMethod(onGestureHandlerStateChange,event);}});_defineProperty(this,\"sync\",()=>{const gesture=this.hammer.get(this.name);if(!gesture)return;const enable=(recognizer,inputData)=>{if(!this.config.enabled){this.isGestureRunning=false;this.hasGestureFailed=false;return false;}if(!inputData||!recognizer.options||typeof inputData.maxPointers==='undefined'){return this.shouldEnableGestureOnSetup;}if(this.hasGestureFailed){return false;}if(!this.isDiscrete){if(this.isGestureRunning){return true;}this._stillWaiting=this._getPendingGestures();if(this._stillWaiting.length){for(const gesture of this._stillWaiting){if(!gesture.isDiscrete&&gesture.isGestureRunning){this.hasGestureFailed=true;this.isGestureRunning=false;return false;}}return false;}}if(!this.hasCustomActivationCriteria){return true;}const deltaRotation=this.initialRotation==null?0:inputData.rotation-this.initialRotation;const{success,failed}=this.isGestureEnabledForEvent(this.getConfig(),recognizer,Object.assign({},inputData,{deltaRotation}));if(failed){this.simulateCancelEvent(inputData);this.hasGestureFailed=true;}return success;};const params=this.getHammerConfig();gesture.set(Object.assign({},params,{enable}));});this.gestureInstance=gestureInstances++;this.hasCustomActivationCriteria=false;}getConfig(){return this.config;}onWaitingEnded(_gesture){}removePendingGesture(id){delete this.pendingGestures[id];}addPendingGesture(gesture){this.pendingGestures[gesture.id]=gesture;}isGestureEnabledForEvent(_config,_recognizer,_event){return{success:true};}get NativeGestureClass(){throw new Error('Must override GestureHandler.NativeGestureClass');}updateHasCustomActivationCriteria(_config){return true;}updateGestureConfig(_ref){let{enabled=true}=_ref,props=_objectWithoutPropertiesLoose(_ref,_excluded);this.clearSelfAsPending();this.config=this.ensureConfig(Object.assign({enabled},props));this.hasCustomActivationCriteria=this.updateHasCustomActivationCriteria(this.config);if(Array.isArray(this.config.waitFor)){for(const gesture of this.config.waitFor){gesture.addPendingGesture(this);}}if(this.hammer){this.sync();}return this.config;}getState(type){if(type==0){return 0;}return EventMap[type];}transformEventData(event){const{eventType,maxPointers:numberOfPointers}=event;const changedTouch=event.changedPointers[0];const pointerInside=this.isPointInView({x:changedTouch.clientX,y:changedTouch.clientY});const state=this.getState(eventType);if(state!==this.previousState){this.oldState=this.previousState;this.previousState=state;}return{nativeEvent:Object.assign({numberOfPointers,state,pointerInside},this.transformNativeEvent(event),{handlerTag:this.handlerTag,target:this.ref,oldState:state!==this.previousState||state!=4?this.oldState:undefined}),timeStamp:Date.now()};}transformNativeEvent(_event){return{};}cancelPendingGestures(event){for(const gesture of Object.values(this.pendingGestures)){if(gesture&&gesture.isGestureRunning){gesture.hasGestureFailed=true;gesture.cancelEvent(event);}}}notifyPendingGestures(){for(const gesture of Object.values(this.pendingGestures)){if(gesture){gesture.onWaitingEnded(this);}}}onGestureEnded(event){this.isGestureRunning=false;this.cancelPendingGestures(event);}forceInvalidate(event){if(this.isGestureRunning){this.hasGestureFailed=true;this.cancelEvent(event);}}cancelEvent(event){this.notifyPendingGestures();this.sendEvent(Object.assign({},event,{eventType:Hammer.INPUT_CANCEL,isFinal:true}));this.onGestureEnded(event);}onRawEvent({isFirst}){if(isFirst){this.hasGestureFailed=false;}}shouldUseTouchEvents(config){var _config$simultaneousH,_config$simultaneousH2;return(_config$simultaneousH=(_config$simultaneousH2=config.simultaneousHandlers)===null||_config$simultaneousH2===void 0?void 0:_config$simultaneousH2.some(handler=>handler.isNative))!==null&&_config$simultaneousH!==void 0?_config$simultaneousH:false;}setView(ref,propsRef){if(ref==null){this.destroy();this.view=null;return;}const SUPPORTS_TOUCH='ontouchstart'in window;this.propsRef=propsRef;this.ref=ref;this.view=findNodeHandle(ref);this.hammer=SUPPORTS_TOUCH&&this.shouldUseTouchEvents(this.config)?new Hammer.Manager(this.view,{inputClass:Hammer.TouchInput}):new Hammer.Manager(this.view);this.oldState=State.UNDETERMINED;this.previousState=State.UNDETERMINED;this.lastSentState=null;const{NativeGestureClass}=this;const gesture=new NativeGestureClass(this.getHammerConfig());this.hammer.add(gesture);this.hammer.on('hammer.input',ev=>{if(!this.config.enabled){this.hasGestureFailed=false;this.isGestureRunning=false;return;}this.onRawEvent(ev);if(this.initialRotation===null&&ev.rotation!==0){this.initialRotation=ev.rotation;}if(ev.isFinal){setTimeout(()=>{this.initialRotation=null;this.hasGestureFailed=false;});}});this.setupEvents();this.sync();}setupEvents(){if(!this.isDiscrete){this.hammer.on(`${this.name}start`,event=>this.onStart(event));this.hammer.on(`${this.name}end ${this.name}cancel`,event=>{this.onGestureEnded(event);});}this.hammer.on(this.name,ev=>this.onGestureActivated(ev));}onStart({deltaX,deltaY,rotation}){this.oldState=State.UNDETERMINED;this.previousState=State.UNDETERMINED;this.lastSentState=null;this.isGestureRunning=true;this.__initialX=deltaX;this.__initialY=deltaY;this.initialRotation=rotation;}onGestureActivated(ev){this.sendEvent(ev);}onSuccess(){}_getPendingGestures(){if(Array.isArray(this.config.waitFor)&&this.config.waitFor.length){const stillWaiting=this.config.waitFor.filter(({hasGestureFailed})=>hasGestureFailed===false);return stillWaiting;}return[];}getHammerConfig(){const pointers=this.config.minPointers===this.config.maxPointers?this.config.minPointers:0;return{pointers};}simulateCancelEvent(_inputData){}ensureConfig(config){const props=Object.assign({},config);if('minDist'in config){props.minDist=config.minDist;props.minDistSq=props.minDist*props.minDist;}if('minVelocity'in config){props.minVelocity=config.minVelocity;props.minVelocitySq=props.minVelocity*props.minVelocity;}if('maxDist'in config){props.maxDist=config.maxDist;props.maxDistSq=config.maxDist*config.maxDist;}if('waitFor'in config){props.waitFor=asArray(config.waitFor).map(({handlerTag})=>NodeManager.getHandler(handlerTag)).filter(v=>v);}else{props.waitFor=null;}if('simultaneousHandlers'in config){const shouldUseTouchEvents=this.shouldUseTouchEvents(this.config);props.simultaneousHandlers=asArray(config.simultaneousHandlers).map(handler=>{if(typeof handler==='number'){return NodeManager.getHandler(handler);}else{return NodeManager.getHandler(handler.handlerTag);}}).filter(v=>v);if(shouldUseTouchEvents!==this.shouldUseTouchEvents(props)){ghQueueMicrotask(()=>{this.destroy();this.setView(this.ref,this.propsRef);});}}else{props.simultaneousHandlers=null;}const configProps=['minPointers','maxPointers','minDist','maxDist','maxDistSq','minVelocitySq','minDistSq','minVelocity','failOffsetXStart','failOffsetYStart','failOffsetXEnd','failOffsetYEnd','activeOffsetXStart','activeOffsetXEnd','activeOffsetYStart','activeOffsetYEnd'];configProps.forEach(prop=>{if(typeof props[prop]==='undefined'){props[prop]=Number.NaN;}});return props;}}function invokeNullableMethod(method,event){if(method){if(typeof method==='function'){method(event);}else{if('__getHandler'in method&&typeof method.__getHandler==='function'){const handler=method.__getHandler();invokeNullableMethod(handler,event);}else{if('__nodeConfig'in method){const{argMapping}=method.__nodeConfig;if(Array.isArray(argMapping)){for(const[index,[key,value]]of argMapping.entries()){if(key in event.nativeEvent){const nativeValue=event.nativeEvent[key];if(value&&value.setValue){value.setValue(nativeValue);}else{method.__nodeConfig.argMapping[index]=[key,nativeValue];}}}}}}}}}function asArray(value){return value==null?[]:Array.isArray(value)?value:[value];}export default GestureHandler;","map":{"version":3,"names":["Hammer","findNodeHandle","State","EventMap","NodeManager","ghQueueMicrotask","gestureInstances","GestureHandler","id","name","gestureInstance","isNative","isDiscrete","shouldEnableGestureOnSetup","Error","constructor","_defineProperty","UNDETERMINED","Array","isArray","config","waitFor","gesture","removePendingGesture","clearSelfAsPending","hammer","stop","destroy","x","y","rect","view","getBoundingClientRect","pointerInside","left","right","top","bottom","nativeEvent","onGestureHandlerEvent","onGestureHandlerStateChange","propsRef","current","event","transformEventData","invokeNullableMethod","lastSentState","state","get","enable","recognizer","inputData","enabled","isGestureRunning","hasGestureFailed","options","maxPointers","_stillWaiting","_getPendingGestures","length","hasCustomActivationCriteria","deltaRotation","initialRotation","rotation","success","failed","isGestureEnabledForEvent","getConfig","Object","assign","simulateCancelEvent","params","getHammerConfig","set","onWaitingEnded","_gesture","pendingGestures","addPendingGesture","_config","_recognizer","_event","NativeGestureClass","updateHasCustomActivationCriteria","updateGestureConfig","_ref","props","_objectWithoutPropertiesLoose","_excluded","ensureConfig","sync","getState","type","eventType","numberOfPointers","changedTouch","changedPointers","isPointInView","clientX","clientY","previousState","oldState","transformNativeEvent","handlerTag","target","ref","undefined","timeStamp","Date","now","cancelPendingGestures","values","cancelEvent","notifyPendingGestures","onGestureEnded","forceInvalidate","sendEvent","INPUT_CANCEL","isFinal","onRawEvent","isFirst","shouldUseTouchEvents","_config$simultaneousH","_config$simultaneousH2","simultaneousHandlers","some","handler","setView","SUPPORTS_TOUCH","window","Manager","inputClass","TouchInput","add","on","ev","setTimeout","setupEvents","onStart","onGestureActivated","deltaX","deltaY","__initialX","__initialY","onSuccess","stillWaiting","filter","pointers","minPointers","_inputData","minDist","minDistSq","minVelocity","minVelocitySq","maxDist","maxDistSq","asArray","map","getHandler","v","configProps","forEach","prop","Number","NaN","method","__getHandler","argMapping","__nodeConfig","index","key","value","entries","nativeValue","setValue"],"sources":["/home/user/rork-vibesync-458/node_modules/react-native-gesture-handler/lib/module/web_hammer/GestureHandler.ts"],"sourcesContent":["/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport Hammer from '@egjs/hammerjs';\nimport { findNodeHandle } from 'react-native';\n\nimport { State } from '../State';\nimport { EventMap } from './constants';\nimport * as NodeManager from './NodeManager';\nimport { ghQueueMicrotask } from '../ghQueueMicrotask';\n\n// TODO(TS) Replace with HammerInput if https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438/files is merged\nexport type HammerInputExt = Omit<HammerInput, 'destroy' | 'handler' | 'init'>;\n\nexport type Config = Partial<{\n  enabled: boolean;\n  minPointers: number;\n  maxPointers: number;\n  minDist: number;\n  minDistSq: number;\n  minVelocity: number;\n  minVelocitySq: number;\n  maxDist: number;\n  maxDistSq: number;\n  failOffsetXStart: number;\n  failOffsetYStart: number;\n  failOffsetXEnd: number;\n  failOffsetYEnd: number;\n  activeOffsetXStart: number;\n  activeOffsetXEnd: number;\n  activeOffsetYStart: number;\n  activeOffsetYEnd: number;\n  waitFor: any[] | null;\n  simultaneousHandlers: any[] | null;\n}>;\n\ntype NativeEvent = ReturnType<GestureHandler['transformEventData']>;\n\nlet gestureInstances = 0;\n\nabstract class GestureHandler {\n  public handlerTag: any;\n  public isGestureRunning = false;\n  public view: number | null = null;\n  protected hasCustomActivationCriteria: boolean;\n  protected hasGestureFailed = false;\n  protected hammer: HammerManager | null = null;\n  protected initialRotation: number | null = null;\n  protected __initialX: any;\n  protected __initialY: any;\n  protected config: Config = {};\n  protected previousState: State = State.UNDETERMINED;\n  private pendingGestures: Record<string, this> = {};\n  private oldState: State = State.UNDETERMINED;\n  private lastSentState: State | null = null;\n  private gestureInstance: number;\n  private _stillWaiting: any;\n  private propsRef: any;\n  private ref: any;\n\n  abstract get name(): string;\n\n  get id() {\n    return `${this.name}${this.gestureInstance}`;\n  }\n\n  // a simple way to check if GestureHandler is NativeViewGestureHandler, since importing it\n  // here to use instanceof would cause import cycle\n  get isNative() {\n    return false;\n  }\n\n  get isDiscrete() {\n    return false;\n  }\n\n  get shouldEnableGestureOnSetup(): boolean {\n    throw new Error('Must override GestureHandler.shouldEnableGestureOnSetup');\n  }\n\n  constructor() {\n    this.gestureInstance = gestureInstances++;\n    this.hasCustomActivationCriteria = false;\n  }\n\n  getConfig() {\n    return this.config;\n  }\n\n  onWaitingEnded(_gesture: this) {}\n\n  removePendingGesture(id: string) {\n    delete this.pendingGestures[id];\n  }\n\n  addPendingGesture(gesture: this) {\n    this.pendingGestures[gesture.id] = gesture;\n  }\n\n  isGestureEnabledForEvent(\n    _config: any,\n    _recognizer: any,\n    _event: any\n  ): { failed?: boolean; success?: boolean } {\n    return { success: true };\n  }\n\n  get NativeGestureClass(): RecognizerStatic {\n    throw new Error('Must override GestureHandler.NativeGestureClass');\n  }\n\n  updateHasCustomActivationCriteria(_config: Config) {\n    return true;\n  }\n\n  clearSelfAsPending = () => {\n    if (Array.isArray(this.config.waitFor)) {\n      for (const gesture of this.config.waitFor) {\n        gesture.removePendingGesture(this.id);\n      }\n    }\n  };\n\n  updateGestureConfig({ enabled = true, ...props }) {\n    this.clearSelfAsPending();\n\n    this.config = this.ensureConfig({ enabled, ...props });\n    this.hasCustomActivationCriteria = this.updateHasCustomActivationCriteria(\n      this.config\n    );\n    if (Array.isArray(this.config.waitFor)) {\n      for (const gesture of this.config.waitFor) {\n        gesture.addPendingGesture(this);\n      }\n    }\n\n    if (this.hammer) {\n      this.sync();\n    }\n    return this.config;\n  }\n\n  destroy = () => {\n    this.clearSelfAsPending();\n\n    if (this.hammer) {\n      this.hammer.stop(false);\n      this.hammer.destroy();\n    }\n    this.hammer = null;\n  };\n\n  isPointInView = ({ x, y }: { x: number; y: number }) => {\n    // @ts-ignore FIXME(TS)\n    const rect = this.view!.getBoundingClientRect();\n    const pointerInside =\n      x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;\n    return pointerInside;\n  };\n\n  getState(type: keyof typeof EventMap): State {\n    // @ts-ignore TODO(TS) check if this is needed\n    if (type == 0) {\n      return 0;\n    }\n    return EventMap[type];\n  }\n\n  transformEventData(event: HammerInputExt) {\n    const { eventType, maxPointers: numberOfPointers } = event;\n    // const direction = DirectionMap[ev.direction];\n    const changedTouch = event.changedPointers[0];\n    const pointerInside = this.isPointInView({\n      x: changedTouch.clientX,\n      y: changedTouch.clientY,\n    });\n\n    // TODO(TS) Remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50966 is merged.\n    const state = this.getState(eventType as 1 | 2 | 4 | 8);\n    if (state !== this.previousState) {\n      this.oldState = this.previousState;\n      this.previousState = state;\n    }\n\n    return {\n      nativeEvent: {\n        numberOfPointers,\n        state,\n        pointerInside,\n        ...this.transformNativeEvent(event),\n        // onHandlerStateChange only\n        handlerTag: this.handlerTag,\n        target: this.ref,\n        // send oldState only when the state was changed, or is different than ACTIVE\n        // GestureDetector relies on the presence of `oldState` to differentiate between\n        // update events and state change events\n        oldState:\n          state !== this.previousState || state != 4\n            ? this.oldState\n            : undefined,\n      },\n      timeStamp: Date.now(),\n    };\n  }\n\n  transformNativeEvent(_event: HammerInputExt) {\n    return {};\n  }\n\n  sendEvent = (nativeEvent: HammerInputExt) => {\n    const { onGestureHandlerEvent, onGestureHandlerStateChange } =\n      this.propsRef.current;\n\n    const event = this.transformEventData(nativeEvent);\n\n    invokeNullableMethod(onGestureHandlerEvent, event);\n    if (this.lastSentState !== event.nativeEvent.state) {\n      this.lastSentState = event.nativeEvent.state as State;\n      invokeNullableMethod(onGestureHandlerStateChange, event);\n    }\n  };\n\n  cancelPendingGestures(event: HammerInputExt) {\n    for (const gesture of Object.values(this.pendingGestures)) {\n      if (gesture && gesture.isGestureRunning) {\n        gesture.hasGestureFailed = true;\n        gesture.cancelEvent(event);\n      }\n    }\n  }\n\n  notifyPendingGestures() {\n    for (const gesture of Object.values(this.pendingGestures)) {\n      if (gesture) {\n        gesture.onWaitingEnded(this);\n      }\n    }\n  }\n\n  // FIXME event is undefined in runtime when firstly invoked (see Draggable example), check other functions taking event as input\n  onGestureEnded(event: HammerInputExt) {\n    this.isGestureRunning = false;\n    this.cancelPendingGestures(event);\n  }\n\n  forceInvalidate(event: HammerInputExt) {\n    if (this.isGestureRunning) {\n      this.hasGestureFailed = true;\n      this.cancelEvent(event);\n    }\n  }\n\n  cancelEvent(event: HammerInputExt) {\n    this.notifyPendingGestures();\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_CANCEL,\n      isFinal: true,\n    });\n    this.onGestureEnded(event);\n  }\n\n  onRawEvent({ isFirst }: HammerInputExt) {\n    if (isFirst) {\n      this.hasGestureFailed = false;\n    }\n  }\n\n  shouldUseTouchEvents(config: Config) {\n    return (\n      config.simultaneousHandlers?.some((handler) => handler.isNative) ?? false\n    );\n  }\n\n  setView(ref: Parameters<typeof findNodeHandle>['0'], propsRef: any) {\n    if (ref == null) {\n      this.destroy();\n      this.view = null;\n      return;\n    }\n\n    // @ts-ignore window doesn't exist on global type as we don't want to use Node types\n    const SUPPORTS_TOUCH = 'ontouchstart' in window;\n    this.propsRef = propsRef;\n    this.ref = ref;\n\n    this.view = findNodeHandle(ref);\n\n    // When the browser starts handling the gesture (e.g. scrolling), it sends a pointercancel event and stops\n    // sending additional pointer events. This is not the case with touch events, so if the gesture is simultaneous\n    // with a NativeGestureHandler, we need to check if touch events are supported and use them if possible.\n    this.hammer =\n      SUPPORTS_TOUCH && this.shouldUseTouchEvents(this.config)\n        ? new Hammer.Manager(this.view as any, {\n            inputClass: Hammer.TouchInput,\n          })\n        : new Hammer.Manager(this.view as any);\n\n    this.oldState = State.UNDETERMINED;\n    this.previousState = State.UNDETERMINED;\n    this.lastSentState = null;\n\n    const { NativeGestureClass } = this;\n    // @ts-ignore TODO(TS)\n    const gesture = new NativeGestureClass(this.getHammerConfig());\n    this.hammer.add(gesture);\n\n    this.hammer.on('hammer.input', (ev: HammerInput) => {\n      if (!this.config.enabled) {\n        this.hasGestureFailed = false;\n        this.isGestureRunning = false;\n        return;\n      }\n\n      this.onRawEvent(ev as unknown as HammerInputExt);\n\n      // TODO: Bacon: Check against something other than null\n      // The isFirst value is not called when the first rotation is calculated.\n      if (this.initialRotation === null && ev.rotation !== 0) {\n        this.initialRotation = ev.rotation;\n      }\n      if (ev.isFinal) {\n        // in favor of a willFail otherwise the last frame of the gesture will be captured.\n        setTimeout(() => {\n          this.initialRotation = null;\n          this.hasGestureFailed = false;\n        });\n      }\n    });\n\n    this.setupEvents();\n    this.sync();\n  }\n\n  setupEvents() {\n    // TODO(TS) Hammer types aren't exactly that what we get in runtime\n    if (!this.isDiscrete) {\n      this.hammer!.on(`${this.name}start`, (event: HammerInput) =>\n        this.onStart(event as unknown as HammerInputExt)\n      );\n      this.hammer!.on(\n        `${this.name}end ${this.name}cancel`,\n        (event: HammerInput) => {\n          this.onGestureEnded(event as unknown as HammerInputExt);\n        }\n      );\n    }\n    this.hammer!.on(this.name, (ev: HammerInput) =>\n      this.onGestureActivated(ev as unknown as HammerInputExt)\n    ); // TODO(TS) remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438 is merged\n  }\n\n  onStart({ deltaX, deltaY, rotation }: HammerInputExt) {\n    // Reset the state for the next gesture\n    this.oldState = State.UNDETERMINED;\n    this.previousState = State.UNDETERMINED;\n    this.lastSentState = null;\n\n    this.isGestureRunning = true;\n    this.__initialX = deltaX;\n    this.__initialY = deltaY;\n    this.initialRotation = rotation;\n  }\n\n  onGestureActivated(ev: HammerInputExt) {\n    this.sendEvent(ev);\n  }\n\n  onSuccess() {}\n\n  _getPendingGestures() {\n    if (Array.isArray(this.config.waitFor) && this.config.waitFor.length) {\n      // Get the list of gestures that this gesture is still waiting for.\n      // Use `=== false` in case a ref that isn't a gesture handler is used.\n      const stillWaiting = this.config.waitFor.filter(\n        ({ hasGestureFailed }) => hasGestureFailed === false\n      );\n      return stillWaiting;\n    }\n    return [];\n  }\n\n  getHammerConfig() {\n    const pointers =\n      this.config.minPointers === this.config.maxPointers\n        ? this.config.minPointers\n        : 0;\n    return {\n      pointers,\n    };\n  }\n\n  sync = () => {\n    const gesture = this.hammer!.get(this.name);\n    if (!gesture) return;\n\n    const enable = (recognizer: any, inputData: any) => {\n      if (!this.config.enabled) {\n        this.isGestureRunning = false;\n        this.hasGestureFailed = false;\n        return false;\n      }\n\n      // Prevent events before the system is ready.\n      if (\n        !inputData ||\n        !recognizer.options ||\n        typeof inputData.maxPointers === 'undefined'\n      ) {\n        return this.shouldEnableGestureOnSetup;\n      }\n\n      if (this.hasGestureFailed) {\n        return false;\n      }\n\n      if (!this.isDiscrete) {\n        if (this.isGestureRunning) {\n          return true;\n        }\n        // The built-in hammer.js \"waitFor\" doesn't work across multiple views.\n        // Only process if there are views to wait for.\n        this._stillWaiting = this._getPendingGestures();\n        // This gesture should continue waiting.\n        if (this._stillWaiting.length) {\n          // Check to see if one of the gestures you're waiting for has started.\n          // If it has then the gesture should fail.\n          for (const gesture of this._stillWaiting) {\n            // When the target gesture has started, this gesture must force fail.\n            if (!gesture.isDiscrete && gesture.isGestureRunning) {\n              this.hasGestureFailed = true;\n              this.isGestureRunning = false;\n              return false;\n            }\n          }\n          // This gesture shouldn't start until the others have finished.\n          return false;\n        }\n      }\n\n      // Use default behaviour\n      if (!this.hasCustomActivationCriteria) {\n        return true;\n      }\n\n      const deltaRotation =\n        this.initialRotation == null\n          ? 0\n          : inputData.rotation - this.initialRotation;\n      // @ts-ignore FIXME(TS)\n      const { success, failed } = this.isGestureEnabledForEvent(\n        this.getConfig(),\n        recognizer,\n        {\n          ...inputData,\n          deltaRotation,\n        }\n      );\n\n      if (failed) {\n        this.simulateCancelEvent(inputData);\n        this.hasGestureFailed = true;\n      }\n      return success;\n    };\n\n    const params = this.getHammerConfig();\n    // @ts-ignore FIXME(TS)\n    gesture.set({ ...params, enable });\n  };\n\n  simulateCancelEvent(_inputData: any) {}\n\n  // Validate the props\n  ensureConfig(config: Config): Required<Config> {\n    const props = { ...config };\n\n    // TODO(TS) We use ! to assert that if property is present then value is not empty (null, undefined)\n    if ('minDist' in config) {\n      props.minDist = config.minDist;\n      props.minDistSq = props.minDist! * props.minDist!;\n    }\n    if ('minVelocity' in config) {\n      props.minVelocity = config.minVelocity;\n      props.minVelocitySq = props.minVelocity! * props.minVelocity!;\n    }\n    if ('maxDist' in config) {\n      props.maxDist = config.maxDist;\n      props.maxDistSq = config.maxDist! * config.maxDist!;\n    }\n    if ('waitFor' in config) {\n      props.waitFor = asArray(config.waitFor)\n        .map(({ handlerTag }: { handlerTag: number }) =>\n          NodeManager.getHandler(handlerTag)\n        )\n        .filter((v) => v);\n    } else {\n      props.waitFor = null;\n    }\n    if ('simultaneousHandlers' in config) {\n      const shouldUseTouchEvents = this.shouldUseTouchEvents(this.config);\n      props.simultaneousHandlers = asArray(config.simultaneousHandlers)\n        .map((handler: number | GestureHandler) => {\n          if (typeof handler === 'number') {\n            return NodeManager.getHandler(handler);\n          } else {\n            return NodeManager.getHandler(handler.handlerTag);\n          }\n        })\n        .filter((v) => v);\n\n      if (shouldUseTouchEvents !== this.shouldUseTouchEvents(props)) {\n        ghQueueMicrotask(() => {\n          // if the undelying event API needs to be changed, we need to unmount and mount\n          // the hammer instance again.\n          this.destroy();\n          this.setView(this.ref, this.propsRef);\n        });\n      }\n    } else {\n      props.simultaneousHandlers = null;\n    }\n\n    const configProps = [\n      'minPointers',\n      'maxPointers',\n      'minDist',\n      'maxDist',\n      'maxDistSq',\n      'minVelocitySq',\n      'minDistSq',\n      'minVelocity',\n      'failOffsetXStart',\n      'failOffsetYStart',\n      'failOffsetXEnd',\n      'failOffsetYEnd',\n      'activeOffsetXStart',\n      'activeOffsetXEnd',\n      'activeOffsetYStart',\n      'activeOffsetYEnd',\n    ] as const;\n    configProps.forEach((prop: (typeof configProps)[number]) => {\n      if (typeof props[prop] === 'undefined') {\n        props[prop] = Number.NaN;\n      }\n    });\n    return props as Required<Config>; // TODO(TS) how to convince TS that props are filled?\n  }\n}\n\n// TODO(TS) investigate this method\n// Used for sending data to a callback or AnimatedEvent\nfunction invokeNullableMethod(\n  method:\n    | ((event: NativeEvent) => void)\n    | { __getHandler: () => (event: NativeEvent) => void }\n    | { __nodeConfig: { argMapping: any } },\n  event: NativeEvent\n) {\n  if (method) {\n    if (typeof method === 'function') {\n      method(event);\n    } else {\n      // For use with reanimated's AnimatedEvent\n      if (\n        '__getHandler' in method &&\n        typeof method.__getHandler === 'function'\n      ) {\n        const handler = method.__getHandler();\n        invokeNullableMethod(handler, event);\n      } else {\n        if ('__nodeConfig' in method) {\n          const { argMapping } = method.__nodeConfig;\n          if (Array.isArray(argMapping)) {\n            for (const [index, [key, value]] of argMapping.entries()) {\n              if (key in event.nativeEvent) {\n                // @ts-ignore fix method type\n                const nativeValue = event.nativeEvent[key];\n                if (value && value.setValue) {\n                  // Reanimated API\n                  value.setValue(nativeValue);\n                } else {\n                  // RN Animated API\n                  method.__nodeConfig.argMapping[index] = [key, nativeValue];\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction asArray<T>(value: T | T[]) {\n  // TODO(TS) use config.waitFor type\n  return value == null ? [] : Array.isArray(value) ? value : [value];\n}\n\nexport default GestureHandler;\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}