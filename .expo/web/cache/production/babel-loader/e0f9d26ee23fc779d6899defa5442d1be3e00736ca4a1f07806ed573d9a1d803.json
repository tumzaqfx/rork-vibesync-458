{"ast":null,"code":"import{ConnectionMonitor}from'./network';import{AppHealthMonitor,PerformanceMonitor}from'./performance';import{OfflineCache,OfflineQueue}from'./offline-cache';import{Analytics}from'./analytics';import{CrashReporter}from'./crash-reporter';import{AdvancedCache}from'./advanced-cache';import{PushNotificationManager}from'./push-notifications';import{BackendHealthCheck}from'./backend-health';export class AppInitializer{static isInitialized=false;static async initialize(){if(this.isInitialized){console.log('[App] Already initialized');return;}console.log('[App] Initializing VibeSync...');try{PerformanceMonitor.startMeasure('app_initialization');ConnectionMonitor.initialize();console.log('[App] Network monitoring initialized');await AdvancedCache.initialize();console.log('[App] Advanced cache initialized');await Analytics.initialize();console.log('[App] Analytics initialized');await CrashReporter.initialize();console.log('[App] Crash reporter initialized');try{const pushToken=await PushNotificationManager.initialize();if(pushToken){console.log('[App] Push notifications initialized with token');}else{console.log('[App] Push notifications skipped (Expo Go or not available)');}}catch(pushError){console.warn('[App] Push notification initialization failed:',pushError);}await this.cleanupExpiredData();try{await Promise.race([AppHealthMonitor.runHealthChecks(),new Promise((_,reject)=>setTimeout(()=>reject(new Error('Health check timeout')),5000))]);}catch(healthError){console.warn('[App] Health check failed or timed out (backend may be offline):',healthError);}try{BackendHealthCheck.startMonitoring(30000);console.log('[App] Backend health monitoring started');BackendHealthCheck.onHealthChange(isHealthy=>{if(isHealthy){console.log('[App] ✅ Backend connection restored');}else{console.warn('[App] ⚠️  Backend connection lost');}});}catch(monitorError){console.warn('[App] Backend monitoring setup failed:',monitorError);}this.setupPeriodicHealthChecks();this.setupOfflineQueueProcessor();PerformanceMonitor.endMeasure('app_initialization');this.isInitialized=true;console.log('[App] VibeSync initialized successfully');}catch(error){console.error('[App] Initialization error:',error);this.isInitialized=true;console.log('[App] Continuing despite initialization errors...');}}static async cleanupExpiredData(){try{const cleanedCount=await OfflineCache.cleanExpired();const advancedCleanedCount=await AdvancedCache.cleanExpired();console.log(`[App] Cleaned ${cleanedCount+advancedCleanedCount} expired cache entries`);}catch(error){console.error('[App] Error cleaning expired data:',error);}}static setupPeriodicHealthChecks(){setInterval(async()=>{await AppHealthMonitor.runHealthChecks();PerformanceMonitor.logMemoryUsage();},5*60*1000);console.log('[App] Periodic health checks scheduled');}static setupOfflineQueueProcessor(){ConnectionMonitor.subscribe(async isOnline=>{if(isOnline){console.log('[App] Connection restored, processing offline queue');const queueSize=await OfflineQueue.size();if(queueSize>0){await OfflineQueue.processQueue(async action=>{console.log('[App] Processing queued action:',action.type);return true;});}}});}static getInitializationStatus(){return this.isInitialized;}}export async function initializeApp(){await AppInitializer.initialize();}","map":{"version":3,"names":["ConnectionMonitor","AppHealthMonitor","PerformanceMonitor","OfflineCache","OfflineQueue","Analytics","CrashReporter","AdvancedCache","PushNotificationManager","BackendHealthCheck","AppInitializer","isInitialized","initialize","console","log","startMeasure","pushToken","pushError","warn","cleanupExpiredData","Promise","race","runHealthChecks","_","reject","setTimeout","Error","healthError","startMonitoring","onHealthChange","isHealthy","monitorError","setupPeriodicHealthChecks","setupOfflineQueueProcessor","endMeasure","error","cleanedCount","cleanExpired","advancedCleanedCount","setInterval","logMemoryUsage","subscribe","isOnline","queueSize","size","processQueue","action","type","getInitializationStatus","initializeApp"],"sources":["/home/user/rork-vibesync-458/utils/app-initializer.ts"],"sourcesContent":["import { ConnectionMonitor } from './network';\nimport { AppHealthMonitor, PerformanceMonitor } from './performance';\nimport { OfflineCache, OfflineQueue } from './offline-cache';\nimport { Analytics } from './analytics';\nimport { CrashReporter } from './crash-reporter';\nimport { AdvancedCache } from './advanced-cache';\nimport { PushNotificationManager } from './push-notifications';\nimport { BackendHealthCheck } from './backend-health';\n\nexport class AppInitializer {\n  private static isInitialized = false;\n\n  static async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      console.log('[App] Already initialized');\n      return;\n    }\n\n    console.log('[App] Initializing VibeSync...');\n    \n    try {\n      PerformanceMonitor.startMeasure('app_initialization');\n\n      ConnectionMonitor.initialize();\n      console.log('[App] Network monitoring initialized');\n\n      await AdvancedCache.initialize();\n      console.log('[App] Advanced cache initialized');\n\n      await Analytics.initialize();\n      console.log('[App] Analytics initialized');\n\n      await CrashReporter.initialize();\n      console.log('[App] Crash reporter initialized');\n\n      try {\n        const pushToken = await PushNotificationManager.initialize();\n        if (pushToken) {\n          console.log('[App] Push notifications initialized with token');\n        } else {\n          console.log('[App] Push notifications skipped (Expo Go or not available)');\n        }\n      } catch (pushError) {\n        console.warn('[App] Push notification initialization failed:', pushError);\n      }\n\n      await this.cleanupExpiredData();\n\n      try {\n        await Promise.race([\n          AppHealthMonitor.runHealthChecks(),\n          new Promise((_, reject) => setTimeout(() => reject(new Error('Health check timeout')), 5000))\n        ]);\n      } catch (healthError) {\n        console.warn('[App] Health check failed or timed out (backend may be offline):', healthError);\n      }\n\n      try {\n        BackendHealthCheck.startMonitoring(30000);\n        console.log('[App] Backend health monitoring started');\n\n        BackendHealthCheck.onHealthChange((isHealthy) => {\n          if (isHealthy) {\n            console.log('[App] ✅ Backend connection restored');\n          } else {\n            console.warn('[App] ⚠️  Backend connection lost');\n          }\n        });\n      } catch (monitorError) {\n        console.warn('[App] Backend monitoring setup failed:', monitorError);\n      }\n\n      this.setupPeriodicHealthChecks();\n\n      this.setupOfflineQueueProcessor();\n\n      PerformanceMonitor.endMeasure('app_initialization');\n      \n      this.isInitialized = true;\n      console.log('[App] VibeSync initialized successfully');\n    } catch (error) {\n      console.error('[App] Initialization error:', error);\n      this.isInitialized = true;\n      console.log('[App] Continuing despite initialization errors...');\n    }\n  }\n\n  private static async cleanupExpiredData(): Promise<void> {\n    try {\n      const cleanedCount = await OfflineCache.cleanExpired();\n      const advancedCleanedCount = await AdvancedCache.cleanExpired();\n      console.log(`[App] Cleaned ${cleanedCount + advancedCleanedCount} expired cache entries`);\n    } catch (error) {\n      console.error('[App] Error cleaning expired data:', error);\n    }\n  }\n\n  private static setupPeriodicHealthChecks(): void {\n    setInterval(async () => {\n      await AppHealthMonitor.runHealthChecks();\n      PerformanceMonitor.logMemoryUsage();\n    }, 5 * 60 * 1000);\n    \n    console.log('[App] Periodic health checks scheduled');\n  }\n\n  private static setupOfflineQueueProcessor(): void {\n    ConnectionMonitor.subscribe(async (isOnline) => {\n      if (isOnline) {\n        console.log('[App] Connection restored, processing offline queue');\n        \n        const queueSize = await OfflineQueue.size();\n        if (queueSize > 0) {\n          await OfflineQueue.processQueue(async (action) => {\n            console.log('[App] Processing queued action:', action.type);\n            return true;\n          });\n        }\n      }\n    });\n  }\n\n  static getInitializationStatus(): boolean {\n    return this.isInitialized;\n  }\n}\n\nexport async function initializeApp(): Promise<void> {\n  await AppInitializer.initialize();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}