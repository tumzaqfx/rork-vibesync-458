{"ast":null,"code":"import _objectWithoutPropertiesLoose from\"@babel/runtime/helpers/objectWithoutPropertiesLoose\";const _excluded=[\"format\"];import{useReleasingSharedObject}from'expo-modules-core';import{SaveFormat}from'./ImageManipulator.types';import ExpoImageManipulator from'./NativeImageManipulatorModule';import{validateArguments}from'./validators';export async function manipulateAsync(uri,actions=[],saveOptions={}){validateArguments(uri,actions,saveOptions);const{format=SaveFormat.JPEG}=saveOptions,rest=_objectWithoutPropertiesLoose(saveOptions,_excluded);const context=ExpoImageManipulator.manipulate(uri);for(const action of actions){if('resize'in action){context.resize(action.resize);}else if('rotate'in action){context.rotate(action.rotate);}else if('flip'in action){context.flip(action.flip);}else if('crop'in action){context.crop(action.crop);}else if('extent'in action&&context.extent){context.extent(action.extent);}}const image=await context.renderAsync();const result=await image.saveAsync(Object.assign({format},rest));context.release();image.release();return result;}export function useImageManipulator(source){return useReleasingSharedObject(()=>ExpoImageManipulator.manipulate(source),[source]);}export{ExpoImageManipulator as ImageManipulator};","map":{"version":3,"names":["useReleasingSharedObject","SaveFormat","ExpoImageManipulator","validateArguments","manipulateAsync","uri","actions","saveOptions","format","JPEG","rest","_objectWithoutPropertiesLoose","_excluded","context","manipulate","action","resize","rotate","flip","crop","extent","image","renderAsync","result","saveAsync","Object","assign","release","useImageManipulator","source","ImageManipulator"],"sources":["/home/user/rork-vibesync-458/node_modules/expo-image-manipulator/src/ImageManipulator.ts"],"sourcesContent":["import { useReleasingSharedObject } from 'expo-modules-core';\nimport { SharedRef } from 'expo-modules-core/types';\n\nimport { Action, ImageResult, SaveFormat, SaveOptions } from './ImageManipulator.types';\nimport { ImageManipulatorContext } from './ImageManipulatorContext';\nimport ExpoImageManipulator from './NativeImageManipulatorModule';\nimport { validateArguments } from './validators';\n\n// @needsAudit\n/**\n * Manipulate the image provided via `uri`. Available modifications are rotating, flipping (mirroring),\n * resizing and cropping. Each invocation results in a new file. With one invocation you can provide\n * a set of actions to perform over the image. Overwriting the source file would not have an effect\n * in displaying the result as images are cached.\n * @param uri URI of the file to manipulate. Should be on the local file system or a base64 data URI.\n * @param actions An array of objects representing manipulation options. Each object should have\n * __only one__ of the keys that corresponds to specific transformation.\n * @param saveOptions A map defining how modified image should be saved.\n * @return Promise which fulfils with [`ImageResult`](#imageresult) object.\n * @deprecated It has been replaced by the new, contextual and object-oriented API.\n * Use [`ImageManipulator.manipulate`](#manipulateuri) or [`useImageManipulator`](#useimagemanipulatoruri) instead.\n */\nexport async function manipulateAsync(\n  uri: string,\n  actions: Action[] = [],\n  saveOptions: SaveOptions = {}\n): Promise<ImageResult> {\n  validateArguments(uri, actions, saveOptions);\n\n  const { format = SaveFormat.JPEG, ...rest } = saveOptions;\n  const context = ExpoImageManipulator.manipulate(uri);\n\n  for (const action of actions) {\n    if ('resize' in action) {\n      context.resize(action.resize);\n    } else if ('rotate' in action) {\n      context.rotate(action.rotate);\n    } else if ('flip' in action) {\n      context.flip(action.flip);\n    } else if ('crop' in action) {\n      context.crop(action.crop);\n    } else if ('extent' in action && context.extent) {\n      context.extent(action.extent);\n    }\n  }\n  const image = await context.renderAsync();\n  const result = await image.saveAsync({ format, ...rest });\n\n  // These shared objects will not be used anymore, so free up some memory.\n  context.release();\n  image.release();\n\n  return result;\n}\n\nexport function useImageManipulator(source: string | SharedRef<'image'>): ImageManipulatorContext {\n  return useReleasingSharedObject(() => ExpoImageManipulator.manipulate(source), [source]);\n}\n\nexport { ExpoImageManipulator as ImageManipulator };\n"],"mappings":"0HAAA,OAASA,wBAAwB,KAAQ,mBAAmB,CAG5D,OAA8BC,UAAU,KAAqB,0BAA0B,CAEvF,MAAO,CAAAC,oBAAoB,KAAM,gCAAgC,CACjE,OAASC,iBAAiB,KAAQ,cAAc,CAgBhD,MAAO,eAAe,CAAAC,eAAeA,CACnCC,GAAW,CACXC,OAAiB,CAAG,EAAE,CACtBC,WAAwB,CAAG,CAAC,CAAC,CACP,CACtBJ,iBAAiB,CAACE,GAAG,CAAEC,OAAO,CAAEC,WAAW,CAAC,CAE5C,KAAM,CAAEC,MAAM,CAAGP,UAAU,CAACQ,IAAc,CAAC,CAAGF,WAAW,CAApBG,IAAI,CAAAC,6BAAA,CAAKJ,WAAW,CAAAK,SAAA,EACzD,KAAM,CAAAC,OAAO,CAAGX,oBAAoB,CAACY,UAAU,CAACT,GAAG,CAAC,CAEpD,IAAK,KAAM,CAAAU,MAAM,GAAI,CAAAT,OAAO,CAAE,CAC5B,GAAI,QAAQ,EAAI,CAAAS,MAAM,CAAE,CACtBF,OAAO,CAACG,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAC/B,CAAC,IAAM,IAAI,QAAQ,EAAI,CAAAD,MAAM,CAAE,CAC7BF,OAAO,CAACI,MAAM,CAACF,MAAM,CAACE,MAAM,CAAC,CAC/B,CAAC,IAAM,IAAI,MAAM,EAAI,CAAAF,MAAM,CAAE,CAC3BF,OAAO,CAACK,IAAI,CAACH,MAAM,CAACG,IAAI,CAAC,CAC3B,CAAC,IAAM,IAAI,MAAM,EAAI,CAAAH,MAAM,CAAE,CAC3BF,OAAO,CAACM,IAAI,CAACJ,MAAM,CAACI,IAAI,CAAC,CAC3B,CAAC,IAAM,IAAI,QAAQ,EAAI,CAAAJ,MAAM,EAAIF,OAAO,CAACO,MAAM,CAAE,CAC/CP,OAAO,CAACO,MAAM,CAACL,MAAM,CAACK,MAAM,CAAC,CAC/B,CACF,CACA,KAAM,CAAAC,KAAK,CAAG,KAAM,CAAAR,OAAO,CAACS,WAAW,CAAC,CAAC,CACzC,KAAM,CAAAC,MAAM,CAAG,KAAM,CAAAF,KAAK,CAACG,SAAS,CAAAC,MAAA,CAAAC,MAAA,EAAGlB,MAAM,EAAKE,IAAI,CAAE,CAAC,CAGzDG,OAAO,CAACc,OAAO,CAAC,CAAC,CACjBN,KAAK,CAACM,OAAO,CAAC,CAAC,CAEf,MAAO,CAAAJ,MAAM,CACf,CAEA,MAAO,SAAS,CAAAK,mBAAmBA,CAACC,MAAmC,CAA2B,CAChG,MAAO,CAAA7B,wBAAwB,CAAC,IAAME,oBAAoB,CAACY,UAAU,CAACe,MAAM,CAAC,CAAE,CAACA,MAAM,CAAC,CAAC,CAC1F,CAEA,OAAS3B,oBAAoB,GAAI,CAAA4B,gBAAgB","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}