{"ast":null,"code":"function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}export default class EventManager{constructor(view){_defineProperty(this,\"view\",void 0);_defineProperty(this,\"pointersInBounds\",[]);_defineProperty(this,\"activePointersCounter\",void 0);this.view=view;this.activePointersCounter=0;}onPointerDown(_event){}onPointerAdd(_event){}onPointerUp(_event){}onPointerRemove(_event){}onPointerMove(_event){}onPointerLeave(_event){}onPointerEnter(_event){}onPointerCancel(_event){}onPointerOutOfBounds(_event){}onPointerMoveOver(_event){}onPointerMoveOut(_event){}onWheel(_event){}setOnPointerDown(callback){this.onPointerDown=callback;}setOnPointerAdd(callback){this.onPointerAdd=callback;}setOnPointerUp(callback){this.onPointerUp=callback;}setOnPointerRemove(callback){this.onPointerRemove=callback;}setOnPointerMove(callback){this.onPointerMove=callback;}setOnPointerLeave(callback){this.onPointerLeave=callback;}setOnPointerEnter(callback){this.onPointerEnter=callback;}setOnPointerCancel(callback){this.onPointerCancel=callback;}setOnPointerOutOfBounds(callback){this.onPointerOutOfBounds=callback;}setOnPointerMoveOver(callback){this.onPointerMoveOver=callback;}setOnPointerMoveOut(callback){this.onPointerMoveOut=callback;}setOnWheel(callback){this.onWheel=callback;}markAsInBounds(pointerId){if(this.pointersInBounds.indexOf(pointerId)>=0){return;}this.pointersInBounds.push(pointerId);}markAsOutOfBounds(pointerId){const index=this.pointersInBounds.indexOf(pointerId);if(index<0){return;}this.pointersInBounds.splice(index,1);}resetManager(){this.activePointersCounter=0;this.pointersInBounds=[];}}","map":{"version":3,"names":["EventManager","constructor","view","_defineProperty","activePointersCounter","onPointerDown","_event","onPointerAdd","onPointerUp","onPointerRemove","onPointerMove","onPointerLeave","onPointerEnter","onPointerCancel","onPointerOutOfBounds","onPointerMoveOver","onPointerMoveOut","onWheel","setOnPointerDown","callback","setOnPointerAdd","setOnPointerUp","setOnPointerRemove","setOnPointerMove","setOnPointerLeave","setOnPointerEnter","setOnPointerCancel","setOnPointerOutOfBounds","setOnPointerMoveOver","setOnPointerMoveOut","setOnWheel","markAsInBounds","pointerId","pointersInBounds","indexOf","push","markAsOutOfBounds","index","splice","resetManager"],"sources":["/home/user/rork-vibesync-458/node_modules/react-native-gesture-handler/lib/module/web/tools/EventManager.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-empty-function */\nimport { AdaptedEvent, EventTypes } from '../interfaces';\n\ntype PointerEventCallback = (event: AdaptedEvent) => void;\n\nexport default abstract class EventManager<T> {\n  protected readonly view: T;\n  protected pointersInBounds: number[] = [];\n  protected activePointersCounter: number;\n\n  constructor(view: T) {\n    this.view = view;\n    this.activePointersCounter = 0;\n  }\n\n  public abstract registerListeners(): void;\n  public abstract unregisterListeners(): void;\n\n  protected abstract mapEvent(\n    event: Event,\n    eventType: EventTypes\n  ): AdaptedEvent;\n\n  protected onPointerDown(_event: AdaptedEvent): void {}\n  protected onPointerAdd(_event: AdaptedEvent): void {}\n  protected onPointerUp(_event: AdaptedEvent): void {}\n  protected onPointerRemove(_event: AdaptedEvent): void {}\n  protected onPointerMove(_event: AdaptedEvent): void {}\n  protected onPointerLeave(_event: AdaptedEvent): void {} // Called only when pointer is pressed (or touching)\n  protected onPointerEnter(_event: AdaptedEvent): void {} // Called only when pointer is pressed (or touching)\n  protected onPointerCancel(_event: AdaptedEvent): void {\n    // When pointer cancel is triggered and there are more pointers on the view, only one pointer is cancelled\n    // Because we want all pointers to be cancelled by that event, we are doing it manually by reseting handler and changing activePointersCounter to 0\n    // Events that correspond to removing the pointer (pointerup, touchend) have condition, that they don't perform any action when activePointersCounter\n    // is equal to 0. This prevents counter from going to negative values, when pointers are removed from view after one of them has been cancelled\n  }\n  protected onPointerOutOfBounds(_event: AdaptedEvent): void {}\n  protected onPointerMoveOver(_event: AdaptedEvent): void {}\n  protected onPointerMoveOut(_event: AdaptedEvent): void {}\n  protected onWheel(_event: AdaptedEvent): void {}\n\n  public setOnPointerDown(callback: PointerEventCallback): void {\n    this.onPointerDown = callback;\n  }\n  public setOnPointerAdd(callback: PointerEventCallback): void {\n    this.onPointerAdd = callback;\n  }\n  public setOnPointerUp(callback: PointerEventCallback): void {\n    this.onPointerUp = callback;\n  }\n  public setOnPointerRemove(callback: PointerEventCallback): void {\n    this.onPointerRemove = callback;\n  }\n  public setOnPointerMove(callback: PointerEventCallback): void {\n    this.onPointerMove = callback;\n  }\n  public setOnPointerLeave(callback: PointerEventCallback): void {\n    this.onPointerLeave = callback;\n  }\n  public setOnPointerEnter(callback: PointerEventCallback): void {\n    this.onPointerEnter = callback;\n  }\n  public setOnPointerCancel(callback: PointerEventCallback): void {\n    this.onPointerCancel = callback;\n  }\n  public setOnPointerOutOfBounds(callback: PointerEventCallback): void {\n    this.onPointerOutOfBounds = callback;\n  }\n  public setOnPointerMoveOver(callback: PointerEventCallback): void {\n    this.onPointerMoveOver = callback;\n  }\n  public setOnPointerMoveOut(callback: PointerEventCallback): void {\n    this.onPointerMoveOut = callback;\n  }\n  public setOnWheel(callback: PointerEventCallback): void {\n    this.onWheel = callback;\n  }\n\n  protected markAsInBounds(pointerId: number): void {\n    if (this.pointersInBounds.indexOf(pointerId) >= 0) {\n      return;\n    }\n\n    this.pointersInBounds.push(pointerId);\n  }\n\n  protected markAsOutOfBounds(pointerId: number): void {\n    const index: number = this.pointersInBounds.indexOf(pointerId);\n\n    if (index < 0) {\n      return;\n    }\n\n    this.pointersInBounds.splice(index, 1);\n  }\n\n  public resetManager(): void {\n    // Reseting activePointersCounter is necessary to make gestures such as pinch work properly\n    // There are gestures that end when there is still one active pointer (like pinch/rotation)\n    // When these gestures end, they are reset, but they still receive events from pointer that is active\n    // This causes trouble, since only onPointerDown registers gesture in orchestrator, and while gestures receive\n    // Events from active pointer after they finished, next pointerdown event will be registered as additional pointer, not the first one\n    // This casues trouble like gestures getting stuck in END state, even though they should have gone to UNDETERMINED\n\n    this.activePointersCounter = 0;\n    this.pointersInBounds = [];\n  }\n}\n"],"mappings":"sLAKA,cAAe,MAAe,CAAAA,YAAgB,CAK5CC,WAAWA,CAACC,IAAD,CAAU,CAAAC,eAAA,qBAAAA,eAAA,yBAHkB,EAGlB,EAAAA,eAAA,sCACnB,KAAKD,IAAL,CAAYA,IAAZ,CACA,KAAKE,qBAAL,CAA6B,CAA7B,CACD,CAUSC,aAAaA,CAACC,MAAD,CAA6B,CAAE,CAC5CC,YAAYA,CAACD,MAAD,CAA6B,CAAE,CAC3CE,WAAWA,CAACF,MAAD,CAA6B,CAAE,CAC1CG,eAAeA,CAACH,MAAD,CAA6B,CAAE,CAC9CI,aAAaA,CAACJ,MAAD,CAA6B,CAAE,CAC5CK,cAAcA,CAACL,MAAD,CAA6B,CAAE,CAC7CM,cAAcA,CAACN,MAAD,CAA6B,CAAE,CAC7CO,eAAeA,CAACP,MAAD,CAA6B,CAKrD,CACSQ,oBAAoBA,CAACR,MAAD,CAA6B,CAAE,CACnDS,iBAAiBA,CAACT,MAAD,CAA6B,CAAE,CAChDU,gBAAgBA,CAACV,MAAD,CAA6B,CAAE,CAC/CW,OAAOA,CAACX,MAAD,CAA6B,CAAE,CAEzCY,gBAAgBA,CAACC,QAAD,CAAuC,CAC5D,KAAKd,aAAL,CAAqBc,QAArB,CACD,CACMC,eAAeA,CAACD,QAAD,CAAuC,CAC3D,KAAKZ,YAAL,CAAoBY,QAApB,CACD,CACME,cAAcA,CAACF,QAAD,CAAuC,CAC1D,KAAKX,WAAL,CAAmBW,QAAnB,CACD,CACMG,kBAAkBA,CAACH,QAAD,CAAuC,CAC9D,KAAKV,eAAL,CAAuBU,QAAvB,CACD,CACMI,gBAAgBA,CAACJ,QAAD,CAAuC,CAC5D,KAAKT,aAAL,CAAqBS,QAArB,CACD,CACMK,iBAAiBA,CAACL,QAAD,CAAuC,CAC7D,KAAKR,cAAL,CAAsBQ,QAAtB,CACD,CACMM,iBAAiBA,CAACN,QAAD,CAAuC,CAC7D,KAAKP,cAAL,CAAsBO,QAAtB,CACD,CACMO,kBAAkBA,CAACP,QAAD,CAAuC,CAC9D,KAAKN,eAAL,CAAuBM,QAAvB,CACD,CACMQ,uBAAuBA,CAACR,QAAD,CAAuC,CACnE,KAAKL,oBAAL,CAA4BK,QAA5B,CACD,CACMS,oBAAoBA,CAACT,QAAD,CAAuC,CAChE,KAAKJ,iBAAL,CAAyBI,QAAzB,CACD,CACMU,mBAAmBA,CAACV,QAAD,CAAuC,CAC/D,KAAKH,gBAAL,CAAwBG,QAAxB,CACD,CACMW,UAAUA,CAACX,QAAD,CAAuC,CACtD,KAAKF,OAAL,CAAeE,QAAf,CACD,CAESY,cAAcA,CAACC,SAAD,CAA0B,CAChD,GAAI,KAAKC,gBAAL,CAAsBC,OAAtB,CAA8BF,SAA9B,GAA4C,CAAhD,CAAmD,CACjD,OACD,CAED,KAAKC,gBAAL,CAAsBE,IAAtB,CAA2BH,SAA3B,EACD,CAESI,iBAAiBA,CAACJ,SAAD,CAA0B,CACnD,KAAM,CAAAK,KAAa,CAAG,KAAKJ,gBAAL,CAAsBC,OAAtB,CAA8BF,SAA9B,CAAtB,CAEA,GAAIK,KAAK,CAAG,CAAZ,CAAe,CACb,OACD,CAED,KAAKJ,gBAAL,CAAsBK,MAAtB,CAA6BD,KAA7B,CAAoC,CAApC,EACD,CAEME,YAAYA,CAAA,CAAS,CAQ1B,KAAKnC,qBAAL,CAA6B,CAA7B,CACA,KAAK6B,gBAAL,CAAwB,EAAxB,CACD,CArG2C","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}