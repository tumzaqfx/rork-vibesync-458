{"ast":null,"code":"import{Platform}from'expo-modules-core';export const userMediaRequested=false;export const mountedInstances=[];async function requestLegacyUserMediaAsync(props){const optionalSource=id=>({optional:[{sourceId:id}]});const constraintToSourceId=constraint=>{const{deviceId}=constraint;if(typeof deviceId==='string'){return deviceId;}if(Array.isArray(deviceId)){return deviceId[0]??null;}else if(typeof deviceId==='object'&&deviceId.ideal){return deviceId.ideal;}return null;};const sources=await new Promise(resolve=>MediaStreamTrack.getSources(sources=>resolve(sources)));let audioSource=null;let videoSource=null;sources.forEach(source=>{if(source.kind==='audio'){audioSource=source.id;}else if(source.kind==='video'){videoSource=source.id;}});const audioSourceId=constraintToSourceId(props.audioConstraints);if(audioSourceId){audioSource=audioSourceId;}const videoSourceId=constraintToSourceId(props.videoConstraints);if(videoSourceId){videoSource=videoSourceId;}return[optionalSource(audioSource),optionalSource(videoSource)];}async function sourceSelectedAsync(isMuted,audioConstraints,videoConstraints){const constraints={video:typeof videoConstraints!=='undefined'?videoConstraints:true};if(!isMuted){constraints.audio=typeof audioConstraints!=='undefined'?audioConstraints:true;}return await getAnyUserMediaAsync(constraints);}export async function requestUserMediaAsync(props,isMuted=true){if(canGetUserMedia()){return await sourceSelectedAsync(isMuted,props.audio,props.video);}const[audio,video]=await requestLegacyUserMediaAsync(props);return await sourceSelectedAsync(isMuted,audio,video);}export async function getAnyUserMediaAsync(constraints,ignoreConstraints=false){try{return await getUserMediaAsync(Object.assign({},constraints,{video:ignoreConstraints||constraints.video}));}catch(error){if(!ignoreConstraints&&typeof error==='object'&&error?.name==='ConstraintNotSatisfiedError'){return await getAnyUserMediaAsync(constraints,true);}throw error;}}export async function getUserMediaAsync(constraints){if(navigator.mediaDevices&&navigator.mediaDevices.getUserMedia){return navigator.mediaDevices.getUserMedia(constraints);}const _getUserMedia=navigator['mozGetUserMedia']||navigator['webkitGetUserMedia']||navigator['msGetUserMedia'];return new Promise((resolve,reject)=>_getUserMedia.call(navigator,constraints,resolve,reject));}export function canGetUserMedia(){return(Platform.isDOMAvailable&&!!(navigator.mediaDevices&&navigator.mediaDevices.getUserMedia||navigator['mozGetUserMedia']||navigator['webkitGetUserMedia']||navigator['msGetUserMedia']));}export async function isFrontCameraAvailableAsync(devices){return await supportsCameraType(['front','user','facetime'],'user',devices);}export async function isBackCameraAvailableAsync(devices){return await supportsCameraType(['back','rear'],'environment',devices);}async function supportsCameraType(labels,type,devices){if(!devices){if(!navigator.mediaDevices.enumerateDevices){return null;}devices=await navigator.mediaDevices.enumerateDevices();}const cameras=devices.filter(t=>t.kind==='videoinput');const[hasCamera]=cameras.filter(camera=>labels.some(label=>camera.label.toLowerCase().includes(label)));const[isCapable]=cameras.filter(camera=>{if(!('getCapabilities'in camera)){return null;}const capabilities=camera.getCapabilities();if(!capabilities.facingMode){return null;}return capabilities.facingMode.find(_=>type);});return isCapable?.deviceId||hasCamera?.deviceId||null;}","map":{"version":3,"names":["Platform","userMediaRequested","mountedInstances","requestLegacyUserMediaAsync","props","optionalSource","id","optional","sourceId","constraintToSourceId","constraint","deviceId","Array","isArray","ideal","sources","Promise","resolve","MediaStreamTrack","getSources","audioSource","videoSource","forEach","source","kind","audioSourceId","audioConstraints","videoSourceId","videoConstraints","sourceSelectedAsync","isMuted","constraints","video","audio","getAnyUserMediaAsync","requestUserMediaAsync","canGetUserMedia","ignoreConstraints","getUserMediaAsync","Object","assign","error","name","navigator","mediaDevices","getUserMedia","_getUserMedia","reject","call","isDOMAvailable","isFrontCameraAvailableAsync","devices","supportsCameraType","isBackCameraAvailableAsync","labels","type","enumerateDevices","cameras","filter","t","hasCamera","camera","some","label","toLowerCase","includes","isCapable","capabilities","getCapabilities","facingMode","find","_"],"sources":["/home/user/rork-vibesync-458/node_modules/expo-camera/src/web/WebUserMediaManager.ts"],"sourcesContent":["/* eslint-env browser */\n/**\n * A web-only module for ponyfilling the UserMedia API.\n */\nimport { Platform } from 'expo-modules-core';\n\nexport const userMediaRequested: boolean = false;\n\nexport const mountedInstances: any[] = [];\n\nasync function requestLegacyUserMediaAsync(\n  // TODO(@kitten): Type this properly\n  props: { audioConstraints?: any; videoConstraints?: any }\n): Promise<any[]> {\n  // TODO(@kitten): This is never type checked against DOM types\n  const optionalSource = (id: string | string[] | null) => ({ optional: [{ sourceId: id }] });\n\n  const constraintToSourceId = (constraint: MediaTrackConstraintSet) => {\n    const { deviceId } = constraint;\n\n    if (typeof deviceId === 'string') {\n      return deviceId;\n    }\n\n    if (Array.isArray(deviceId)) {\n      return deviceId[0] ?? null;\n    } else if (typeof deviceId === 'object' && deviceId.ideal) {\n      return deviceId.ideal;\n    }\n\n    return null;\n  };\n\n  const sources: any[] = await new Promise((resolve) =>\n    // @ts-ignore: https://caniuse.com/#search=getSources Chrome for Android (78) & Samsung Internet (10.1) use this\n    MediaStreamTrack.getSources((sources) => resolve(sources))\n  );\n\n  let audioSource = null;\n  let videoSource = null;\n\n  sources.forEach((source) => {\n    if (source.kind === 'audio') {\n      audioSource = source.id;\n    } else if (source.kind === 'video') {\n      videoSource = source.id;\n    }\n  });\n\n  // NOTE(@kitten): This doesn't seem right. The types that should be used here don't contain `audioConstraints`\n  // If this is legacy, the type shouldn't have been dropped but marked as `@deprecated`. Alternatively, remove this code path\n  const audioSourceId = constraintToSourceId(props.audioConstraints);\n  if (audioSourceId) {\n    audioSource = audioSourceId;\n  }\n\n  // NOTE(@kitten): This doesn't seem right. The types that should be used here don't contain `videoConstraints`\n  // If this is legacy, the type shouldn't have been dropped but marked as `@deprecated`. Alternatively, remove this code path\n  const videoSourceId = constraintToSourceId(props.videoConstraints);\n  if (videoSourceId) {\n    videoSource = videoSourceId;\n  }\n\n  return [optionalSource(audioSource), optionalSource(videoSource)];\n}\n\nasync function sourceSelectedAsync(\n  isMuted: boolean,\n  audioConstraints?: MediaTrackConstraints | boolean,\n  videoConstraints?: MediaTrackConstraints | boolean\n): Promise<MediaStream> {\n  const constraints: MediaStreamConstraints = {\n    video: typeof videoConstraints !== 'undefined' ? videoConstraints : true,\n  };\n\n  if (!isMuted) {\n    constraints.audio = typeof audioConstraints !== 'undefined' ? audioConstraints : true;\n  }\n\n  return await getAnyUserMediaAsync(constraints);\n}\n\nexport async function requestUserMediaAsync(\n  // TODO(@kitten): Type this properly\n  props: { audio?: any; video?: any },\n  isMuted: boolean = true\n): Promise<MediaStream> {\n  if (canGetUserMedia()) {\n    return await sourceSelectedAsync(isMuted, props.audio, props.video);\n  }\n  // NOTE(@kitten): This doesn't seem right. The types that should be used here don't contain `videoConstraints`\n  // If this is legacy, the type shouldn't have been dropped but marked as `@deprecated`. Alternatively, remove this code path\n  const [audio, video] = await requestLegacyUserMediaAsync(props as any);\n  return await sourceSelectedAsync(isMuted, audio, video);\n}\n\nexport async function getAnyUserMediaAsync(\n  constraints: MediaStreamConstraints,\n  ignoreConstraints: boolean = false\n): Promise<MediaStream> {\n  try {\n    return await getUserMediaAsync({\n      ...constraints,\n      video: ignoreConstraints || constraints.video,\n    });\n  } catch (error: any) {\n    if (\n      !ignoreConstraints &&\n      typeof error === 'object' &&\n      error?.name === 'ConstraintNotSatisfiedError'\n    ) {\n      return await getAnyUserMediaAsync(constraints, true);\n    }\n    throw error;\n  }\n}\n\nexport async function getUserMediaAsync(constraints: MediaStreamConstraints): Promise<MediaStream> {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n\n  const _getUserMedia =\n    navigator['mozGetUserMedia'] ||\n    navigator['webkitGetUserMedia'] ||\n    // @ts-expect-error: TODO(@kitten): Remove / Drop IE support\n    navigator['msGetUserMedia'];\n  return new Promise((resolve, reject) =>\n    _getUserMedia.call(navigator, constraints, resolve, reject)\n  );\n}\n\nexport function canGetUserMedia(): boolean {\n  // TODO(@kitten): This is misaligned with the implementations in `expo-audio/src/AudioModule.web.ts` and `expo-av`\n  return (\n    // SSR\n    Platform.isDOMAvailable &&\n    // Has any form of media API\n    !!(\n      (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) ||\n      navigator['mozGetUserMedia'] ||\n      navigator['webkitGetUserMedia'] ||\n      // @ts-expect-error: TODO(@kitten): Remove / Drop IE support\n      navigator['msGetUserMedia']\n    )\n  );\n}\n\nexport async function isFrontCameraAvailableAsync(\n  devices?: MediaDeviceInfo[]\n): Promise<null | string> {\n  return await supportsCameraType(['front', 'user', 'facetime'], 'user', devices);\n}\n\nexport async function isBackCameraAvailableAsync(\n  devices?: MediaDeviceInfo[]\n): Promise<null | string> {\n  return await supportsCameraType(['back', 'rear'], 'environment', devices);\n}\n\nasync function supportsCameraType(\n  labels: string[],\n  type: string,\n  devices?: MediaDeviceInfo[]\n): Promise<null | string> {\n  if (!devices) {\n    if (!navigator.mediaDevices.enumerateDevices) {\n      return null;\n    }\n    devices = await navigator.mediaDevices.enumerateDevices();\n  }\n  const cameras = devices.filter((t) => t.kind === 'videoinput');\n  const [hasCamera] = cameras.filter((camera) =>\n    labels.some((label) => camera.label.toLowerCase().includes(label))\n  );\n  const [isCapable] = cameras.filter((camera) => {\n    if (!('getCapabilities' in camera)) {\n      return null;\n    }\n\n    const capabilities = (camera as any).getCapabilities();\n    if (!capabilities.facingMode) {\n      return null;\n    }\n\n    return capabilities.facingMode.find((_: string) => type);\n  });\n\n  return isCapable?.deviceId || hasCamera?.deviceId || null;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}