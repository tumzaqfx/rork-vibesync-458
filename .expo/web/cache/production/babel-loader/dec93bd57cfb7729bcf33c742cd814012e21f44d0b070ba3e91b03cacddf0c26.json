{"ast":null,"code":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.getNavigationConfig=getNavigationConfig;exports.getLinkingConfig=getLinkingConfig;const native_1=require(\"@react-navigation/native\");const expo_modules_core_1=require(\"expo-modules-core\");const constants_1=require(\"./constants\");const getReactNavigationConfig_1=require(\"./getReactNavigationConfig\");const getRoutesRedirects_1=require(\"./getRoutesRedirects\");const linking_1=require(\"./link/linking\");function getNavigationConfig(routes,metaOnly=true){return{screens:{[constants_1.INTERNAL_SLOT_NAME]:Object.assign({path:''},(0,getReactNavigationConfig_1.getReactNavigationConfig)(routes,metaOnly))}};}function getLinkingConfig(routes,context,getRouteInfo,{metaOnly=true,serverUrl,redirects}={}){let hasCachedInitialUrl=false;let initialUrl;const nativeLinkingKey=context.keys().find(key=>key.match(/^\\.\\/\\+native-intent\\.[tj]sx?$/));const nativeLinking=nativeLinkingKey?context(nativeLinkingKey):undefined;const config=getNavigationConfig(routes,metaOnly);return{prefixes:[],config,getInitialURL(){if(!hasCachedInitialUrl){if(expo_modules_core_1.Platform.OS==='web'){initialUrl=serverUrl??(0,linking_1.getInitialURL)();}else{initialUrl=serverUrl??(0,linking_1.getInitialURL)();if(typeof initialUrl==='string'){initialUrl=(0,getRoutesRedirects_1.applyRedirects)(initialUrl,redirects);if(initialUrl&&typeof nativeLinking?.redirectSystemPath==='function'){initialUrl=nativeLinking.redirectSystemPath({path:initialUrl,initial:true});}}else if(initialUrl){initialUrl=initialUrl.then(url=>{url=(0,getRoutesRedirects_1.applyRedirects)(url,redirects);if(url&&typeof nativeLinking?.redirectSystemPath==='function'){return nativeLinking.redirectSystemPath({path:url,initial:true});}return url;});}}hasCachedInitialUrl=true;}return initialUrl;},subscribe:(0,linking_1.subscribe)(nativeLinking,redirects),getStateFromPath:(path,options)=>{return(0,linking_1.getStateFromPath)(path,options,getRouteInfo().segments);},getPathFromState(state,options){return(0,linking_1.getPathFromState)(state,Object.assign({},config,options,{screens:config.screens??options?.screens??{}}))??'/';},getActionFromState:native_1.getActionFromState};}","map":{"version":3,"names":["exports","getNavigationConfig","getLinkingConfig","native_1","require","expo_modules_core_1","constants_1","getReactNavigationConfig_1","getRoutesRedirects_1","linking_1","routes","metaOnly","screens","INTERNAL_SLOT_NAME","Object","assign","path","getReactNavigationConfig","context","getRouteInfo","serverUrl","redirects","hasCachedInitialUrl","initialUrl","nativeLinkingKey","keys","find","key","match","nativeLinking","undefined","config","prefixes","getInitialURL","Platform","OS","applyRedirects","redirectSystemPath","initial","then","url","subscribe","getStateFromPath","options","segments","getPathFromState","state","getActionFromState"],"sources":["/home/user/rork-vibesync-458/node_modules/expo-router/src/getLinkingConfig.ts"],"sourcesContent":["import { getActionFromState, LinkingOptions } from '@react-navigation/native';\nimport { Platform } from 'expo-modules-core';\n\nimport { RouteNode } from './Route';\nimport { INTERNAL_SLOT_NAME } from './constants';\nimport { Options, State } from './fork/getPathFromState';\nimport { getReactNavigationConfig } from './getReactNavigationConfig';\nimport { applyRedirects } from './getRoutesRedirects';\nimport { UrlObject } from './global-state/routeInfo';\nimport type { StoreRedirects } from './global-state/router-store';\nimport { getInitialURL, getPathFromState, getStateFromPath, subscribe } from './link/linking';\nimport { NativeIntent, RequireContext } from './types';\n\nexport function getNavigationConfig(routes: RouteNode, metaOnly: boolean = true) {\n  return {\n    screens: {\n      [INTERNAL_SLOT_NAME]: {\n        path: '',\n        ...getReactNavigationConfig(routes, metaOnly),\n      },\n    },\n  };\n}\n\nexport type ExpoLinkingOptions<T extends object = Record<string, unknown>> = LinkingOptions<T> & {\n  getPathFromState: typeof getPathFromState;\n  getStateFromPath: typeof getStateFromPath;\n};\n\nexport type LinkingConfigOptions = {\n  metaOnly?: boolean;\n  serverUrl?: string;\n  getInitialURL?: typeof getInitialURL;\n  redirects?: StoreRedirects[];\n};\n\nexport function getLinkingConfig(\n  routes: RouteNode,\n  context: RequireContext,\n  getRouteInfo: () => UrlObject,\n  { metaOnly = true, serverUrl, redirects }: LinkingConfigOptions = {}\n): ExpoLinkingOptions {\n  // Returning `undefined` / `null from `getInitialURL` are valid values, so we need to track if it's been called.\n  let hasCachedInitialUrl = false;\n  let initialUrl: ReturnType<typeof getInitialURL> | undefined;\n\n  const nativeLinkingKey = context\n    .keys()\n    .find((key) => key.match(/^\\.\\/\\+native-intent\\.[tj]sx?$/));\n  const nativeLinking: NativeIntent | undefined = nativeLinkingKey\n    ? context(nativeLinkingKey)\n    : undefined;\n\n  const config = getNavigationConfig(routes, metaOnly);\n\n  return {\n    prefixes: [],\n    config,\n    // A custom getInitialURL is used on native to ensure the app always starts at\n    // the root path if it's launched from something other than a deep link.\n    // This helps keep the native functionality working like the web functionality.\n    // For example, if you had a root navigator where the first screen was `/settings` and the second was `/index`\n    // then `/index` would be used on web and `/settings` would be used on native.\n    getInitialURL() {\n      // Expo Router calls `getInitialURL` twice, which may confuse the user if they provide a custom `getInitialURL`.\n      // Therefor we memoize the result.\n      if (!hasCachedInitialUrl) {\n        if (Platform.OS === 'web') {\n          initialUrl = serverUrl ?? getInitialURL();\n        } else {\n          initialUrl = serverUrl ?? getInitialURL();\n\n          if (typeof initialUrl === 'string') {\n            initialUrl = applyRedirects(initialUrl, redirects);\n            if (initialUrl && typeof nativeLinking?.redirectSystemPath === 'function') {\n              initialUrl = nativeLinking.redirectSystemPath({ path: initialUrl, initial: true });\n            }\n          } else if (initialUrl) {\n            initialUrl = initialUrl.then((url) => {\n              url = applyRedirects(url, redirects);\n              if (url && typeof nativeLinking?.redirectSystemPath === 'function') {\n                return nativeLinking.redirectSystemPath({ path: url, initial: true });\n              }\n              return url;\n            });\n          }\n        }\n        hasCachedInitialUrl = true;\n      }\n      return initialUrl;\n    },\n    subscribe: subscribe(nativeLinking, redirects),\n    getStateFromPath: <ParamList extends object>(path: string, options?: Options<ParamList>) => {\n      return getStateFromPath(path, options, getRouteInfo().segments);\n    },\n    getPathFromState(state: State, options: Parameters<typeof getPathFromState>[1]) {\n      return (\n        getPathFromState(state, {\n          ...config,\n          ...options,\n          screens: config.screens ?? options?.screens ?? {},\n        }) ?? '/'\n      );\n    },\n    // Add all functions to ensure the types never need to fallback.\n    // This is a convenience for usage in the package.\n    getActionFromState,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}