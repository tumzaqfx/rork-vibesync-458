{"ast":null,"code":"'use client';import{useEffect,useRef,useState}from'react';import{Image}from'./Image';import{resolveSource}from'./utils/resolveSources';export function useImage(source,options={},dependencies=[]){const resolvedSource=resolveSource(source);const[image,setImage]=useState(null);const optionsRef=useRef(options);optionsRef.current=options;useEffect(()=>{let isEffectValid=true;function loadImage(){Image.loadAsync(resolvedSource,options).then(image=>{if(isEffectValid){setImage(image);}}).catch(error=>{if(!isEffectValid){return;}if(optionsRef.current.onError){optionsRef.current.onError(error,loadImage);}else{console.error(`Loading an image from '${resolvedSource.uri}' failed, use 'onError' option to handle errors and suppress this message`);console.error(error);}});}loadImage();return()=>{isEffectValid=false;image?.release();};},[resolvedSource.uri,...dependencies]);return image;}","map":{"version":3,"names":["useEffect","useRef","useState","Image","resolveSource","useImage","source","options","dependencies","resolvedSource","image","setImage","optionsRef","current","isEffectValid","loadImage","loadAsync","then","catch","error","onError","console","uri","release"],"sources":["/home/user/rork-vibesync-458/node_modules/expo-image/src/useImage.ts"],"sourcesContent":["'use client';\n\nimport { DependencyList, useEffect, useRef, useState } from 'react';\n\nimport { Image } from './Image';\nimport type { ImageLoadOptions, ImageRef, ImageSource } from './Image.types';\nimport { resolveSource } from './utils/resolveSources';\n\n/**\n * A hook that loads an image from the given source and returns a reference\n * to the native image instance, or `null` until the first image is successfully loaded.\n *\n * It loads a new image every time the `uri` of the provided source changes.\n * To trigger reloads in some other scenarios, you can provide an additional dependency list.\n * @platform android\n * @platform ios\n * @platform web\n *\n * @example\n * ```ts\n * import { useImage, Image } from 'expo-image';\n * import { Text } from 'react-native';\n *\n * export default function MyImage() {\n *   const image = useImage('https://picsum.photos/1000/800', {\n *     maxWidth: 800,\n *     onError(error, retry) {\n *       console.error('Loading failed:', error.message);\n *     }\n *   });\n *\n *   if (!image) {\n *     return <Text>Image is loading...</Text>;\n *   }\n *\n *   return <Image source={image} style={{ width: image.width / 2, height: image.height / 2 }} />;\n * }\n * ```\n */\nexport function useImage(\n  source: ImageSource | string | number,\n  options: ImageLoadOptions = {},\n  dependencies: DependencyList = []\n): ImageRef | null {\n  const resolvedSource = resolveSource(source) as ImageSource;\n  const [image, setImage] = useState<ImageRef | null>(null);\n\n  // Since options are not dependencies of the below effect, we store them in a ref.\n  // Once the image is asynchronously loaded, the effect will use the most recent options,\n  // instead of the captured ones (especially important for callbacks that may change in subsequent renders).\n  const optionsRef = useRef<ImageLoadOptions>(options);\n  optionsRef.current = options;\n\n  useEffect(() => {\n    // We're doing some asynchronous action in this effect, so we should keep track\n    // if the effect was already cleaned up. In that case, the async action shouldn't change the state.\n    let isEffectValid = true;\n\n    function loadImage() {\n      Image.loadAsync(resolvedSource, options)\n        .then((image) => {\n          if (isEffectValid) {\n            setImage(image);\n          }\n        })\n        .catch((error) => {\n          if (!isEffectValid) {\n            return;\n          }\n          if (optionsRef.current.onError) {\n            optionsRef.current.onError(error, loadImage);\n          } else {\n            // Print unhandled errors to the console.\n            console.error(\n              `Loading an image from '${resolvedSource.uri}' failed, use 'onError' option to handle errors and suppress this message`\n            );\n            console.error(error);\n          }\n        });\n    }\n\n    loadImage();\n\n    return () => {\n      // Invalidate the effect and release the shared object to free up memory.\n      isEffectValid = false;\n      image?.release();\n    };\n  }, [resolvedSource.uri, ...dependencies]);\n\n  return image;\n}\n"],"mappings":"AAAA,YAAY,CAEZ,OAAyBA,SAAS,CAAEC,MAAM,CAAEC,QAAQ,KAAQ,OAAO,CAEnE,OAASC,KAAK,KAAQ,SAAS,CAE/B,OAASC,aAAa,KAAQ,wBAAwB,CAiCtD,MAAO,SAAS,CAAAC,QAAQA,CACtBC,MAAqC,CACrCC,OAAyB,CAAG,CAAC,CAAC,CAC9BC,YAA4B,CAAG,EAAE,CAChB,CACjB,KAAM,CAAAC,cAAc,CAAGL,aAAa,CAACE,MAAM,CAAgB,CAC3D,KAAM,CAACI,KAAK,CAAEC,QAAQ,CAAC,CAAGT,QAAQ,CAAkB,IAAI,CAAC,CAKzD,KAAM,CAAAU,UAAU,CAAGX,MAAM,CAAmBM,OAAO,CAAC,CACpDK,UAAU,CAACC,OAAO,CAAGN,OAAO,CAE5BP,SAAS,CAAC,IAAM,CAGd,GAAI,CAAAc,aAAa,CAAG,IAAI,CAExB,QAAS,CAAAC,SAASA,CAAA,CAAG,CACnBZ,KAAK,CAACa,SAAS,CAACP,cAAc,CAAEF,OAAO,CAAC,CACrCU,IAAI,CAAEP,KAAK,EAAK,CACf,GAAII,aAAa,CAAE,CACjBH,QAAQ,CAACD,KAAK,CAAC,CACjB,CACF,CAAC,CAAC,CACDQ,KAAK,CAAEC,KAAK,EAAK,CAChB,GAAI,CAACL,aAAa,CAAE,CAClB,OACF,CACA,GAAIF,UAAU,CAACC,OAAO,CAACO,OAAO,CAAE,CAC9BR,UAAU,CAACC,OAAO,CAACO,OAAO,CAACD,KAAK,CAAEJ,SAAS,CAAC,CAC9C,CAAC,IAAM,CAELM,OAAO,CAACF,KAAK,CACX,0BAA0BV,cAAc,CAACa,GAAG,2EAC9C,CAAC,CACDD,OAAO,CAACF,KAAK,CAACA,KAAK,CAAC,CACtB,CACF,CAAC,CAAC,CACN,CAEAJ,SAAS,CAAC,CAAC,CAEX,MAAO,IAAM,CAEXD,aAAa,CAAG,KAAK,CACrBJ,KAAK,EAAEa,OAAO,CAAC,CAAC,CAClB,CAAC,CACH,CAAC,CAAE,CAACd,cAAc,CAACa,GAAG,CAAE,GAAGd,YAAY,CAAC,CAAC,CAEzC,MAAO,CAAAE,KAAK,CACd","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}