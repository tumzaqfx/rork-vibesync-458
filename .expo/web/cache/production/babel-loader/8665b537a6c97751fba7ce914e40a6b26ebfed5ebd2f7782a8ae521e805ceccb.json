{"ast":null,"code":"function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}import{EventTypes}from'../interfaces';export default class RotationGestureDetector{constructor(callbacks){_defineProperty(this,\"onRotationBegin\",void 0);_defineProperty(this,\"onRotation\",void 0);_defineProperty(this,\"onRotationEnd\",void 0);_defineProperty(this,\"currentTime\",0);_defineProperty(this,\"previousTime\",0);_defineProperty(this,\"previousAngle\",0);_defineProperty(this,\"_rotation\",0);_defineProperty(this,\"_anchorX\",0);_defineProperty(this,\"_anchorY\",0);_defineProperty(this,\"isInProgress\",false);_defineProperty(this,\"keyPointers\",[NaN,NaN]);this.onRotationBegin=callbacks.onRotationBegin;this.onRotation=callbacks.onRotation;this.onRotationEnd=callbacks.onRotationEnd;}updateCurrent(event,tracker){this.previousTime=this.currentTime;this.currentTime=event.time;const[firstPointerID,secondPointerID]=this.keyPointers;const firstPointerCoords=tracker.getLastAbsoluteCoords(firstPointerID);const secondPointerCoords=tracker.getLastAbsoluteCoords(secondPointerID);const vectorX=secondPointerCoords.x-firstPointerCoords.x;const vectorY=secondPointerCoords.y-firstPointerCoords.y;this._anchorX=(firstPointerCoords.x+secondPointerCoords.x)/2;this._anchorY=(firstPointerCoords.y+secondPointerCoords.y)/2;const angle=-Math.atan2(vectorY,vectorX);this._rotation=Number.isNaN(this.previousAngle)?0:this.previousAngle-angle;this.previousAngle=angle;if(this.rotation>Math.PI){this._rotation-=Math.PI;}else if(this.rotation<-Math.PI){this._rotation+=Math.PI;}if(this.rotation>Math.PI/2){this._rotation-=Math.PI;}else if(this.rotation<-Math.PI/2){this._rotation+=Math.PI;}}finish(){if(!this.isInProgress){return;}this.isInProgress=false;this.keyPointers=[NaN,NaN];this.onRotationEnd(this);}setKeyPointers(tracker){if(this.keyPointers[0]&&this.keyPointers[1]){return;}const pointerIDs=tracker.trackedPointers.keys();this.keyPointers[0]=pointerIDs.next().value;this.keyPointers[1]=pointerIDs.next().value;}onTouchEvent(event,tracker){switch(event.eventType){case EventTypes.DOWN:this.isInProgress=false;break;case EventTypes.ADDITIONAL_POINTER_DOWN:if(this.isInProgress){break;}this.isInProgress=true;this.previousTime=event.time;this.previousAngle=NaN;this.setKeyPointers(tracker);this.updateCurrent(event,tracker);this.onRotationBegin(this);break;case EventTypes.MOVE:if(!this.isInProgress){break;}this.updateCurrent(event,tracker);this.onRotation(this);break;case EventTypes.ADDITIONAL_POINTER_UP:if(!this.isInProgress){break;}if(this.keyPointers.indexOf(event.pointerId)>=0){this.finish();}break;case EventTypes.UP:if(this.isInProgress){this.finish();}break;}return true;}reset(){this.keyPointers=[NaN,NaN];this.isInProgress=false;}get anchorX(){return this._anchorX;}get anchorY(){return this._anchorY;}get rotation(){return this._rotation;}get timeDelta(){return this.currentTime+this.previousTime;}}","map":{"version":3,"names":["EventTypes","RotationGestureDetector","constructor","callbacks","_defineProperty","NaN","onRotationBegin","onRotation","onRotationEnd","updateCurrent","event","tracker","previousTime","currentTime","time","firstPointerID","secondPointerID","keyPointers","firstPointerCoords","getLastAbsoluteCoords","secondPointerCoords","vectorX","x","vectorY","y","_anchorX","_anchorY","angle","Math","atan2","_rotation","Number","isNaN","previousAngle","rotation","PI","finish","isInProgress","setKeyPointers","pointerIDs","trackedPointers","keys","next","value","onTouchEvent","eventType","DOWN","ADDITIONAL_POINTER_DOWN","MOVE","ADDITIONAL_POINTER_UP","indexOf","pointerId","UP","reset","anchorX","anchorY","timeDelta"],"sources":["/home/user/rork-vibesync-458/node_modules/react-native-gesture-handler/lib/module/web/detectors/RotationGestureDetector.ts"],"sourcesContent":["import { AdaptedEvent, EventTypes } from '../interfaces';\nimport PointerTracker from '../tools/PointerTracker';\n\nexport interface RotationGestureListener {\n  onRotationBegin: (detector: RotationGestureDetector) => boolean;\n  onRotation: (detector: RotationGestureDetector) => boolean;\n  onRotationEnd: (detector: RotationGestureDetector) => void;\n}\n\nexport default class RotationGestureDetector\n  implements RotationGestureListener\n{\n  onRotationBegin: (detector: RotationGestureDetector) => boolean;\n  onRotation: (detector: RotationGestureDetector) => boolean;\n  onRotationEnd: (detector: RotationGestureDetector) => void;\n\n  private currentTime = 0;\n  private previousTime = 0;\n\n  private previousAngle = 0;\n  private _rotation = 0;\n\n  private _anchorX = 0;\n  private _anchorY = 0;\n\n  private isInProgress = false;\n\n  private keyPointers: number[] = [NaN, NaN];\n\n  constructor(callbacks: RotationGestureListener) {\n    this.onRotationBegin = callbacks.onRotationBegin;\n    this.onRotation = callbacks.onRotation;\n    this.onRotationEnd = callbacks.onRotationEnd;\n  }\n\n  private updateCurrent(event: AdaptedEvent, tracker: PointerTracker): void {\n    this.previousTime = this.currentTime;\n    this.currentTime = event.time;\n\n    const [firstPointerID, secondPointerID] = this.keyPointers;\n\n    const firstPointerCoords = tracker.getLastAbsoluteCoords(firstPointerID);\n    const secondPointerCoords = tracker.getLastAbsoluteCoords(secondPointerID);\n\n    const vectorX: number = secondPointerCoords.x - firstPointerCoords.x;\n    const vectorY: number = secondPointerCoords.y - firstPointerCoords.y;\n\n    this._anchorX = (firstPointerCoords.x + secondPointerCoords.x) / 2;\n    this._anchorY = (firstPointerCoords.y + secondPointerCoords.y) / 2;\n\n    // Angle diff should be positive when rotating in clockwise direction\n    const angle: number = -Math.atan2(vectorY, vectorX);\n\n    this._rotation = Number.isNaN(this.previousAngle)\n      ? 0\n      : this.previousAngle - angle;\n\n    this.previousAngle = angle;\n\n    if (this.rotation > Math.PI) {\n      this._rotation -= Math.PI;\n    } else if (this.rotation < -Math.PI) {\n      this._rotation += Math.PI;\n    }\n\n    if (this.rotation > Math.PI / 2) {\n      this._rotation -= Math.PI;\n    } else if (this.rotation < -Math.PI / 2) {\n      this._rotation += Math.PI;\n    }\n  }\n\n  private finish(): void {\n    if (!this.isInProgress) {\n      return;\n    }\n\n    this.isInProgress = false;\n    this.keyPointers = [NaN, NaN];\n    this.onRotationEnd(this);\n  }\n\n  private setKeyPointers(tracker: PointerTracker): void {\n    if (this.keyPointers[0] && this.keyPointers[1]) {\n      return;\n    }\n\n    const pointerIDs: IterableIterator<number> = tracker.trackedPointers.keys();\n\n    this.keyPointers[0] = pointerIDs.next().value as number;\n    this.keyPointers[1] = pointerIDs.next().value as number;\n  }\n\n  public onTouchEvent(event: AdaptedEvent, tracker: PointerTracker): boolean {\n    switch (event.eventType) {\n      case EventTypes.DOWN:\n        this.isInProgress = false;\n        break;\n\n      case EventTypes.ADDITIONAL_POINTER_DOWN:\n        if (this.isInProgress) {\n          break;\n        }\n        this.isInProgress = true;\n\n        this.previousTime = event.time;\n        this.previousAngle = NaN;\n\n        this.setKeyPointers(tracker);\n\n        this.updateCurrent(event, tracker);\n        this.onRotationBegin(this);\n        break;\n\n      case EventTypes.MOVE:\n        if (!this.isInProgress) {\n          break;\n        }\n\n        this.updateCurrent(event, tracker);\n        this.onRotation(this);\n\n        break;\n\n      case EventTypes.ADDITIONAL_POINTER_UP:\n        if (!this.isInProgress) {\n          break;\n        }\n\n        if (this.keyPointers.indexOf(event.pointerId) >= 0) {\n          this.finish();\n        }\n\n        break;\n\n      case EventTypes.UP:\n        if (this.isInProgress) {\n          this.finish();\n        }\n        break;\n    }\n\n    return true;\n  }\n\n  public reset(): void {\n    this.keyPointers = [NaN, NaN];\n    this.isInProgress = false;\n  }\n\n  public get anchorX() {\n    return this._anchorX;\n  }\n\n  public get anchorY() {\n    return this._anchorY;\n  }\n\n  public get rotation() {\n    return this._rotation;\n  }\n\n  public get timeDelta() {\n    return this.currentTime + this.previousTime;\n  }\n}\n"],"mappings":"sLAAA,OAAuBA,UAAvB,KAAyC,eAAzC,CASA,cAAe,MAAM,CAAAC,uBAErB,CAkBEC,WAAWA,CAACC,SAAD,CAAqC,CAAAC,eAAA,gCAAAA,eAAA,2BAAAA,eAAA,8BAAAA,eAAA,oBAb1B,CAa0B,EAAAA,eAAA,qBAZzB,CAYyB,EAAAA,eAAA,sBAVxB,CAUwB,EAAAA,eAAA,kBAT5B,CAS4B,EAAAA,eAAA,iBAP7B,CAO6B,EAAAA,eAAA,iBAN7B,CAM6B,EAAAA,eAAA,qBAJzB,KAIyB,EAAAA,eAAA,oBAFhB,CAACC,GAAD,CAAMA,GAAN,CAEgB,EAC9C,KAAKC,eAAL,CAAuBH,SAAS,CAACG,eAAjC,CACA,KAAKC,UAAL,CAAkBJ,SAAS,CAACI,UAA5B,CACA,KAAKC,aAAL,CAAqBL,SAAS,CAACK,aAA/B,CACD,CAEOC,aAAaA,CAACC,KAAD,CAAsBC,OAAtB,CAAqD,CACxE,KAAKC,YAAL,CAAoB,KAAKC,WAAzB,CACA,KAAKA,WAAL,CAAmBH,KAAK,CAACI,IAAzB,CAEA,KAAM,CAACC,cAAD,CAAiBC,eAAjB,EAAoC,KAAKC,WAA/C,CAEA,KAAM,CAAAC,kBAAkB,CAAGP,OAAO,CAACQ,qBAAR,CAA8BJ,cAA9B,CAA3B,CACA,KAAM,CAAAK,mBAAmB,CAAGT,OAAO,CAACQ,qBAAR,CAA8BH,eAA9B,CAA5B,CAEA,KAAM,CAAAK,OAAe,CAAGD,mBAAmB,CAACE,CAApB,CAAwBJ,kBAAkB,CAACI,CAAnE,CACA,KAAM,CAAAC,OAAe,CAAGH,mBAAmB,CAACI,CAApB,CAAwBN,kBAAkB,CAACM,CAAnE,CAEA,KAAKC,QAAL,CAAgB,CAACP,kBAAkB,CAACI,CAAnB,CAAuBF,mBAAmB,CAACE,CAA5C,EAAiD,CAAjE,CACA,KAAKI,QAAL,CAAgB,CAACR,kBAAkB,CAACM,CAAnB,CAAuBJ,mBAAmB,CAACI,CAA5C,EAAiD,CAAjE,CAGA,KAAM,CAAAG,KAAa,CAAG,CAACC,IAAI,CAACC,KAAL,CAAWN,OAAX,CAAoBF,OAApB,CAAvB,CAEA,KAAKS,SAAL,CAAiBC,MAAM,CAACC,KAAP,CAAa,KAAKC,aAAlB,EACb,CADa,CAEb,KAAKA,aAAL,CAAqBN,KAFzB,CAIA,KAAKM,aAAL,CAAqBN,KAArB,CAEA,GAAI,KAAKO,QAAL,CAAgBN,IAAI,CAACO,EAAzB,CAA6B,CAC3B,KAAKL,SAAL,EAAkBF,IAAI,CAACO,EAAvB,CACD,CAFD,IAEO,IAAI,KAAKD,QAAL,CAAgB,CAACN,IAAI,CAACO,EAA1B,CAA8B,CACnC,KAAKL,SAAL,EAAkBF,IAAI,CAACO,EAAvB,CACD,CAED,GAAI,KAAKD,QAAL,CAAgBN,IAAI,CAACO,EAAL,CAAU,CAA9B,CAAiC,CAC/B,KAAKL,SAAL,EAAkBF,IAAI,CAACO,EAAvB,CACD,CAFD,IAEO,IAAI,KAAKD,QAAL,CAAgB,CAACN,IAAI,CAACO,EAAN,CAAW,CAA/B,CAAkC,CACvC,KAAKL,SAAL,EAAkBF,IAAI,CAACO,EAAvB,CACD,CACF,CAEOC,MAAMA,CAAA,CAAS,CACrB,GAAI,CAAC,KAAKC,YAAV,CAAwB,CACtB,OACD,CAED,KAAKA,YAAL,CAAoB,KAApB,CACA,KAAKpB,WAAL,CAAmB,CAACZ,GAAD,CAAMA,GAAN,CAAnB,CACA,KAAKG,aAAL,CAAmB,IAAnB,EACD,CAEO8B,cAAcA,CAAC3B,OAAD,CAAgC,CACpD,GAAI,KAAKM,WAAL,CAAiB,CAAjB,GAAuB,KAAKA,WAAL,CAAiB,CAAjB,CAA3B,CAAgD,CAC9C,OACD,CAED,KAAM,CAAAsB,UAAoC,CAAG5B,OAAO,CAAC6B,eAAR,CAAwBC,IAAxB,EAA7C,CAEA,KAAKxB,WAAL,CAAiB,CAAjB,EAAsBsB,UAAU,CAACG,IAAX,GAAkBC,KAAxC,CACA,KAAK1B,WAAL,CAAiB,CAAjB,EAAsBsB,UAAU,CAACG,IAAX,GAAkBC,KAAxC,CACD,CAEMC,YAAYA,CAAClC,KAAD,CAAsBC,OAAtB,CAAwD,CACzE,OAAQD,KAAK,CAACmC,SAAd,EACE,IAAK,CAAA7C,UAAU,CAAC8C,IAAhB,CACE,KAAKT,YAAL,CAAoB,KAApB,CACA,MAEF,IAAK,CAAArC,UAAU,CAAC+C,uBAAhB,CACE,GAAI,KAAKV,YAAT,CAAuB,CACrB,MACD,CACD,KAAKA,YAAL,CAAoB,IAApB,CAEA,KAAKzB,YAAL,CAAoBF,KAAK,CAACI,IAA1B,CACA,KAAKmB,aAAL,CAAqB5B,GAArB,CAEA,KAAKiC,cAAL,CAAoB3B,OAApB,EAEA,KAAKF,aAAL,CAAmBC,KAAnB,CAA0BC,OAA1B,EACA,KAAKL,eAAL,CAAqB,IAArB,EACA,MAEF,IAAK,CAAAN,UAAU,CAACgD,IAAhB,CACE,GAAI,CAAC,KAAKX,YAAV,CAAwB,CACtB,MACD,CAED,KAAK5B,aAAL,CAAmBC,KAAnB,CAA0BC,OAA1B,EACA,KAAKJ,UAAL,CAAgB,IAAhB,EAEA,MAEF,IAAK,CAAAP,UAAU,CAACiD,qBAAhB,CACE,GAAI,CAAC,KAAKZ,YAAV,CAAwB,CACtB,MACD,CAED,GAAI,KAAKpB,WAAL,CAAiBiC,OAAjB,CAAyBxC,KAAK,CAACyC,SAA/B,GAA6C,CAAjD,CAAoD,CAClD,KAAKf,MAAL,GACD,CAED,MAEF,IAAK,CAAApC,UAAU,CAACoD,EAAhB,CACE,GAAI,KAAKf,YAAT,CAAuB,CACrB,KAAKD,MAAL,GACD,CACD,MA7CJ,CAgDA,MAAO,KAAP,CACD,CAEMiB,KAAKA,CAAA,CAAS,CACnB,KAAKpC,WAAL,CAAmB,CAACZ,GAAD,CAAMA,GAAN,CAAnB,CACA,KAAKgC,YAAL,CAAoB,KAApB,CACD,CAEiB,GAAP,CAAAiB,OAAOA,CAAA,CAAG,CACnB,MAAO,MAAK7B,QAAZ,CACD,CAEiB,GAAP,CAAA8B,OAAOA,CAAA,CAAG,CACnB,MAAO,MAAK7B,QAAZ,CACD,CAEkB,GAAR,CAAAQ,QAAQA,CAAA,CAAG,CACpB,MAAO,MAAKJ,SAAZ,CACD,CAEmB,GAAT,CAAA0B,SAASA,CAAA,CAAG,CACrB,MAAO,MAAK3C,WAAL,CAAmB,KAAKD,YAA/B,CACD,CAzJH","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}