{"ast":null,"code":"import{useEffect,useMemo,useState}from'react';import{useBlurhash}from'../utils/blurhash/useBlurhash';import{isThumbhashString}from'../utils/resolveSources';import{thumbHashStringToDataURL}from'../utils/thumbhash/thumbhash';export function useThumbhash(source){const isThumbhash=isThumbhashString(source?.uri||'');const strippedThumbhashString=source?.uri?.replace(/thumbhash:\\//,'')??'';const thumbhashSource=useMemo(()=>isThumbhash?{uri:thumbHashStringToDataURL(strippedThumbhashString)}:null,[strippedThumbhashString,isThumbhash]);return[thumbhashSource,isThumbhash];}export function useImageHashes(source){const[thumbhash,isThumbhashString]=useThumbhash(source);const[blurhash,isBlurhashString]=useBlurhash(source);return useMemo(()=>{if(!isThumbhashString&&!isBlurhashString){return{resolvedSource:source,isImageHash:false};}if(!blurhash&&!thumbhash){return{resolvedSource:null,isImageHash:true};}return{resolvedSource:blurhash??thumbhash,isImageHash:true};},[blurhash,thumbhash,isThumbhashString,isBlurhashString,source]);}export function useHeaders(source,cachePolicy,onError){const[objectURL,setObjectURL]=useState(null);useEffect(()=>{(async()=>{if(!source?.headers||!source.uri){return;}try{const result=await fetch(source.uri,{headers:source.headers,cache:cachePolicy==='none'?'no-cache':'default',redirect:'follow'});if(!result.ok){throw new Error(`Failed to fetch image: ${result.status} ${result.statusText}`);}const blob=await result.blob();setObjectURL(prevObjURL=>{if(prevObjURL){URL.revokeObjectURL(prevObjURL);}return URL.createObjectURL(blob);});}catch{onError?.forEach(e=>e?.({source}));}})();},[source]);if(!source?.headers){return source;}if(!objectURL){return null;}return Object.assign({},source,{uri:objectURL});}","map":{"version":3,"names":["useEffect","useMemo","useState","useBlurhash","isThumbhashString","thumbHashStringToDataURL","useThumbhash","source","isThumbhash","uri","strippedThumbhashString","replace","thumbhashSource","useImageHashes","thumbhash","blurhash","isBlurhashString","resolvedSource","isImageHash","useHeaders","cachePolicy","onError","objectURL","setObjectURL","headers","result","fetch","cache","redirect","ok","Error","status","statusText","blob","prevObjURL","URL","revokeObjectURL","createObjectURL","forEach","e","Object","assign"],"sources":["/home/user/rork-vibesync-458/node_modules/expo-image/src/web/hooks.ts"],"sourcesContent":["import { useEffect, useMemo, useState } from 'react';\n\nimport { OnErrorEvent } from './ImageWrapper.types';\nimport { ImageNativeProps, ImageSource } from '../Image.types';\nimport { useBlurhash } from '../utils/blurhash/useBlurhash';\nimport { isThumbhashString } from '../utils/resolveSources';\nimport { thumbHashStringToDataURL } from '../utils/thumbhash/thumbhash';\n\nexport function useThumbhash(source: ImageSource | null | undefined) {\n  const isThumbhash = isThumbhashString(source?.uri || '');\n  const strippedThumbhashString = source?.uri?.replace(/thumbhash:\\//, '') ?? '';\n  const thumbhashSource = useMemo(\n    () => (isThumbhash ? { uri: thumbHashStringToDataURL(strippedThumbhashString) } : null),\n    [strippedThumbhashString, isThumbhash]\n  );\n  return [thumbhashSource, isThumbhash] as const;\n}\n\nexport function useImageHashes(source: ImageSource | null | undefined) {\n  const [thumbhash, isThumbhashString] = useThumbhash(source);\n  const [blurhash, isBlurhashString] = useBlurhash(source);\n  return useMemo(() => {\n    if (!isThumbhashString && !isBlurhashString) {\n      return { resolvedSource: source, isImageHash: false };\n    }\n    if (!blurhash && !thumbhash) {\n      return { resolvedSource: null, isImageHash: true };\n    }\n    return {\n      resolvedSource: blurhash ?? thumbhash,\n      isImageHash: true,\n    };\n  }, [blurhash, thumbhash, isThumbhashString, isBlurhashString, source]);\n}\n\nexport function useHeaders(\n  source: ImageSource | null | undefined,\n  cachePolicy: ImageNativeProps['cachePolicy'],\n  onError?: OnErrorEvent[]\n): ImageSource | null | undefined {\n  const [objectURL, setObjectURL] = useState<string | null>(null);\n  useEffect(() => {\n    (async () => {\n      if (!source?.headers || !source.uri) {\n        return;\n      }\n      try {\n        const result = await fetch(source.uri, {\n          headers: source.headers,\n          cache: cachePolicy === 'none' ? 'no-cache' : 'default',\n          redirect: 'follow',\n        });\n        if (!result.ok) {\n          throw new Error(`Failed to fetch image: ${result.status} ${result.statusText}`);\n        }\n        const blob = await result.blob();\n        setObjectURL((prevObjURL) => {\n          if (prevObjURL) {\n            URL.revokeObjectURL(prevObjURL);\n          }\n          return URL.createObjectURL(blob);\n        });\n      } catch {\n        onError?.forEach((e) => e?.({ source }));\n      }\n    })();\n  }, [source]);\n  if (!source?.headers) {\n    return source;\n  }\n  if (!objectURL) {\n    // Avoid fetching a URL without headers if we have headers\n    return null;\n  }\n  return { ...source, uri: objectURL };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}