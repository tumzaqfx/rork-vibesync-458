{"ast":null,"code":"\"use strict\";import escape from'escape-string-regexp';import*as queryString from'query-string';import{arrayStartsWith}from\"./arrayStartsWith.js\";import{findFocusedRoute}from\"./findFocusedRoute.js\";import{getPatternParts}from\"./getPatternParts.js\";import{isArrayEqual}from\"./isArrayEqual.js\";import{validatePathConfig}from\"./validatePathConfig.js\";export function getStateFromPath(path,options){const{initialRoutes,configs}=getConfigResources(options);const screens=options?.screens;let remaining=path.replace(/\\/+/g,'/').replace(/^\\//,'').replace(/\\?.*$/,'');remaining=remaining.endsWith('/')?remaining:`${remaining}/`;const prefix=options?.path?.replace(/^\\//,'');if(prefix){const normalizedPrefix=prefix.endsWith('/')?prefix:`${prefix}/`;if(!remaining.startsWith(normalizedPrefix)){return undefined;}remaining=remaining.replace(normalizedPrefix,'');}if(screens===undefined){const routes=remaining.split('/').filter(Boolean).map(segment=>{const name=decodeURIComponent(segment);return{name};});if(routes.length){return createNestedStateObject(path,routes,initialRoutes);}return undefined;}if(remaining==='/'){const match=configs.find(config=>config.segments.join('/')==='');if(match){return createNestedStateObject(path,match.routeNames.map(name=>({name})),initialRoutes,configs);}return undefined;}let result;let current;const{routes,remainingPath}=matchAgainstConfigs(remaining,configs);if(routes!==undefined){current=createNestedStateObject(path,routes,initialRoutes,configs);remaining=remainingPath;result=current;}if(current==null||result==null){return undefined;}return result;}const cachedConfigResources=new WeakMap();function getConfigResources(options){if(!options)return prepareConfigResources();const cached=cachedConfigResources.get(options);if(cached)return cached;const resources=prepareConfigResources(options);cachedConfigResources.set(options,resources);return resources;}function prepareConfigResources(options){if(options){validatePathConfig(options);}const initialRoutes=getInitialRoutes(options);const configs=getSortedNormalizedConfigs(initialRoutes,options?.screens);checkForDuplicatedConfigs(configs);const configWithRegexes=getConfigsWithRegexes(configs);return{initialRoutes,configs,configWithRegexes};}function getInitialRoutes(options){const initialRoutes=[];if(options?.initialRouteName){initialRoutes.push({initialRouteName:options.initialRouteName,parentScreens:[]});}return initialRoutes;}function getSortedNormalizedConfigs(initialRoutes,screens={}){return[].concat(...Object.keys(screens).map(key=>createNormalizedConfigs(key,screens,initialRoutes,[],[],[]))).sort((a,b)=>{if(isArrayEqual(a.segments,b.segments)){return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));}if(arrayStartsWith(a.segments,b.segments)){return-1;}if(arrayStartsWith(b.segments,a.segments)){return 1;}for(let i=0;i<Math.max(a.segments.length,b.segments.length);i++){if(a.segments[i]==null){return 1;}if(b.segments[i]==null){return-1;}const aWildCard=a.segments[i]==='*';const bWildCard=b.segments[i]==='*';const aParam=a.segments[i].startsWith(':');const bParam=b.segments[i].startsWith(':');const aRegex=aParam&&a.segments[i].includes('(');const bRegex=bParam&&b.segments[i].includes('(');if(aWildCard&&bWildCard||aRegex&&bRegex){continue;}if(aWildCard&&!bWildCard){return 1;}if(bWildCard&&!aWildCard){return-1;}if(aParam&&!bParam){return 1;}if(bParam&&!aParam){return-1;}if(aRegex&&!bRegex){return-1;}if(bRegex&&!aRegex){return 1;}}return a.segments.length-b.segments.length;});}function checkForDuplicatedConfigs(configs){configs.reduce((acc,config)=>{const pattern=config.segments.join('/');if(acc[pattern]){const a=acc[pattern].routeNames;const b=config.routeNames;const intersects=a.length>b.length?b.every((it,i)=>a[i]===it):a.every((it,i)=>b[i]===it);if(!intersects){throw new Error(`Found conflicting screens with the same pattern. The pattern '${pattern}' resolves to both '${a.join(' > ')}' and '${b.join(' > ')}'. Patterns must be unique and cannot resolve to more than one screen.`);}}return Object.assign(acc,{[pattern]:config});},{});}function getConfigsWithRegexes(configs){return configs.map(c=>Object.assign({},c,{regex:c.regex?new RegExp(c.regex.source+'$'):undefined}));}const matchAgainstConfigs=(remaining,configs)=>{let routes;let remainingPath=remaining;for(const config of configs){if(!config.regex){continue;}const match=remainingPath.match(config.regex);if(match){routes=config.routeNames.map(routeName=>{const routeConfig=configs.find(c=>{return c.screen===routeName&&arrayStartsWith(config.segments,c.segments);});const params=routeConfig&&match.groups?Object.fromEntries(Object.entries(match.groups).map(([key,value])=>{const index=Number(key.replace('param_',''));const param=routeConfig.params.find(it=>it.index===index);if(param?.screen===routeName&&param?.name){return[param.name,value];}return null;}).filter(it=>it!=null).map(([key,value])=>{if(value==null){return[key,undefined];}const decoded=decodeURIComponent(value);const parsed=routeConfig.parse?.[key]?routeConfig.parse[key](decoded):decoded;return[key,parsed];})):undefined;if(params&&Object.keys(params).length){return{name:routeName,params};}return{name:routeName};});remainingPath=remainingPath.replace(match[0],'');break;}}return{routes,remainingPath};};const createNormalizedConfigs=(screen,routeConfig,initials,paths,parentScreens,routeNames)=>{const configs=[];routeNames.push(screen);parentScreens.push(screen);const config=routeConfig[screen];if(typeof config==='string'){paths.push({screen,path:config});configs.push(createConfigItem(screen,[...routeNames],[...paths]));}else if(typeof config==='object'){if(typeof config.path==='string'){if(config.exact&&config.path==null){throw new Error(`Screen '${screen}' doesn't specify a 'path'. A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. \\`path: ''\\`.`);}const aliasConfigs=[];if(config.alias){for(const alias of config.alias){if(typeof alias==='string'){aliasConfigs.push(createConfigItem(screen,[...routeNames],[...paths,{screen,path:alias}],config.parse));}else if(typeof alias==='object'){aliasConfigs.push(createConfigItem(screen,[...routeNames],alias.exact?[{screen,path:alias.path}]:[...paths,{screen,path:alias.path}],alias.parse));}}}if(config.exact){paths.length=0;}paths.push({screen,path:config.path});configs.push(createConfigItem(screen,[...routeNames],[...paths],config.parse));configs.push(...aliasConfigs);}if(typeof config!=='string'&&typeof config.path!=='string'&&config.alias?.length){throw new Error(`Screen '${screen}' doesn't specify a 'path'. A 'path' needs to be specified in order to use 'alias'.`);}if(config.screens){if(config.initialRouteName){initials.push({initialRouteName:config.initialRouteName,parentScreens});}Object.keys(config.screens).forEach(nestedConfig=>{const result=createNormalizedConfigs(nestedConfig,config.screens,initials,[...paths],[...parentScreens],routeNames);configs.push(...result);});}}routeNames.pop();return configs;};const createConfigItem=(screen,routeNames,paths,parse)=>{const parts=[];for(const{screen,path}of paths){parts.push(...getPatternParts(path).map(part=>Object.assign({},part,{screen})));}const regex=parts.length?new RegExp(`^(${parts.map((it,i)=>{if(it.param){const reg=it.regex||'[^/]+';return`(((?<param_${i}>${reg})\\\\/)${it.optional?'?':''})`;}return`${it.segment==='*'?'.*':escape(it.segment)}\\\\/`;}).join('')})$`):undefined;const segments=parts.map(it=>it.segment);const params=parts.map((it,i)=>it.param?{index:i,screen:it.screen,name:it.param}:null).filter(it=>it!=null);return{screen,regex,segments,params,routeNames,parse};};const findParseConfigForRoute=(routeName,flatConfig)=>{for(const config of flatConfig){if(routeName===config.routeNames[config.routeNames.length-1]){return config.parse;}}return undefined;};const findInitialRoute=(routeName,parentScreens,initialRoutes)=>{for(const config of initialRoutes){if(parentScreens.length===config.parentScreens.length){let sameParents=true;for(let i=0;i<parentScreens.length;i++){if(parentScreens[i].localeCompare(config.parentScreens[i])!==0){sameParents=false;break;}}if(sameParents){return routeName!==config.initialRouteName?config.initialRouteName:undefined;}}}return undefined;};const createStateObject=(initialRoute,route,isEmpty)=>{if(isEmpty){if(initialRoute){return{index:1,routes:[{name:initialRoute},route]};}else{return{routes:[route]};}}else{if(initialRoute){return{index:1,routes:[{name:initialRoute},Object.assign({},route,{state:{routes:[]}})]};}else{return{routes:[Object.assign({},route,{state:{routes:[]}})]};}}};const createNestedStateObject=(path,routes,initialRoutes,flatConfig)=>{let route=routes.shift();const parentScreens=[];let initialRoute=findInitialRoute(route.name,parentScreens,initialRoutes);parentScreens.push(route.name);const state=createStateObject(initialRoute,route,routes.length===0);if(routes.length>0){let nestedState=state;while(route=routes.shift()){initialRoute=findInitialRoute(route.name,parentScreens,initialRoutes);const nestedStateIndex=nestedState.index||nestedState.routes.length-1;nestedState.routes[nestedStateIndex].state=createStateObject(initialRoute,route,routes.length===0);if(routes.length>0){nestedState=nestedState.routes[nestedStateIndex].state;}parentScreens.push(route.name);}}route=findFocusedRoute(state);route.path=path.replace(/\\/$/,'');const params=parseQueryParams(path,flatConfig?findParseConfigForRoute(route.name,flatConfig):undefined);if(params){route.params=Object.assign({},route.params,params);}return state;};const parseQueryParams=(path,parseConfig)=>{const query=path.split('?')[1];const params=queryString.parse(query);if(parseConfig){Object.keys(params).forEach(name=>{if(Object.hasOwnProperty.call(parseConfig,name)&&typeof params[name]==='string'){params[name]=parseConfig[name](params[name]);}});}return Object.keys(params).length?params:undefined;};","map":{"version":3,"names":["escape","queryString","arrayStartsWith","findFocusedRoute","getPatternParts","isArrayEqual","validatePathConfig","getStateFromPath","path","options","initialRoutes","configs","getConfigResources","screens","remaining","replace","endsWith","prefix","normalizedPrefix","startsWith","undefined","routes","split","filter","Boolean","map","segment","name","decodeURIComponent","length","createNestedStateObject","match","find","config","segments","join","routeNames","result","current","remainingPath","matchAgainstConfigs","cachedConfigResources","WeakMap","prepareConfigResources","cached","get","resources","set","getInitialRoutes","getSortedNormalizedConfigs","checkForDuplicatedConfigs","configWithRegexes","getConfigsWithRegexes","initialRouteName","push","parentScreens","concat","Object","keys","key","createNormalizedConfigs","sort","a","b","localeCompare","i","Math","max","aWildCard","bWildCard","aParam","bParam","aRegex","includes","bRegex","reduce","acc","pattern","intersects","every","it","Error","assign","c","regex","RegExp","source","routeName","routeConfig","screen","params","groups","fromEntries","entries","value","index","Number","param","decoded","parsed","parse","initials","paths","createConfigItem","exact","aliasConfigs","alias","forEach","nestedConfig","pop","parts","part","reg","optional","findParseConfigForRoute","flatConfig","findInitialRoute","sameParents","createStateObject","initialRoute","route","isEmpty","state","shift","nestedState","nestedStateIndex","parseQueryParams","parseConfig","query","hasOwnProperty","call"],"sources":["/home/user/rork-vibesync-458/node_modules/@react-navigation/core/src/getStateFromPath.tsx"],"sourcesContent":["import type {\n  InitialState,\n  NavigationState,\n  ParamListBase,\n  PartialState,\n} from '@react-navigation/routers';\nimport escape from 'escape-string-regexp';\nimport * as queryString from 'query-string';\n\nimport { arrayStartsWith } from './arrayStartsWith';\nimport { findFocusedRoute } from './findFocusedRoute';\nimport { getPatternParts, type PatternPart } from './getPatternParts';\nimport { isArrayEqual } from './isArrayEqual';\nimport type { PathConfig, PathConfigMap } from './types';\nimport { validatePathConfig } from './validatePathConfig';\n\ntype Options<ParamList extends {}> = {\n  path?: string;\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n};\n\ntype ParseConfig = Record<string, (value: string) => unknown>;\n\ntype RouteConfig = {\n  screen: string;\n  regex?: RegExp;\n  segments: string[];\n  params: { screen: string; name?: string; index: number }[];\n  routeNames: string[];\n  parse?: ParseConfig;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  parentScreens: string[];\n};\n\ntype ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\ntype ParsedRoute = {\n  name: string;\n  path?: string;\n  params?: Record<string, unknown> | undefined;\n};\n\ntype ConfigResources = {\n  initialRoutes: InitialRouteConfig[];\n  configs: RouteConfig[];\n};\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * @example\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         parse: { id: Number }\n *       }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport function getStateFromPath<ParamList extends {}>(\n  path: string,\n  options?: Options<ParamList>\n): ResultState | undefined {\n  const { initialRoutes, configs } = getConfigResources(options);\n\n  const screens = options?.screens;\n\n  let remaining = path\n    .replace(/\\/+/g, '/') // Replace multiple slash (//) with single ones\n    .replace(/^\\//, '') // Remove extra leading slash\n    .replace(/\\?.*$/, ''); // Remove query params which we will handle later\n\n  // Make sure there is a trailing slash\n  remaining = remaining.endsWith('/') ? remaining : `${remaining}/`;\n\n  const prefix = options?.path?.replace(/^\\//, ''); // Remove extra leading slash\n\n  if (prefix) {\n    // Make sure there is a trailing slash\n    const normalizedPrefix = prefix.endsWith('/') ? prefix : `${prefix}/`;\n\n    // If the path doesn't start with the prefix, it's not a match\n    if (!remaining.startsWith(normalizedPrefix)) {\n      return undefined;\n    }\n\n    // Remove the prefix from the path\n    remaining = remaining.replace(normalizedPrefix, '');\n  }\n\n  if (screens === undefined) {\n    // When no config is specified, use the path segments as route names\n    const routes = remaining\n      .split('/')\n      .filter(Boolean)\n      .map((segment) => {\n        const name = decodeURIComponent(segment);\n        return { name };\n      });\n\n    if (routes.length) {\n      return createNestedStateObject(path, routes, initialRoutes);\n    }\n\n    return undefined;\n  }\n\n  if (remaining === '/') {\n    // We need to add special handling of empty path so navigation to empty path also works\n    // When handling empty path, we should only look at the root level config\n    const match = configs.find((config) => config.segments.join('/') === '');\n\n    if (match) {\n      return createNestedStateObject(\n        path,\n        match.routeNames.map((name) => ({ name })),\n        initialRoutes,\n        configs\n      );\n    }\n\n    return undefined;\n  }\n\n  let result: PartialState<NavigationState> | undefined;\n  let current: PartialState<NavigationState> | undefined;\n\n  // We match the whole path against the regex instead of segments\n  // This makes sure matches such as wildcard will catch any unmatched routes, even if nested\n  const { routes, remainingPath } = matchAgainstConfigs(remaining, configs);\n\n  if (routes !== undefined) {\n    // This will always be empty if full path matched\n    current = createNestedStateObject(path, routes, initialRoutes, configs);\n    remaining = remainingPath;\n    result = current;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  return result;\n}\n\n/**\n * Reference to the last used config resources. This is used to avoid recomputing the config resources when the options are the same.\n */\nconst cachedConfigResources = new WeakMap<Options<{}>, ConfigResources>();\n\nfunction getConfigResources<ParamList extends {}>(\n  options: Options<ParamList> | undefined\n) {\n  if (!options) return prepareConfigResources();\n\n  const cached = cachedConfigResources.get(options);\n\n  if (cached) return cached;\n\n  const resources = prepareConfigResources(options);\n\n  cachedConfigResources.set(options, resources);\n\n  return resources;\n}\n\nfunction prepareConfigResources(options?: Options<{}>) {\n  if (options) {\n    validatePathConfig(options);\n  }\n\n  const initialRoutes = getInitialRoutes(options);\n  const configs = getSortedNormalizedConfigs(initialRoutes, options?.screens);\n\n  checkForDuplicatedConfigs(configs);\n\n  const configWithRegexes = getConfigsWithRegexes(configs);\n\n  return {\n    initialRoutes,\n    configs,\n    configWithRegexes,\n  };\n}\n\nfunction getInitialRoutes(options?: Options<{}>) {\n  const initialRoutes: InitialRouteConfig[] = [];\n\n  if (options?.initialRouteName) {\n    initialRoutes.push({\n      initialRouteName: options.initialRouteName,\n      parentScreens: [],\n    });\n  }\n\n  return initialRoutes;\n}\n\nfunction getSortedNormalizedConfigs(\n  initialRoutes: InitialRouteConfig[],\n  screens: Record<string, string | PathConfig<ParamListBase>> = {}\n) {\n  // Create a normalized configs array which will be easier to use\n  return ([] as RouteConfig[])\n    .concat(\n      ...Object.keys(screens).map((key) =>\n        createNormalizedConfigs(key, screens, initialRoutes, [], [], [])\n      )\n    )\n    .sort((a, b) => {\n      // Sort config from most specific to least specific:\n      // - more segments\n      // - static segments\n      // - params with regex\n      // - regular params\n      // - wildcard\n\n      // If 2 patterns are same, move the one with less route names up\n      // This is an error state, so it's only useful for consistent error messages\n      if (isArrayEqual(a.segments, b.segments)) {\n        return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));\n      }\n\n      // If one of the patterns starts with the other, it's more exhaustive\n      // So move it up\n      if (arrayStartsWith(a.segments, b.segments)) {\n        return -1;\n      }\n\n      if (arrayStartsWith(b.segments, a.segments)) {\n        return 1;\n      }\n\n      for (let i = 0; i < Math.max(a.segments.length, b.segments.length); i++) {\n        // if b is longer, b gets higher priority\n        if (a.segments[i] == null) {\n          return 1;\n        }\n\n        // if a is longer, a gets higher priority\n        if (b.segments[i] == null) {\n          return -1;\n        }\n\n        const aWildCard = a.segments[i] === '*';\n        const bWildCard = b.segments[i] === '*';\n        const aParam = a.segments[i].startsWith(':');\n        const bParam = b.segments[i].startsWith(':');\n        const aRegex = aParam && a.segments[i].includes('(');\n        const bRegex = bParam && b.segments[i].includes('(');\n\n        // if both are wildcard or regex, we compare next component\n        if ((aWildCard && bWildCard) || (aRegex && bRegex)) {\n          continue;\n        }\n\n        // if only a is wildcard, b gets higher priority\n        if (aWildCard && !bWildCard) {\n          return 1;\n        }\n\n        // if only b is wildcard, a gets higher priority\n        if (bWildCard && !aWildCard) {\n          return -1;\n        }\n\n        // If only a has a param, b gets higher priority\n        if (aParam && !bParam) {\n          return 1;\n        }\n\n        // If only b has a param, a gets higher priority\n        if (bParam && !aParam) {\n          return -1;\n        }\n\n        // if only a has regex, a gets higher priority\n        if (aRegex && !bRegex) {\n          return -1;\n        }\n\n        // if only b has regex, b gets higher priority\n        if (bRegex && !aRegex) {\n          return 1;\n        }\n      }\n\n      return a.segments.length - b.segments.length;\n    });\n}\n\nfunction checkForDuplicatedConfigs(configs: RouteConfig[]) {\n  // Check for duplicate patterns in the config\n  configs.reduce<Record<string, RouteConfig>>((acc, config) => {\n    const pattern = config.segments.join('/');\n\n    if (acc[pattern]) {\n      const a = acc[pattern].routeNames;\n      const b = config.routeNames;\n\n      // It's not a problem if the path string omitted from a inner most screen\n      // For example, it's ok if a path resolves to `A > B > C` or `A > B`\n      const intersects =\n        a.length > b.length\n          ? b.every((it, i) => a[i] === it)\n          : a.every((it, i) => b[i] === it);\n\n      if (!intersects) {\n        throw new Error(\n          `Found conflicting screens with the same pattern. The pattern '${\n            pattern\n          }' resolves to both '${a.join(' > ')}' and '${b.join(\n            ' > '\n          )}'. Patterns must be unique and cannot resolve to more than one screen.`\n        );\n      }\n    }\n\n    return Object.assign(acc, {\n      [pattern]: config,\n    });\n  }, {});\n}\n\nfunction getConfigsWithRegexes(configs: RouteConfig[]) {\n  return configs.map((c) => ({\n    ...c,\n    // Add `$` to the regex to make sure it matches till end of the path and not just beginning\n    regex: c.regex ? new RegExp(c.regex.source + '$') : undefined,\n  }));\n}\n\nconst matchAgainstConfigs = (remaining: string, configs: RouteConfig[]) => {\n  let routes: ParsedRoute[] | undefined;\n  let remainingPath = remaining;\n\n  // Go through all configs, and see if the next path segment matches our regex\n  for (const config of configs) {\n    if (!config.regex) {\n      continue;\n    }\n\n    const match = remainingPath.match(config.regex);\n\n    // If our regex matches, we need to extract params from the path\n    if (match) {\n      routes = config.routeNames.map((routeName) => {\n        const routeConfig = configs.find((c) => {\n          // Check matching name AND pattern in case same screen is used at different levels in config\n          return (\n            c.screen === routeName &&\n            arrayStartsWith(config.segments, c.segments)\n          );\n        });\n\n        const params =\n          routeConfig && match.groups\n            ? Object.fromEntries(\n                Object.entries(match.groups)\n                  .map(([key, value]) => {\n                    const index = Number(key.replace('param_', ''));\n                    const param = routeConfig.params.find(\n                      (it) => it.index === index\n                    );\n\n                    if (param?.screen === routeName && param?.name) {\n                      return [param.name, value];\n                    }\n\n                    return null;\n                  })\n                  .filter((it) => it != null)\n                  .map(([key, value]) => {\n                    if (value == null) {\n                      return [key, undefined];\n                    }\n\n                    const decoded = decodeURIComponent(value);\n                    const parsed = routeConfig.parse?.[key]\n                      ? routeConfig.parse[key](decoded)\n                      : decoded;\n\n                    return [key, parsed];\n                  })\n              )\n            : undefined;\n\n        if (params && Object.keys(params).length) {\n          return { name: routeName, params };\n        }\n\n        return { name: routeName };\n      });\n\n      remainingPath = remainingPath.replace(match[0], '');\n\n      break;\n    }\n  }\n\n  return { routes, remainingPath };\n};\n\nconst createNormalizedConfigs = (\n  screen: string,\n  routeConfig: Record<string, string | PathConfig<ParamListBase>>,\n  initials: InitialRouteConfig[],\n  paths: { screen: string; path: string }[],\n  parentScreens: string[],\n  routeNames: string[]\n): RouteConfig[] => {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(screen);\n\n  parentScreens.push(screen);\n\n  const config = routeConfig[screen];\n\n  if (typeof config === 'string') {\n    paths.push({ screen, path: config });\n    configs.push(createConfigItem(screen, [...routeNames], [...paths]));\n  } else if (typeof config === 'object') {\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (typeof config.path === 'string') {\n      if (config.exact && config.path == null) {\n        throw new Error(\n          `Screen '${screen}' doesn't specify a 'path'. A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. \\`path: ''\\`.`\n        );\n      }\n\n      // We should add alias configs after the main config\n      // So unless they are more specific, main config will be matched first\n      const aliasConfigs = [];\n\n      if (config.alias) {\n        for (const alias of config.alias) {\n          if (typeof alias === 'string') {\n            aliasConfigs.push(\n              createConfigItem(\n                screen,\n                [...routeNames],\n                [...paths, { screen, path: alias }],\n                config.parse\n              )\n            );\n          } else if (typeof alias === 'object') {\n            aliasConfigs.push(\n              createConfigItem(\n                screen,\n                [...routeNames],\n                alias.exact\n                  ? [{ screen, path: alias.path }]\n                  : [...paths, { screen, path: alias.path }],\n                alias.parse\n              )\n            );\n          }\n        }\n      }\n\n      if (config.exact) {\n        // If it's an exact path, we don't need to keep track of the parent screens\n        // So we can clear it\n        paths.length = 0;\n      }\n\n      paths.push({ screen, path: config.path });\n      configs.push(\n        createConfigItem(screen, [...routeNames], [...paths], config.parse)\n      );\n\n      configs.push(...aliasConfigs);\n    }\n\n    if (\n      typeof config !== 'string' &&\n      typeof config.path !== 'string' &&\n      config.alias?.length\n    ) {\n      throw new Error(\n        `Screen '${screen}' doesn't specify a 'path'. A 'path' needs to be specified in order to use 'alias'.`\n      );\n    }\n\n    if (config.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (config.initialRouteName) {\n        initials.push({\n          initialRouteName: config.initialRouteName,\n          parentScreens,\n        });\n      }\n\n      Object.keys(config.screens).forEach((nestedConfig) => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          config.screens as Record<string, string | PathConfig<ParamListBase>>,\n          initials,\n          [...paths],\n          [...parentScreens],\n          routeNames\n        );\n\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n};\n\nconst createConfigItem = (\n  screen: string,\n  routeNames: string[],\n  paths: { screen: string; path: string }[],\n  parse?: ParseConfig\n): RouteConfig => {\n  const parts: (PatternPart & { screen: string })[] = [];\n\n  // Parse the path string into parts for easier matching\n  for (const { screen, path } of paths) {\n    parts.push(...getPatternParts(path).map((part) => ({ ...part, screen })));\n  }\n\n  const regex = parts.length\n    ? new RegExp(\n        `^(${parts\n          .map((it, i) => {\n            if (it.param) {\n              const reg = it.regex || '[^/]+';\n\n              return `(((?<param_${i}>${reg})\\\\/)${it.optional ? '?' : ''})`;\n            }\n\n            return `${it.segment === '*' ? '.*' : escape(it.segment)}\\\\/`;\n          })\n          .join('')})$`\n      )\n    : undefined;\n\n  const segments = parts.map((it) => it.segment);\n  const params = parts\n    .map((it, i) =>\n      it.param\n        ? {\n            index: i,\n            screen: it.screen,\n            name: it.param,\n          }\n        : null\n    )\n    .filter((it) => it != null);\n\n  return {\n    screen,\n    regex,\n    segments,\n    params,\n    routeNames,\n    parse,\n  };\n};\n\nconst findParseConfigForRoute = (\n  routeName: string,\n  flatConfig: RouteConfig[]\n): ParseConfig | undefined => {\n  for (const config of flatConfig) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n\n  return undefined;\n};\n\n// Try to find an initial route connected with the one passed\nconst findInitialRoute = (\n  routeName: string,\n  parentScreens: string[],\n  initialRoutes: InitialRouteConfig[]\n): string | undefined => {\n  for (const config of initialRoutes) {\n    if (parentScreens.length === config.parentScreens.length) {\n      let sameParents = true;\n      for (let i = 0; i < parentScreens.length; i++) {\n        if (parentScreens[i].localeCompare(config.parentScreens[i]) !== 0) {\n          sameParents = false;\n          break;\n        }\n      }\n      if (sameParents) {\n        return routeName !== config.initialRouteName\n          ? config.initialRouteName\n          : undefined;\n      }\n    }\n  }\n  return undefined;\n};\n\n// returns state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nconst createStateObject = (\n  initialRoute: string | undefined,\n  route: ParsedRoute,\n  isEmpty: boolean\n): InitialState => {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{ name: initialRoute }, route],\n      };\n    } else {\n      return {\n        routes: [route],\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{ name: initialRoute }, { ...route, state: { routes: [] } }],\n      };\n    } else {\n      return {\n        routes: [{ ...route, state: { routes: [] } }],\n      };\n    }\n  }\n};\n\nconst createNestedStateObject = (\n  path: string,\n  routes: ParsedRoute[],\n  initialRoutes: InitialRouteConfig[],\n  flatConfig?: RouteConfig[]\n) => {\n  let route = routes.shift() as ParsedRoute;\n  const parentScreens: string[] = [];\n\n  let initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n  parentScreens.push(route.name);\n\n  const state: InitialState = createStateObject(\n    initialRoute,\n    route,\n    routes.length === 0\n  );\n\n  if (routes.length > 0) {\n    let nestedState = state;\n\n    while ((route = routes.shift() as ParsedRoute)) {\n      initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n      const nestedStateIndex =\n        nestedState.index || nestedState.routes.length - 1;\n\n      nestedState.routes[nestedStateIndex].state = createStateObject(\n        initialRoute,\n        route,\n        routes.length === 0\n      );\n\n      if (routes.length > 0) {\n        nestedState = nestedState.routes[nestedStateIndex]\n          .state as InitialState;\n      }\n\n      parentScreens.push(route.name);\n    }\n  }\n\n  route = findFocusedRoute(state) as ParsedRoute;\n  route.path = path.replace(/\\/$/, '');\n\n  const params = parseQueryParams(\n    path,\n    flatConfig ? findParseConfigForRoute(route.name, flatConfig) : undefined\n  );\n\n  if (params) {\n    route.params = { ...route.params, ...params };\n  }\n\n  return state;\n};\n\nconst parseQueryParams = (\n  path: string,\n  parseConfig?: Record<string, (value: string) => unknown>\n) => {\n  const query = path.split('?')[1];\n  const params: Record<string, unknown> = queryString.parse(query);\n\n  if (parseConfig) {\n    Object.keys(params).forEach((name) => {\n      if (\n        Object.hasOwnProperty.call(parseConfig, name) &&\n        typeof params[name] === 'string'\n      ) {\n        params[name] = parseConfig[name](params[name]);\n      }\n    });\n  }\n\n  return Object.keys(params).length ? params : undefined;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}