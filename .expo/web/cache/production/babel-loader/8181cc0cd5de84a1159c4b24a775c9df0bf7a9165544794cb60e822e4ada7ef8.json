{"ast":null,"code":"import*as React from'react';import*as Utils from'./WebCameraUtils';import{FacingModeToCameraType}from'./WebConstants';const VALID_SETTINGS_KEYS=['autoFocus','flashMode','exposureCompensation','colorTemperature','iso','brightness','contrast','saturation','sharpness','focusDistance','whiteBalance','zoom'];function useLoadedVideo(video,onLoaded){React.useEffect(()=>{if(video){video.addEventListener('loadedmetadata',()=>{requestAnimationFrame(()=>{onLoaded();});});}},[video]);}export function useWebCameraStream(video,preferredType,settings,{onCameraReady,onMountError}){const isStartingCamera=React.useRef(false);const activeStreams=React.useRef([]);const capabilities=React.useRef({autoFocus:'continuous',flashMode:'off',whiteBalance:'continuous',zoom:1});const[stream,setStream]=React.useState(null);const mediaTrackSettings=React.useMemo(()=>{return stream?stream.getTracks()[0].getSettings():null;},[stream]);const type=React.useMemo(()=>{if(!mediaTrackSettings){return null;}const{facingMode='user'}=mediaTrackSettings;return FacingModeToCameraType[facingMode];},[mediaTrackSettings]);const getStreamDeviceAsync=React.useCallback(async()=>{try{return await Utils.getPreferredStreamDevice(preferredType);}catch(nativeEvent){if(false){console.warn(`Error requesting UserMedia for type \"${preferredType}\":`,nativeEvent);}if(onMountError){onMountError({nativeEvent});}return null;}},[preferredType,onMountError]);const resumeAsync=React.useCallback(async()=>{const nextStream=await getStreamDeviceAsync();if(Utils.compareStreams(nextStream,stream)){return false;}if(!activeStreams.current.some(value=>value.id===nextStream?.id)){activeStreams.current.push(nextStream);}setStream(nextStream);if(onCameraReady){onCameraReady();}return false;},[getStreamDeviceAsync,setStream,onCameraReady,stream,activeStreams.current]);React.useEffect(()=>{if(isStartingCamera.current){return;}isStartingCamera.current=true;resumeAsync().then(isStarting=>{isStartingCamera.current=isStarting;}).catch(()=>{isStartingCamera.current=false;});},[preferredType]);React.useEffect(()=>{const changes={};for(const key of VALID_SETTINGS_KEYS){if(key in settings){const nextValue=settings[key];if(nextValue!==capabilities.current[key]){changes[key]=nextValue;}}}const hasChanges=!!Object.keys(changes).length;const nextWebCameraSettings=Object.assign({},capabilities.current,changes);if(hasChanges){Utils.syncTrackCapabilities(preferredType,stream,changes);}capabilities.current=nextWebCameraSettings;},[settings.autoFocus,settings.flashMode,settings.exposureCompensation,settings.colorTemperature,settings.iso,settings.brightness,settings.contrast,settings.saturation,settings.sharpness,settings.focusDistance,settings.whiteBalance,settings.zoom]);React.useEffect(()=>{if(!video.current){return;}Utils.setVideoSource(video.current,stream);},[video.current,stream]);React.useEffect(()=>{return()=>{for(const stream of activeStreams.current){Utils.stopMediaStream(stream);}if(video.current){Utils.setVideoSource(video.current,stream);}};},[]);useLoadedVideo(video.current,()=>{Utils.syncTrackCapabilities(preferredType,stream,capabilities.current);});return{type,mediaTrackSettings};}","map":{"version":3,"names":["React","Utils","FacingModeToCameraType","VALID_SETTINGS_KEYS","useLoadedVideo","video","onLoaded","useEffect","addEventListener","requestAnimationFrame","useWebCameraStream","preferredType","settings","onCameraReady","onMountError","isStartingCamera","useRef","activeStreams","capabilities","autoFocus","flashMode","whiteBalance","zoom","stream","setStream","useState","mediaTrackSettings","useMemo","getTracks","getSettings","type","facingMode","getStreamDeviceAsync","useCallback","getPreferredStreamDevice","nativeEvent","console","warn","resumeAsync","nextStream","compareStreams","current","some","value","id","push","then","isStarting","catch","changes","key","nextValue","hasChanges","Object","keys","length","nextWebCameraSettings","assign","syncTrackCapabilities","exposureCompensation","colorTemperature","iso","brightness","contrast","saturation","sharpness","focusDistance","setVideoSource","stopMediaStream"],"sources":["/home/user/rork-vibesync-458/node_modules/expo-camera/src/web/useWebCameraStream.ts"],"sourcesContent":["/* eslint-env browser */\nimport * as React from 'react';\n\nimport * as Utils from './WebCameraUtils';\nimport { FacingModeToCameraType } from './WebConstants';\nimport {\n  CameraReadyListener,\n  CameraType,\n  MountErrorListener,\n  WebCameraSettings,\n} from '../Camera.types';\n\nconst VALID_SETTINGS_KEYS = [\n  'autoFocus',\n  'flashMode',\n  'exposureCompensation',\n  'colorTemperature',\n  'iso',\n  'brightness',\n  'contrast',\n  'saturation',\n  'sharpness',\n  'focusDistance',\n  'whiteBalance',\n  'zoom',\n] as const;\n\nfunction useLoadedVideo(video: HTMLVideoElement | null, onLoaded: () => void) {\n  React.useEffect(() => {\n    if (video) {\n      video.addEventListener('loadedmetadata', () => {\n        // without this async block the constraints aren't properly applied to the camera,\n        // this means that if you were to turn on the torch and swap to the front camera,\n        // then swap back to the rear camera the torch setting wouldn't be applied.\n        requestAnimationFrame(() => {\n          onLoaded();\n        });\n      });\n    }\n  }, [video]);\n}\n\nexport function useWebCameraStream(\n  video: React.MutableRefObject<HTMLVideoElement | null>,\n  preferredType: CameraType,\n  settings: Record<string, any>,\n  {\n    onCameraReady,\n    onMountError,\n  }: { onCameraReady?: CameraReadyListener; onMountError?: MountErrorListener }\n): {\n  type: CameraType | null;\n  mediaTrackSettings: MediaTrackSettings | null;\n} {\n  const isStartingCamera = React.useRef<boolean | null>(false);\n  const activeStreams = React.useRef<MediaStream[]>([]);\n  const capabilities = React.useRef<WebCameraSettings>({\n    autoFocus: 'continuous',\n    flashMode: 'off',\n    whiteBalance: 'continuous',\n    zoom: 1,\n  });\n  const [stream, setStream] = React.useState<MediaStream | null>(null);\n\n  const mediaTrackSettings = React.useMemo(() => {\n    return stream ? stream.getTracks()[0].getSettings() : null;\n  }, [stream]);\n\n  // The actual camera type - this can be different from the incoming camera type.\n  const type = React.useMemo(() => {\n    if (!mediaTrackSettings) {\n      return null;\n    }\n    // On desktop no value will be returned, in this case we should assume the cameraType is 'front'\n    const { facingMode = 'user' } = mediaTrackSettings;\n    return FacingModeToCameraType[facingMode];\n  }, [mediaTrackSettings]);\n\n  const getStreamDeviceAsync = React.useCallback(async (): Promise<MediaStream | null> => {\n    try {\n      return await Utils.getPreferredStreamDevice(preferredType);\n    } catch (nativeEvent: any) {\n      if (__DEV__) {\n        console.warn(`Error requesting UserMedia for type \"${preferredType}\":`, nativeEvent);\n      }\n      if (onMountError) {\n        onMountError({ nativeEvent });\n      }\n      return null;\n    }\n  }, [preferredType, onMountError]);\n\n  const resumeAsync = React.useCallback(async (): Promise<boolean> => {\n    const nextStream = await getStreamDeviceAsync();\n    if (Utils.compareStreams(nextStream, stream)) {\n      // Do nothing if the streams are the same.\n      // This happens when the device only supports one camera (i.e. desktop) and the mode was toggled between front/back while already active.\n      // Without this check there is a screen flash while the video switches.\n      return false;\n    }\n\n    // Save a history of all active streams (usually 2+) so we can close them later.\n    // Keeping them open makes swapping camera types much faster.\n    if (!activeStreams.current.some((value) => value.id === nextStream?.id)) {\n      activeStreams.current.push(nextStream!);\n    }\n\n    // Set the new stream -> update the video, settings, and actual camera type.\n    setStream(nextStream);\n    if (onCameraReady) {\n      onCameraReady();\n    }\n    return false;\n  }, [getStreamDeviceAsync, setStream, onCameraReady, stream, activeStreams.current]);\n\n  React.useEffect(() => {\n    // Restart the camera and guard concurrent actions.\n    if (isStartingCamera.current) {\n      return;\n    }\n    isStartingCamera.current = true;\n\n    resumeAsync()\n      .then((isStarting) => {\n        isStartingCamera.current = isStarting;\n      })\n      .catch(() => {\n        // ensure the camera can be started again.\n        isStartingCamera.current = false;\n      });\n  }, [preferredType]);\n\n  // Update the native camera with any custom capabilities.\n  React.useEffect(() => {\n    const changes: WebCameraSettings = {};\n\n    for (const key of VALID_SETTINGS_KEYS) {\n      if (key in settings) {\n        const nextValue = settings[key];\n        if (nextValue !== capabilities.current[key]) {\n          changes[key] = nextValue;\n        }\n      }\n    }\n\n    // Only update the native camera if changes were found\n    const hasChanges = !!Object.keys(changes).length;\n\n    const nextWebCameraSettings = { ...capabilities.current, ...changes };\n    if (hasChanges) {\n      Utils.syncTrackCapabilities(preferredType, stream, changes);\n    }\n\n    capabilities.current = nextWebCameraSettings;\n  }, [\n    settings.autoFocus,\n    settings.flashMode,\n    settings.exposureCompensation,\n    settings.colorTemperature,\n    settings.iso,\n    settings.brightness,\n    settings.contrast,\n    settings.saturation,\n    settings.sharpness,\n    settings.focusDistance,\n    settings.whiteBalance,\n    settings.zoom,\n  ]);\n\n  React.useEffect(() => {\n    // set or unset the video source.\n    if (!video.current) {\n      return;\n    }\n    Utils.setVideoSource(video.current, stream);\n  }, [video.current, stream]);\n\n  React.useEffect(() => {\n    return () => {\n      // Clean up on dismount, this is important for making sure the camera light goes off when the component is removed.\n      for (const stream of activeStreams.current) {\n        // Close all open streams.\n        Utils.stopMediaStream(stream);\n      }\n      if (video.current) {\n        // Invalidate the video source.\n        Utils.setVideoSource(video.current, stream);\n      }\n    };\n  }, []);\n\n  // Update props when the video loads.\n  useLoadedVideo(video.current, () => {\n    Utils.syncTrackCapabilities(preferredType, stream, capabilities.current);\n  });\n\n  return {\n    type,\n    mediaTrackSettings,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}