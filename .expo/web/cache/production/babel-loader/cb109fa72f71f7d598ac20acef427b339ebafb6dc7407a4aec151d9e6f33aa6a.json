{"ast":null,"code":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.parseRouteSegments=parseRouteSegments;exports.getReactNavigationScreensConfig=getReactNavigationScreensConfig;exports.getReactNavigationConfig=getReactNavigationConfig;const matchers_1=require(\"./matchers\");function convertDynamicRouteToReactNavigation(segment){if(segment==='index'){return'';}if(segment==='+not-found'){return'*not-found';}const rest=(0,matchers_1.matchDeepDynamicRouteName)(segment);if(rest!=null){return'*'+rest;}const dynamicName=(0,matchers_1.matchDynamicName)(segment);if(dynamicName!=null){return`:${dynamicName}`;}return segment;}function parseRouteSegments(segments){return(segments.split('/').map(convertDynamicRouteToReactNavigation).filter(Boolean).join('/'));}function convertRouteNodeToScreen(node,metaOnly){const path=parseRouteSegments(node.route);if(!node.children.length){if(!metaOnly){return{path,screens:{},_route:node};}return path;}const screens=getReactNavigationScreensConfig(node.children,metaOnly);const screen={path,screens};if(node.initialRouteName){screen.initialRouteName=node.initialRouteName;}if(!metaOnly){screen._route=node;}return screen;}function getReactNavigationScreensConfig(nodes,metaOnly){return Object.fromEntries(nodes.map(node=>[node.route,convertRouteNodeToScreen(node,metaOnly)]));}function getReactNavigationConfig(routes,metaOnly){const config={initialRouteName:undefined,screens:getReactNavigationScreensConfig(routes.children,metaOnly)};if(routes.initialRouteName){config.initialRouteName=routes.initialRouteName;}return config;}","map":{"version":3,"names":["exports","parseRouteSegments","getReactNavigationScreensConfig","getReactNavigationConfig","matchers_1","require","convertDynamicRouteToReactNavigation","segment","rest","matchDeepDynamicRouteName","dynamicName","matchDynamicName","segments","split","map","filter","Boolean","join","convertRouteNodeToScreen","node","metaOnly","path","route","children","length","screens","_route","screen","initialRouteName","nodes","Object","fromEntries","routes","config","undefined"],"sources":["/home/user/rork-vibesync-458/node_modules/expo-router/src/getReactNavigationConfig.ts"],"sourcesContent":["import type { RouteNode } from './Route';\nimport { matchDeepDynamicRouteName, matchDynamicName } from './matchers';\n\nexport type Screen =\n  | string\n  | {\n      path: string;\n      screens: Record<string, Screen>;\n      _route?: RouteNode;\n      initialRouteName?: string;\n    };\n\n// `[page]` -> `:page`\n// `page` -> `page`\nfunction convertDynamicRouteToReactNavigation(segment: string): string {\n  // NOTE(EvanBacon): To support shared routes we preserve group segments.\n  if (segment === 'index') {\n    return '';\n  }\n  if (segment === '+not-found') {\n    return '*not-found';\n  }\n\n  const rest = matchDeepDynamicRouteName(segment);\n  if (rest != null) {\n    return '*' + rest;\n  }\n  const dynamicName = matchDynamicName(segment);\n\n  if (dynamicName != null) {\n    return `:${dynamicName}`;\n  }\n\n  return segment;\n}\n\nexport function parseRouteSegments(segments: string): string {\n  return (\n    // NOTE(EvanBacon): When there are nested routes without layouts\n    // the node.route will be something like `app/home/index`\n    // this needs to be split to ensure each segment is parsed correctly.\n    segments\n      .split('/')\n      // Convert each segment to a React Navigation format.\n      .map(convertDynamicRouteToReactNavigation)\n      // Remove any empty paths from groups or index routes.\n      .filter(Boolean)\n      // Join to return as a path.\n      .join('/')\n  );\n}\n\nfunction convertRouteNodeToScreen(node: RouteNode, metaOnly: boolean): Screen {\n  const path = parseRouteSegments(node.route);\n  if (!node.children.length) {\n    if (!metaOnly) {\n      return {\n        path,\n        screens: {},\n        _route: node,\n      };\n    }\n    return path;\n  }\n  const screens = getReactNavigationScreensConfig(node.children, metaOnly);\n\n  const screen: Screen = {\n    path,\n    screens,\n  };\n\n  if (node.initialRouteName) {\n    // NOTE(EvanBacon): This is bad because it forces all Layout Routes\n    // to be loaded into memory. We should move towards a system where\n    // the initial route name is either loaded asynchronously in the Layout Route\n    // or defined via a file system convention.\n    screen.initialRouteName = node.initialRouteName;\n  }\n\n  if (!metaOnly) {\n    screen._route = node;\n  }\n\n  return screen;\n}\n\nexport function getReactNavigationScreensConfig(\n  nodes: RouteNode[],\n  metaOnly: boolean\n): Record<string, Screen> {\n  return Object.fromEntries(\n    nodes.map((node) => [node.route, convertRouteNodeToScreen(node, metaOnly)] as const)\n  );\n}\n\nexport function getReactNavigationConfig(routes: RouteNode, metaOnly: boolean) {\n  const config = {\n    initialRouteName: undefined,\n    screens: getReactNavigationScreensConfig(routes.children, metaOnly),\n  };\n\n  if (routes.initialRouteName) {\n    // We're using LinkingOptions the generic type is `object` instead of a proper ParamList.\n    // So we need to cast the initialRouteName to `any` to avoid type errors.\n    config.initialRouteName = routes.initialRouteName as any;\n  }\n  return config;\n}\n"],"mappings":"sEAoCAA,OAAA,CAAAC,kBAAA,CAAAA,kBAAA,CAkDAD,OAAA,CAAAE,+BAAA,CAAAA,+BAAA,CASAF,OAAA,CAAAG,wBAAA,CAAAA,wBAAA,CA9FA,MAAAC,UAAA,CAAAC,OAAA,eAaA,QAAS,CAAAC,oCAAoCA,CAACC,OAAe,EAE3D,GAAIA,OAAO,GAAK,OAAO,CAAE,CACvB,MAAO,EAAE,CACX,CACA,GAAIA,OAAO,GAAK,YAAY,CAAE,CAC5B,MAAO,YAAY,CACrB,CAEA,KAAM,CAAAC,IAAI,CAAG,GAAAJ,UAAA,CAAAK,yBAAyB,EAACF,OAAO,CAAC,CAC/C,GAAIC,IAAI,EAAI,IAAI,CAAE,CAChB,MAAO,GAAG,CAAGA,IAAI,CACnB,CACA,KAAM,CAAAE,WAAW,CAAG,GAAAN,UAAA,CAAAO,gBAAgB,EAACJ,OAAO,CAAC,CAE7C,GAAIG,WAAW,EAAI,IAAI,CAAE,CACvB,MAAO,IAAIA,WAAW,EAAE,CAC1B,CAEA,MAAO,CAAAH,OAAO,CAChB,CAEA,QAAgB,CAAAN,kBAAkBA,CAACW,QAAgB,EACjD,OAIEA,QAAQ,CACLC,KAAK,CAAC,GAAG,CAAC,CAEVC,GAAG,CAACR,oCAAoC,CAAC,CAEzCS,MAAM,CAACC,OAAO,CAAC,CAEfC,IAAI,CAAC,GAAG,CAAC,EAEhB,CAEA,QAAS,CAAAC,wBAAwBA,CAACC,IAAe,CAAEC,QAAiB,EAClE,KAAM,CAAAC,IAAI,CAAGpB,kBAAkB,CAACkB,IAAI,CAACG,KAAK,CAAC,CAC3C,GAAI,CAACH,IAAI,CAACI,QAAQ,CAACC,MAAM,CAAE,CACzB,GAAI,CAACJ,QAAQ,CAAE,CACb,MAAO,CACLC,IAAI,CACJI,OAAO,CAAE,EAAE,CACXC,MAAM,CAAEP,I,CACT,CACH,CACA,MAAO,CAAAE,IAAI,CACb,CACA,KAAM,CAAAI,OAAO,CAAGvB,+BAA+B,CAACiB,IAAI,CAACI,QAAQ,CAAEH,QAAQ,CAAC,CAExE,KAAM,CAAAO,MAAM,CAAW,CACrBN,IAAI,CACJI,O,CACD,CAED,GAAIN,IAAI,CAACS,gBAAgB,CAAE,CAKzBD,MAAM,CAACC,gBAAgB,CAAGT,IAAI,CAACS,gBAAgB,CACjD,CAEA,GAAI,CAACR,QAAQ,CAAE,CACbO,MAAM,CAACD,MAAM,CAAGP,IAAI,CACtB,CAEA,MAAO,CAAAQ,MAAM,CACf,CAEA,QAAgB,CAAAzB,+BAA+BA,CAC7C2B,KAAkB,CAClBT,QAAiB,EAEjB,MAAO,CAAAU,MAAM,CAACC,WAAW,CACvBF,KAAK,CAACf,GAAG,CAAEK,IAAI,EAAK,CAACA,IAAI,CAACG,KAAK,CAAEJ,wBAAwB,CAACC,IAAI,CAAEC,QAAQ,CAAC,CAAU,CAAC,CACrF,CACH,CAEA,QAAgB,CAAAjB,wBAAwBA,CAAC6B,MAAiB,CAAEZ,QAAiB,EAC3E,KAAM,CAAAa,MAAM,CAAG,CACbL,gBAAgB,CAAEM,SAAS,CAC3BT,OAAO,CAAEvB,+BAA+B,CAAC8B,MAAM,CAACT,QAAQ,CAAEH,QAAQ,C,CACnE,CAED,GAAIY,MAAM,CAACJ,gBAAgB,CAAE,CAG3BK,MAAM,CAACL,gBAAgB,CAAGI,MAAM,CAACJ,gBAAuB,CAC1D,CACA,MAAO,CAAAK,MAAM,CACf","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}