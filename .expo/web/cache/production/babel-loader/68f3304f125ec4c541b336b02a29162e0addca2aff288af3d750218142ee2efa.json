{"ast":null,"code":"import{Platform}from'expo-modules-core';import PixelRatio from\"react-native-web/dist/exports/PixelRatio\";import NativeModules from\"react-native-web/dist/exports/NativeModules\";import AssetSourceResolver from'./AssetSourceResolver';import{getManifest2,manifestBaseUrl}from'./PlatformUtils';export function selectAssetSource(meta){const scale=AssetSourceResolver.pickScale(meta.scales,PixelRatio.get());const index=meta.scales.findIndex(s=>s===scale);const hash=meta.fileHashes?meta.fileHashes[index]??meta.fileHashes[0]:meta.hash;const uri=meta.fileUris?meta.fileUris[index]??meta.fileUris[0]:meta.uri;if(uri){return{uri:resolveUri(uri),hash};}const fileScale=scale===1?'':`@${scale}x`;const fileExtension=meta.type?`.${encodeURIComponent(meta.type)}`:'';const suffix=`/${encodeURIComponent(meta.name)}${fileScale}${fileExtension}`;const params=new URLSearchParams({platform:\"web\",hash:meta.hash});if(/^https?:\\/\\//.test(meta.httpServerLocation)){const uri=meta.httpServerLocation+suffix+'?'+params;return{uri,hash};}const manifest2=getManifest2();const devServerUrl=manifest2?.extra?.expoGo?.developer?'http://'+manifest2.extra.expoGo.debuggerHost:null;if(devServerUrl){const baseUrl=new URL(meta.httpServerLocation+suffix,devServerUrl);baseUrl.searchParams.set('platform',\"web\");baseUrl.searchParams.set('hash',meta.hash);return{uri:baseUrl.href,hash};}if(NativeModules['ExponentKernel']){return{uri:`https://classic-assets.eascdn.net/~assets/${encodeURIComponent(hash)}`,hash};}return{uri:'',hash};}export function resolveUri(uri){return manifestBaseUrl?new URL(uri,manifestBaseUrl).href:uri;}","map":{"version":3,"names":["Platform","PixelRatio","NativeModules","AssetSourceResolver","getManifest2","manifestBaseUrl","selectAssetSource","meta","scale","pickScale","scales","get","index","findIndex","s","hash","fileHashes","uri","fileUris","resolveUri","fileScale","fileExtension","type","encodeURIComponent","suffix","name","params","URLSearchParams","platform","test","httpServerLocation","manifest2","devServerUrl","extra","expoGo","developer","debuggerHost","baseUrl","URL","searchParams","set","href"],"sources":["/home/user/rork-vibesync-458/node_modules/expo-asset/src/AssetSources.ts"],"sourcesContent":["import type { PackagerAsset } from '@react-native/assets-registry/registry';\nimport { Platform } from 'expo-modules-core';\nimport { PixelRatio, NativeModules } from 'react-native';\n\nimport AssetSourceResolver from './AssetSourceResolver';\nimport { getManifest2, manifestBaseUrl } from './PlatformUtils';\n\n// @docsMissing\nexport type AssetMetadata = Pick<\n  PackagerAsset,\n  'httpServerLocation' | 'name' | 'hash' | 'type' | 'scales' | 'width' | 'height'\n> & {\n  uri?: string;\n  fileHashes?: string[];\n  fileUris?: string[];\n};\n\nexport type AssetSource = {\n  uri: string;\n  hash: string;\n};\n\n/**\n * Selects the best file for the given asset (ex: choosing the best scale for images) and returns\n * a { uri, hash } pair for the specific asset file.\n *\n * If the asset isn't an image with multiple scales, the first file is selected.\n */\nexport function selectAssetSource(meta: AssetMetadata): AssetSource {\n  // This logic is based on that of AssetSourceResolver, with additional support for file hashes and\n  // explicitly provided URIs\n  const scale = AssetSourceResolver.pickScale(meta.scales, PixelRatio.get());\n  const index = meta.scales.findIndex((s) => s === scale);\n  const hash = meta.fileHashes ? (meta.fileHashes[index] ?? meta.fileHashes[0]) : meta.hash;\n\n  // Allow asset processors to directly provide the URL to load\n  const uri = meta.fileUris ? (meta.fileUris[index] ?? meta.fileUris[0]) : meta.uri;\n  if (uri) {\n    return { uri: resolveUri(uri), hash };\n  }\n\n  const fileScale = scale === 1 ? '' : `@${scale}x`;\n  const fileExtension = meta.type ? `.${encodeURIComponent(meta.type)}` : '';\n  const suffix = `/${encodeURIComponent(meta.name)}${fileScale}${fileExtension}`;\n  const params = new URLSearchParams({\n    platform: Platform.OS,\n    hash: meta.hash,\n  });\n\n  // For assets with a specified absolute URL, we use the existing origin instead of prepending the\n  // development server or production CDN URL origin\n  if (/^https?:\\/\\//.test(meta.httpServerLocation)) {\n    const uri = meta.httpServerLocation + suffix + '?' + params;\n    return { uri, hash };\n  }\n\n  // For assets during development using manifest2, we use the development server's URL origin\n  const manifest2 = getManifest2();\n\n  const devServerUrl = manifest2?.extra?.expoGo?.developer\n    ? 'http://' + manifest2.extra.expoGo.debuggerHost\n    : null;\n  if (devServerUrl) {\n    const baseUrl = new URL(meta.httpServerLocation + suffix, devServerUrl);\n\n    baseUrl.searchParams.set('platform', Platform.OS);\n    baseUrl.searchParams.set('hash', meta.hash);\n    return {\n      uri: baseUrl.href,\n      hash,\n    };\n  }\n\n  // Temporary fallback for loading assets in Expo Go home\n  if (NativeModules['ExponentKernel']) {\n    return { uri: `https://classic-assets.eascdn.net/~assets/${encodeURIComponent(hash)}`, hash };\n  }\n\n  // In correctly configured apps, we arrive here if the asset is locally available on disk due to\n  // being managed by expo-updates, and `getLocalAssetUri(hash)` must return a local URI for this\n  // hash. Since the asset is local, we don't have a remote URL and specify an invalid URL (an empty\n  // string) as a placeholder.\n  return { uri: '', hash };\n}\n\n/**\n * Resolves the given URI to an absolute URI. If the given URI is already an absolute URI, it is\n * simply returned. Otherwise, if it is a relative URI, it is resolved relative to the manifest's\n * base URI.\n */\nexport function resolveUri(uri: string): string {\n  // `manifestBaseUrl` is always an absolute URL or `null`.\n  return manifestBaseUrl ? new URL(uri, manifestBaseUrl).href : uri;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}