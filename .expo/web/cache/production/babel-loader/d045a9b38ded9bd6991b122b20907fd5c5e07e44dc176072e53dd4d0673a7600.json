{"ast":null,"code":"import AsyncStorage from'@react-native-async-storage/async-storage';import{SecurityUtils}from'./security';export class TokenManager{static TOKEN_KEY='auth_tokens';static SESSION_KEY='session_data';static SESSION_TIMEOUT=7*24*60*60*1000;static tokenRefreshTimer=null;static async storeTokens(tokenData){try{const encrypted=await SecurityUtils.encryptData(JSON.stringify(tokenData));await AsyncStorage.setItem(this.TOKEN_KEY,encrypted);const sessionData={token:tokenData,deviceId:SecurityUtils.generateSecureToken(),lastActivity:Date.now()};await AsyncStorage.setItem(this.SESSION_KEY,JSON.stringify(sessionData));this.scheduleTokenRefresh(tokenData.expiresAt);console.log('Tokens stored securely');}catch(error){console.error('Error storing tokens:',error);throw new Error('Failed to store authentication tokens');}}static async getTokens(){try{const encrypted=await AsyncStorage.getItem(this.TOKEN_KEY);if(!encrypted)return null;const decrypted=await SecurityUtils.decryptData(encrypted);const tokenData=JSON.parse(decrypted);if(SecurityUtils.isTokenExpired(tokenData.expiresAt)){console.log('Token expired, attempting refresh');return await this.refreshTokens(tokenData.refreshToken);}await this.updateLastActivity();return tokenData;}catch(error){console.error('Error retrieving tokens:',error);return null;}}static async refreshTokens(refreshToken){try{console.log('Refreshing tokens...');const newTokenData={accessToken:SecurityUtils.generateSecureToken(),refreshToken:SecurityUtils.generateSecureToken(),expiresAt:SecurityUtils.getTokenExpiryTime(3600000),userId:''};await this.storeTokens(newTokenData);return newTokenData;}catch(error){console.error('Error refreshing tokens:',error);await this.clearTokens();return null;}}static async clearTokens(){try{await AsyncStorage.removeItem(this.TOKEN_KEY);await AsyncStorage.removeItem(this.SESSION_KEY);if(this.tokenRefreshTimer){clearTimeout(this.tokenRefreshTimer);this.tokenRefreshTimer=null;}console.log('Tokens cleared');}catch(error){console.error('Error clearing tokens:',error);}}static async isSessionValid(){try{const sessionJson=await AsyncStorage.getItem(this.SESSION_KEY);if(!sessionJson)return false;const session=JSON.parse(sessionJson);const timeSinceLastActivity=Date.now()-session.lastActivity;if(timeSinceLastActivity>this.SESSION_TIMEOUT){console.log('Session expired due to inactivity');await this.clearTokens();return false;}return!SecurityUtils.isTokenExpired(session.token.expiresAt);}catch(error){console.error('Error checking session validity:',error);return false;}}static async updateLastActivity(){try{const sessionJson=await AsyncStorage.getItem(this.SESSION_KEY);if(!sessionJson)return;const session=JSON.parse(sessionJson);session.lastActivity=Date.now();await AsyncStorage.setItem(this.SESSION_KEY,JSON.stringify(session));}catch(error){console.error('Error updating last activity:',error);}}static scheduleTokenRefresh(expiresAt){if(this.tokenRefreshTimer){clearTimeout(this.tokenRefreshTimer);}const timeUntilExpiry=expiresAt-Date.now();const refreshTime=Math.max(0,timeUntilExpiry-5*60*1000);this.tokenRefreshTimer=setTimeout(async()=>{const tokens=await this.getTokens();if(tokens){await this.refreshTokens(tokens.refreshToken);}},refreshTime);}static async getAccessToken(){const tokens=await this.getTokens();return tokens?.accessToken||null;}static async validateToken(token){try{const tokens=await this.getTokens();return tokens?.accessToken===token&&!SecurityUtils.isTokenExpired(tokens.expiresAt);}catch(error){console.error('Error validating token:',error);return false;}}}","map":{"version":3,"names":["AsyncStorage","SecurityUtils","TokenManager","TOKEN_KEY","SESSION_KEY","SESSION_TIMEOUT","tokenRefreshTimer","storeTokens","tokenData","encrypted","encryptData","JSON","stringify","setItem","sessionData","token","deviceId","generateSecureToken","lastActivity","Date","now","scheduleTokenRefresh","expiresAt","console","log","error","Error","getTokens","getItem","decrypted","decryptData","parse","isTokenExpired","refreshTokens","refreshToken","updateLastActivity","newTokenData","accessToken","getTokenExpiryTime","userId","clearTokens","removeItem","clearTimeout","isSessionValid","sessionJson","session","timeSinceLastActivity","timeUntilExpiry","refreshTime","Math","max","setTimeout","tokens","getAccessToken","validateToken"],"sources":["/home/user/rork-vibesync-458/utils/token-manager.ts"],"sourcesContent":["import AsyncStorage from '@react-native-async-storage/async-storage';\nimport { SecurityUtils } from './security';\n\ninterface TokenData {\n  accessToken: string;\n  refreshToken: string;\n  expiresAt: number;\n  userId: string;\n}\n\ninterface SessionData {\n  token: TokenData;\n  deviceId: string;\n  lastActivity: number;\n}\n\nexport class TokenManager {\n  private static readonly TOKEN_KEY = 'auth_tokens';\n  private static readonly SESSION_KEY = 'session_data';\n  private static readonly SESSION_TIMEOUT = 7 * 24 * 60 * 60 * 1000;\n  private static tokenRefreshTimer: ReturnType<typeof setTimeout> | null = null;\n\n  static async storeTokens(tokenData: TokenData): Promise<void> {\n    try {\n      const encrypted = await SecurityUtils.encryptData(JSON.stringify(tokenData));\n      await AsyncStorage.setItem(this.TOKEN_KEY, encrypted);\n      \n      const sessionData: SessionData = {\n        token: tokenData,\n        deviceId: SecurityUtils.generateSecureToken(),\n        lastActivity: Date.now(),\n      };\n      \n      await AsyncStorage.setItem(this.SESSION_KEY, JSON.stringify(sessionData));\n      \n      this.scheduleTokenRefresh(tokenData.expiresAt);\n      \n      console.log('Tokens stored securely');\n    } catch (error) {\n      console.error('Error storing tokens:', error);\n      throw new Error('Failed to store authentication tokens');\n    }\n  }\n\n  static async getTokens(): Promise<TokenData | null> {\n    try {\n      const encrypted = await AsyncStorage.getItem(this.TOKEN_KEY);\n      if (!encrypted) return null;\n\n      const decrypted = await SecurityUtils.decryptData(encrypted);\n      const tokenData: TokenData = JSON.parse(decrypted);\n\n      if (SecurityUtils.isTokenExpired(tokenData.expiresAt)) {\n        console.log('Token expired, attempting refresh');\n        return await this.refreshTokens(tokenData.refreshToken);\n      }\n\n      await this.updateLastActivity();\n      return tokenData;\n    } catch (error) {\n      console.error('Error retrieving tokens:', error);\n      return null;\n    }\n  }\n\n  static async refreshTokens(refreshToken: string): Promise<TokenData | null> {\n    try {\n      console.log('Refreshing tokens...');\n      \n      const newTokenData: TokenData = {\n        accessToken: SecurityUtils.generateSecureToken(),\n        refreshToken: SecurityUtils.generateSecureToken(),\n        expiresAt: SecurityUtils.getTokenExpiryTime(3600000),\n        userId: '',\n      };\n\n      await this.storeTokens(newTokenData);\n      return newTokenData;\n    } catch (error) {\n      console.error('Error refreshing tokens:', error);\n      await this.clearTokens();\n      return null;\n    }\n  }\n\n  static async clearTokens(): Promise<void> {\n    try {\n      await AsyncStorage.removeItem(this.TOKEN_KEY);\n      await AsyncStorage.removeItem(this.SESSION_KEY);\n      \n      if (this.tokenRefreshTimer) {\n        clearTimeout(this.tokenRefreshTimer);\n        this.tokenRefreshTimer = null;\n      }\n      \n      console.log('Tokens cleared');\n    } catch (error) {\n      console.error('Error clearing tokens:', error);\n    }\n  }\n\n  static async isSessionValid(): Promise<boolean> {\n    try {\n      const sessionJson = await AsyncStorage.getItem(this.SESSION_KEY);\n      if (!sessionJson) return false;\n\n      const session: SessionData = JSON.parse(sessionJson);\n      const timeSinceLastActivity = Date.now() - session.lastActivity;\n\n      if (timeSinceLastActivity > this.SESSION_TIMEOUT) {\n        console.log('Session expired due to inactivity');\n        await this.clearTokens();\n        return false;\n      }\n\n      return !SecurityUtils.isTokenExpired(session.token.expiresAt);\n    } catch (error) {\n      console.error('Error checking session validity:', error);\n      return false;\n    }\n  }\n\n  static async updateLastActivity(): Promise<void> {\n    try {\n      const sessionJson = await AsyncStorage.getItem(this.SESSION_KEY);\n      if (!sessionJson) return;\n\n      const session: SessionData = JSON.parse(sessionJson);\n      session.lastActivity = Date.now();\n      \n      await AsyncStorage.setItem(this.SESSION_KEY, JSON.stringify(session));\n    } catch (error) {\n      console.error('Error updating last activity:', error);\n    }\n  }\n\n  private static scheduleTokenRefresh(expiresAt: number): void {\n    if (this.tokenRefreshTimer) {\n      clearTimeout(this.tokenRefreshTimer);\n    }\n\n    const timeUntilExpiry = expiresAt - Date.now();\n    const refreshTime = Math.max(0, timeUntilExpiry - 5 * 60 * 1000);\n\n    this.tokenRefreshTimer = setTimeout(async () => {\n      const tokens = await this.getTokens();\n      if (tokens) {\n        await this.refreshTokens(tokens.refreshToken);\n      }\n    }, refreshTime);\n  }\n\n  static async getAccessToken(): Promise<string | null> {\n    const tokens = await this.getTokens();\n    return tokens?.accessToken || null;\n  }\n\n  static async validateToken(token: string): Promise<boolean> {\n    try {\n      const tokens = await this.getTokens();\n      return tokens?.accessToken === token && !SecurityUtils.isTokenExpired(tokens.expiresAt);\n    } catch (error) {\n      console.error('Error validating token:', error);\n      return false;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}