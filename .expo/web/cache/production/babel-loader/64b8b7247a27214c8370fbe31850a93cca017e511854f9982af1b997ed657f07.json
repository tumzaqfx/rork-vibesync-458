{"ast":null,"code":"\"use strict\";export function getPatternParts(path){const parts=[];let current={segment:''};let isRegex=false;let isParam=false;let regexInnerParens=0;for(let i=0;i<=path.length;i++){const char=path[i];if(char!=null){current.segment+=char;}if(char===':'){if(current.segment===':'){isParam=true;}else if(!isRegex){throw new Error(`Encountered ':' in the middle of a segment in path: ${path}`);}}else if(char==='('){if(isParam){if(isRegex){regexInnerParens++;}else{isRegex=true;}}else{throw new Error(`Encountered '(' without preceding ':' in path: ${path}`);}}else if(char===')'){if(isParam&&isRegex){if(regexInnerParens){regexInnerParens--;current.regex+=char;}else{isRegex=false;isParam=false;}}else{throw new Error(`Encountered ')' without preceding '(' in path: ${path}`);}}else if(char==='?'){if(current.param){isParam=false;current.optional=true;}else{throw new Error(`Encountered '?' without preceding ':' in path: ${path}`);}}else if(char==null||char==='/'&&!isRegex){isParam=false;current.segment=current.segment.replace(/\\/$/,'');if(current.segment===''){continue;}if(current.param){current.param=current.param.replace(/^:/,'');}if(current.regex){current.regex=current.regex.replace(/^\\(/,'').replace(/\\)$/,'');}parts.push(current);if(char==null){break;}current={segment:''};}if(isRegex){current.regex=current.regex||'';current.regex+=char;}if(isParam&&!isRegex){current.param=current.param||'';current.param+=char;}}if(isRegex){throw new Error(`Could not find closing ')' in path: ${path}`);}const params=parts.map(part=>part.param).filter(Boolean);for(const[index,param]of params.entries()){if(params.indexOf(param)!==index){throw new Error(`Duplicate param name '${param}' found in path: ${path}`);}}return parts;}","map":{"version":3,"names":["getPatternParts","path","parts","current","segment","isRegex","isParam","regexInnerParens","i","length","char","Error","regex","param","optional","replace","push","params","map","part","filter","Boolean","index","entries","indexOf"],"sources":["/home/user/rork-vibesync-458/node_modules/@react-navigation/core/src/getPatternParts.tsx"],"sourcesContent":["export type PatternPart = {\n  segment: string;\n  param?: string;\n  regex?: string;\n  optional?: boolean;\n};\n\n/**\n * Parse a path into an array of parts with information about each segment.\n */\nexport function getPatternParts(path: string): PatternPart[] {\n  const parts: PatternPart[] = [];\n\n  let current: PatternPart = { segment: '' };\n\n  let isRegex = false;\n  let isParam = false;\n  let regexInnerParens = 0;\n\n  // One extra iteration to add the last character\n  for (let i = 0; i <= path.length; i++) {\n    const char = path[i];\n\n    if (char != null) {\n      current.segment += char;\n    }\n\n    if (char === ':') {\n      // The segment must start with a colon if it's a param\n      if (current.segment === ':') {\n        isParam = true;\n      } else if (!isRegex) {\n        throw new Error(\n          `Encountered ':' in the middle of a segment in path: ${path}`\n        );\n      }\n    } else if (char === '(') {\n      if (isParam) {\n        if (isRegex) {\n          // The '(' is part of the regex if we're already inside one\n          regexInnerParens++;\n        } else {\n          isRegex = true;\n        }\n      } else {\n        throw new Error(\n          `Encountered '(' without preceding ':' in path: ${path}`\n        );\n      }\n    } else if (char === ')') {\n      if (isParam && isRegex) {\n        if (regexInnerParens) {\n          // The ')' is part of the regex if we're already inside one\n          regexInnerParens--;\n          current.regex += char;\n        } else {\n          isRegex = false;\n          isParam = false;\n        }\n      } else {\n        throw new Error(\n          `Encountered ')' without preceding '(' in path: ${path}`\n        );\n      }\n    } else if (char === '?') {\n      if (current.param) {\n        isParam = false;\n\n        current.optional = true;\n      } else {\n        throw new Error(\n          `Encountered '?' without preceding ':' in path: ${path}`\n        );\n      }\n    } else if (char == null || (char === '/' && !isRegex)) {\n      isParam = false;\n\n      // Remove trailing slash from segment\n      current.segment = current.segment.replace(/\\/$/, '');\n\n      if (current.segment === '') {\n        continue;\n      }\n\n      if (current.param) {\n        current.param = current.param.replace(/^:/, '');\n      }\n\n      if (current.regex) {\n        current.regex = current.regex.replace(/^\\(/, '').replace(/\\)$/, '');\n      }\n\n      parts.push(current);\n\n      if (char == null) {\n        break;\n      }\n\n      current = { segment: '' };\n    }\n\n    if (isRegex) {\n      current.regex = current.regex || '';\n      current.regex += char;\n    }\n\n    if (isParam && !isRegex) {\n      current.param = current.param || '';\n      current.param += char;\n    }\n  }\n\n  if (isRegex) {\n    throw new Error(`Could not find closing ')' in path: ${path}`);\n  }\n\n  const params = parts.map((part) => part.param).filter(Boolean);\n\n  for (const [index, param] of params.entries()) {\n    if (params.indexOf(param) !== index) {\n      throw new Error(`Duplicate param name '${param}' found in path: ${path}`);\n    }\n  }\n\n  return parts;\n}\n"],"mappings":"aAUA,MAAO,SAAS,CAAAA,eAAeA,CAACC,IAAY,CAAiB,CAC3D,KAAM,CAAAC,KAAoB,CAAG,EAAE,CAE/B,GAAI,CAAAC,OAAoB,CAAG,CAAEC,OAAO,CAAE,EAAG,CAAC,CAE1C,GAAI,CAAAC,OAAO,CAAG,KAAK,CACnB,GAAI,CAAAC,OAAO,CAAG,KAAK,CACnB,GAAI,CAAAC,gBAAgB,CAAG,CAAC,CAGxB,IAAK,GAAI,CAAAC,CAAC,CAAG,CAAC,CAAEA,CAAC,EAAIP,IAAI,CAACQ,MAAM,CAAED,CAAC,EAAE,CAAE,CACrC,KAAM,CAAAE,IAAI,CAAGT,IAAI,CAACO,CAAC,CAAC,CAEpB,GAAIE,IAAI,EAAI,IAAI,CAAE,CAChBP,OAAO,CAACC,OAAO,EAAIM,IAAI,CACzB,CAEA,GAAIA,IAAI,GAAK,GAAG,CAAE,CAEhB,GAAIP,OAAO,CAACC,OAAO,GAAK,GAAG,CAAE,CAC3BE,OAAO,CAAG,IAAI,CAChB,CAAC,IAAM,IAAI,CAACD,OAAO,CAAE,CACnB,KAAM,IAAI,CAAAM,KAAK,CACb,uDAAuDV,IAAI,EAC7D,CAAC,CACH,CACF,CAAC,IAAM,IAAIS,IAAI,GAAK,GAAG,CAAE,CACvB,GAAIJ,OAAO,CAAE,CACX,GAAID,OAAO,CAAE,CAEXE,gBAAgB,EAAE,CACpB,CAAC,IAAM,CACLF,OAAO,CAAG,IAAI,CAChB,CACF,CAAC,IAAM,CACL,KAAM,IAAI,CAAAM,KAAK,CACb,kDAAkDV,IAAI,EACxD,CAAC,CACH,CACF,CAAC,IAAM,IAAIS,IAAI,GAAK,GAAG,CAAE,CACvB,GAAIJ,OAAO,EAAID,OAAO,CAAE,CACtB,GAAIE,gBAAgB,CAAE,CAEpBA,gBAAgB,EAAE,CAClBJ,OAAO,CAACS,KAAK,EAAIF,IAAI,CACvB,CAAC,IAAM,CACLL,OAAO,CAAG,KAAK,CACfC,OAAO,CAAG,KAAK,CACjB,CACF,CAAC,IAAM,CACL,KAAM,IAAI,CAAAK,KAAK,CACb,kDAAkDV,IAAI,EACxD,CAAC,CACH,CACF,CAAC,IAAM,IAAIS,IAAI,GAAK,GAAG,CAAE,CACvB,GAAIP,OAAO,CAACU,KAAK,CAAE,CACjBP,OAAO,CAAG,KAAK,CAEfH,OAAO,CAACW,QAAQ,CAAG,IAAI,CACzB,CAAC,IAAM,CACL,KAAM,IAAI,CAAAH,KAAK,CACb,kDAAkDV,IAAI,EACxD,CAAC,CACH,CACF,CAAC,IAAM,IAAIS,IAAI,EAAI,IAAI,EAAKA,IAAI,GAAK,GAAG,EAAI,CAACL,OAAQ,CAAE,CACrDC,OAAO,CAAG,KAAK,CAGfH,OAAO,CAACC,OAAO,CAAGD,OAAO,CAACC,OAAO,CAACW,OAAO,CAAC,KAAK,CAAE,EAAE,CAAC,CAEpD,GAAIZ,OAAO,CAACC,OAAO,GAAK,EAAE,CAAE,CAC1B,SACF,CAEA,GAAID,OAAO,CAACU,KAAK,CAAE,CACjBV,OAAO,CAACU,KAAK,CAAGV,OAAO,CAACU,KAAK,CAACE,OAAO,CAAC,IAAI,CAAE,EAAE,CAAC,CACjD,CAEA,GAAIZ,OAAO,CAACS,KAAK,CAAE,CACjBT,OAAO,CAACS,KAAK,CAAGT,OAAO,CAACS,KAAK,CAACG,OAAO,CAAC,KAAK,CAAE,EAAE,CAAC,CAACA,OAAO,CAAC,KAAK,CAAE,EAAE,CAAC,CACrE,CAEAb,KAAK,CAACc,IAAI,CAACb,OAAO,CAAC,CAEnB,GAAIO,IAAI,EAAI,IAAI,CAAE,CAChB,MACF,CAEAP,OAAO,CAAG,CAAEC,OAAO,CAAE,EAAG,CAAC,CAC3B,CAEA,GAAIC,OAAO,CAAE,CACXF,OAAO,CAACS,KAAK,CAAGT,OAAO,CAACS,KAAK,EAAI,EAAE,CACnCT,OAAO,CAACS,KAAK,EAAIF,IAAI,CACvB,CAEA,GAAIJ,OAAO,EAAI,CAACD,OAAO,CAAE,CACvBF,OAAO,CAACU,KAAK,CAAGV,OAAO,CAACU,KAAK,EAAI,EAAE,CACnCV,OAAO,CAACU,KAAK,EAAIH,IAAI,CACvB,CACF,CAEA,GAAIL,OAAO,CAAE,CACX,KAAM,IAAI,CAAAM,KAAK,CAAC,uCAAuCV,IAAI,EAAE,CAAC,CAChE,CAEA,KAAM,CAAAgB,MAAM,CAAGf,KAAK,CAACgB,GAAG,CAAEC,IAAI,EAAKA,IAAI,CAACN,KAAK,CAAC,CAACO,MAAM,CAACC,OAAO,CAAC,CAE9D,IAAK,KAAM,CAACC,KAAK,CAAET,KAAK,CAAC,EAAI,CAAAI,MAAM,CAACM,OAAO,CAAC,CAAC,CAAE,CAC7C,GAAIN,MAAM,CAACO,OAAO,CAACX,KAAK,CAAC,GAAKS,KAAK,CAAE,CACnC,KAAM,IAAI,CAAAX,KAAK,CAAC,yBAAyBE,KAAK,oBAAoBZ,IAAI,EAAE,CAAC,CAC3E,CACF,CAEA,MAAO,CAAAC,KAAK,CACd","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}