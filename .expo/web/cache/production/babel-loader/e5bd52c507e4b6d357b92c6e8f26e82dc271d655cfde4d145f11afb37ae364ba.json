{"ast":null,"code":"\"use strict\";import _objectWithoutPropertiesLoose from\"@babel/runtime/helpers/objectWithoutPropertiesLoose\";const _excluded=[\"screen\",\"if\"],_excluded2=[\"screens\",\"groups\"],_excluded3=[\"if\"];import*as React from'react';import{isValidElementType}from'react-is';import{useRoute}from\"./useRoute.js\";import{jsx as _jsx}from\"react/jsx-runtime\";import{createElement as _createElement}from\"react\";const MemoizedScreen=React.memo(({component})=>{const route=useRoute();const children=React.createElement(component,{route});return children;});MemoizedScreen.displayName='Memo(Screen)';const getItemsFromScreens=(Screen,screens)=>{return Object.entries(screens).map(([name,item])=>{let component;let props={};let useIf;let isNavigator=false;if('screen'in item){const{screen,if:_if}=item,rest=_objectWithoutPropertiesLoose(item,_excluded);useIf=_if;props=rest;if(isValidElementType(screen)){component=screen;}else if('config'in screen){isNavigator=true;component=createComponentForStaticNavigation(screen,`${name}Navigator`);}}else if(isValidElementType(item)){component=item;}else if('config'in item){isNavigator=true;component=createComponentForStaticNavigation(item,`${name}Navigator`);}if(component==null){throw new Error(`Couldn't find a 'screen' property for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`);}const element=isNavigator?(React.createElement(component,{})):_jsx(MemoizedScreen,{component:component});return()=>{const shouldRender=useIf==null||useIf();if(!shouldRender){return null;}return _jsx(Screen,Object.assign({name:name},props,{children:()=>element}),name);};});};export function createComponentForStaticNavigation(tree,displayName){const{Navigator,Group,Screen,config}=tree;const{screens,groups}=config,rest=_objectWithoutPropertiesLoose(config,_excluded2);if(screens==null&&groups==null){throw new Error(\"Couldn't find a 'screens' or 'groups' property. Make sure to define your screens under a 'screens' property in the configuration.\");}const items=[];for(const key in config){if(key==='screens'&&screens){items.push(...getItemsFromScreens(Screen,screens));}if(key==='groups'&&groups){items.push(...Object.entries(groups).map(([key,_ref])=>{let{if:useIf}=_ref,group=_objectWithoutPropertiesLoose(_ref,_excluded3);const groupItems=getItemsFromScreens(Screen,group.screens);return()=>{const children=groupItems.map(item=>item());const shouldRender=useIf==null||useIf();if(!shouldRender){return null;}return _createElement(Group,Object.assign({navigationKey:key},group,{key:key}),children);};}));}}const NavigatorComponent=()=>{const children=items.map(item=>item());return _jsx(Navigator,Object.assign({},rest,{children:children}));};NavigatorComponent.displayName=displayName;return NavigatorComponent;}export function createPathConfigForStaticNavigation(tree,options,auto){let initialScreenConfig;const createPathConfigForTree=(t,o,skipInitialDetection)=>{const createPathConfigForScreens=(screens,initialRouteName)=>{return Object.fromEntries(Object.entries(screens).sort(([a],[b])=>{if(a===initialRouteName){return-1;}if(b===initialRouteName){return 1;}return 0;}).map(([key,item])=>{const screenConfig={};if('linking'in item){if(typeof item.linking==='string'){screenConfig.path=item.linking;}else{Object.assign(screenConfig,item.linking);}if(typeof screenConfig.path==='string'){screenConfig.path=screenConfig.path.replace(/^\\//,'').replace(/\\/$/,'');}}let screens;const skipInitialDetectionInChild=skipInitialDetection||screenConfig.path!=null&&screenConfig.path!=='';if('config'in item){screens=createPathConfigForTree(item,undefined,skipInitialDetectionInChild);}else if('screen'in item&&'config'in item.screen&&(item.screen.config.screens||item.screen.config.groups)){screens=createPathConfigForTree(item.screen,undefined,skipInitialDetectionInChild);}if(screens){screenConfig.screens=screens;}if(auto&&!screenConfig.screens&&!('linking'in item&&item.linking==null)){if(screenConfig.path!=null){if(!skipInitialDetection&&screenConfig.path===''){initialScreenConfig=undefined;}}else{if(!skipInitialDetection&&initialScreenConfig==null){initialScreenConfig=screenConfig;}screenConfig.path=key.replace(/([A-Z]+)/g,'-$1').replace(/^-/,'').toLowerCase();}}return[key,screenConfig];}).filter(([,screen])=>Object.keys(screen).length>0));};const screens={};for(const key in t.config){if(key==='screens'&&t.config.screens){Object.assign(screens,createPathConfigForScreens(t.config.screens,o?.initialRouteName??t.config.initialRouteName));}if(key==='groups'&&t.config.groups){Object.entries(t.config.groups).forEach(([,group])=>{Object.assign(screens,createPathConfigForScreens(group.screens,o?.initialRouteName??t.config.initialRouteName));});}}if(Object.keys(screens).length===0){return undefined;}return screens;};const screens=createPathConfigForTree(tree,options,false);if(auto&&initialScreenConfig){initialScreenConfig.path='';}return screens;}","map":{"version":3,"names":["React","isValidElementType","useRoute","jsx","_jsx","createElement","_createElement","MemoizedScreen","memo","component","route","children","displayName","getItemsFromScreens","Screen","screens","Object","entries","map","name","item","props","useIf","isNavigator","screen","if","_if","rest","_objectWithoutPropertiesLoose","_excluded","createComponentForStaticNavigation","Error","element","shouldRender","assign","tree","Navigator","Group","config","groups","_excluded2","items","key","push","_ref","group","_excluded3","groupItems","navigationKey","NavigatorComponent","createPathConfigForStaticNavigation","options","auto","initialScreenConfig","createPathConfigForTree","t","o","skipInitialDetection","createPathConfigForScreens","initialRouteName","fromEntries","sort","a","b","screenConfig","linking","path","replace","skipInitialDetectionInChild","undefined","toLowerCase","filter","keys","length","forEach"],"sources":["/home/user/rork-vibesync-458/node_modules/@react-navigation/core/src/StaticNavigation.tsx"],"sourcesContent":["import type { NavigationState, ParamListBase } from '@react-navigation/routers';\nimport * as React from 'react';\nimport { isValidElementType } from 'react-is';\n\nimport type {\n  DefaultNavigatorOptions,\n  EventMapBase,\n  NavigationListBase,\n  NavigatorScreenParams,\n  NavigatorTypeBagBase,\n  PathConfig,\n  RouteConfigComponent,\n  RouteConfigProps,\n  RouteGroupConfig,\n} from './types';\nimport { useRoute } from './useRoute';\n\n/**\n * Flatten a type to remove all type alias names, unions etc.\n * This will show a plain object when hovering over the type.\n */\ntype FlatType<T> = { [K in keyof T]: T[K] } & {};\n\n/**\n * keyof T doesn't work for union types. We can use distributive conditional types instead.\n * https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n */\ntype KeysOf<T> = T extends {} ? keyof T : never;\n\n/**\n * We get a union type when using keyof, but we want an intersection instead.\n * https://stackoverflow.com/a/50375286/1665026\n */\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I\n) => void\n  ? I\n  : never;\n\ntype UnknownToUndefined<T> = unknown extends T ? undefined : T;\n\ntype ParamsForScreenComponent<T> = T extends {\n  screen: React.ComponentType<{ route: { params: infer P } }>;\n}\n  ? P\n  : T extends React.ComponentType<{ route: { params: infer P } }>\n    ? P\n    : undefined;\n\ntype ParamsForScreen<T> = T extends { screen: StaticNavigation<any, any, any> }\n  ? NavigatorScreenParams<StaticParamList<T['screen']>> | undefined\n  : T extends StaticNavigation<any, any, any>\n    ? NavigatorScreenParams<StaticParamList<T>> | undefined\n    : UnknownToUndefined<ParamsForScreenComponent<T>>;\n\ntype ParamListForScreens<Screens> = {\n  [Key in KeysOf<Screens>]: ParamsForScreen<Screens[Key]>;\n};\n\ntype ParamListForGroups<\n  Groups extends\n    | Readonly<{\n        [key: string]: {\n          screens: StaticConfigScreens<\n            ParamListBase,\n            NavigationState,\n            {},\n            EventMapBase,\n            any\n          >;\n        };\n      }>\n    | undefined,\n> = Groups extends {\n  [key: string]: {\n    screens: StaticConfigScreens<\n      ParamListBase,\n      NavigationState,\n      {},\n      EventMapBase,\n      any\n    >;\n  };\n}\n  ? ParamListForScreens<UnionToIntersection<Groups[keyof Groups]['screens']>>\n  : {};\n\ntype StaticRouteConfig<\n  ParamList extends ParamListBase,\n  RouteName extends keyof ParamList,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  Navigation,\n> = RouteConfigProps<\n  ParamList,\n  RouteName,\n  State,\n  ScreenOptions,\n  EventMap,\n  Navigation\n> &\n  RouteConfigComponent<ParamList, RouteName>;\n\ntype StaticConfigScreens<\n  ParamList extends ParamListBase,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  NavigationList extends NavigationListBase<ParamList>,\n> = {\n  [RouteName in keyof ParamList]:\n    | React.ComponentType<any>\n    | StaticNavigation<any, any, any>\n    | (Omit<\n        StaticRouteConfig<\n          ParamList,\n          RouteName,\n          State,\n          ScreenOptions,\n          EventMap,\n          NavigationList[RouteName]\n        >,\n        'name' | 'component' | 'getComponent' | 'children'\n      > & {\n        /**\n         * Callback to determine whether the screen should be rendered or not.\n         * This can be useful for conditional rendering of screens,\n         * e.g. - if you want to render a different screen for logged in users.\n         *\n         * You can use a custom hook to use custom logic to determine the return value.\n         *\n         * @example\n         * ```js\n         * if: useIsLoggedIn\n         * ```\n         */\n        if?: () => boolean;\n        /**\n         * Linking config for the screen.\n         * This can be a string to specify the path, or an object with more options.\n         *\n         * @example\n         * ```js\n         * linking: {\n         *   path: 'profile/:id',\n         *   exact: true,\n         * },\n         * ```\n         */\n        linking?: PathConfig<ParamList> | string;\n        /**\n         * Static navigation config or Component to render for the screen.\n         */\n        screen: StaticNavigation<any, any, any> | React.ComponentType<any>;\n      });\n};\n\ntype GroupConfig<\n  ParamList extends ParamListBase,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  NavigationList extends NavigationListBase<ParamList>,\n> = Omit<\n  RouteGroupConfig<ParamList, ScreenOptions, NavigationList[keyof ParamList]>,\n  'screens' | 'children'\n> & {\n  /**\n   * Callback to determine whether the screens in the group should be rendered or not.\n   * This can be useful for conditional rendering of group of screens.\n   */\n  if?: () => boolean;\n  /**\n   * Static navigation config or Component to render for the screen.\n   */\n  screens: StaticConfigScreens<\n    ParamList,\n    State,\n    ScreenOptions,\n    EventMap,\n    NavigationList\n  >;\n};\n\nexport type StaticConfig<Bag extends NavigatorTypeBagBase> =\n  StaticConfigInternal<\n    Bag['ParamList'],\n    Bag['NavigatorID'],\n    Bag['State'],\n    Bag['ScreenOptions'],\n    Bag['EventMap'],\n    Bag['NavigationList'],\n    Bag['Navigator']\n  >;\n\ntype StaticConfigInternal<\n  ParamList extends ParamListBase,\n  NavigatorID extends string | undefined,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  NavigationList extends NavigationListBase<ParamList>,\n  Navigator extends React.ComponentType<any>,\n> = Omit<\n  Omit<\n    React.ComponentProps<Navigator>,\n    keyof DefaultNavigatorOptions<\n      ParamListBase,\n      string | undefined,\n      NavigationState,\n      {},\n      EventMapBase,\n      NavigationList[keyof ParamList]\n    >\n  > &\n    DefaultNavigatorOptions<\n      ParamList,\n      NavigatorID,\n      State,\n      ScreenOptions,\n      EventMap,\n      NavigationList[keyof ParamList]\n    >,\n  'screens' | 'children'\n> &\n  (\n    | {\n        /**\n         * Screens to render in the navigator and their configuration.\n         */\n        screens: StaticConfigScreens<\n          ParamList,\n          State,\n          ScreenOptions,\n          EventMap,\n          NavigationList\n        >;\n        /**\n         * Groups of screens to render in the navigator and their configuration.\n         */\n        groups?: {\n          [key: string]: GroupConfig<\n            ParamList,\n            State,\n            ScreenOptions,\n            EventMap,\n            NavigationList\n          >;\n        };\n      }\n    | {\n        /**\n         * Screens to render in the navigator and their configuration.\n         */\n        screens?: StaticConfigScreens<\n          ParamList,\n          State,\n          ScreenOptions,\n          EventMap,\n          NavigationList\n        >;\n        /**\n         * Groups of screens to render in the navigator and their configuration.\n         */\n        groups: {\n          [key: string]: GroupConfig<\n            ParamList,\n            State,\n            ScreenOptions,\n            EventMap,\n            NavigationList\n          >;\n        };\n      }\n  );\n\n/**\n * Props for a screen component which is rendered by a static navigator.\n * Takes the route params as a generic argument.\n */\nexport type StaticScreenProps<T extends Record<string, unknown> | undefined> = {\n  route: {\n    params: T;\n  };\n};\n\n/**\n * Infer the param list from the static navigation config.\n */\nexport type StaticParamList<\n  T extends {\n    readonly config: {\n      readonly screens?: Record<string, any>;\n      readonly groups?: {\n        [key: string]: {\n          screens: Record<string, any>;\n        };\n      };\n    };\n  },\n> = FlatType<\n  ParamListForScreens<T['config']['screens']> &\n    ParamListForGroups<T['config']['groups']>\n>;\n\nexport type StaticNavigation<NavigatorProps, GroupProps, ScreenProps> = {\n  Navigator: React.ComponentType<NavigatorProps>;\n  Group: React.ComponentType<GroupProps>;\n  Screen: React.ComponentType<ScreenProps>;\n  config: StaticConfig<NavigatorTypeBagBase>;\n};\n\nconst MemoizedScreen = React.memo(\n  <T extends React.ComponentType<any>>({ component }: { component: T }) => {\n    const route = useRoute();\n    const children = React.createElement(component, { route });\n\n    return children;\n  }\n);\n\nMemoizedScreen.displayName = 'Memo(Screen)';\n\nconst getItemsFromScreens = (\n  Screen: React.ComponentType<any>,\n  screens: StaticConfigScreens<any, any, any, any, any>\n) => {\n  return Object.entries(screens).map(([name, item]) => {\n    let component: React.ComponentType<any> | undefined;\n    let props: {} = {};\n    let useIf: (() => boolean) | undefined;\n\n    let isNavigator = false;\n\n    if ('screen' in item) {\n      const { screen, if: _if, ...rest } = item;\n\n      useIf = _if;\n      props = rest;\n\n      if (isValidElementType(screen)) {\n        component = screen;\n      } else if ('config' in screen) {\n        isNavigator = true;\n        component = createComponentForStaticNavigation(\n          screen,\n          `${name}Navigator`\n        );\n      }\n    } else if (isValidElementType(item)) {\n      component = item;\n    } else if ('config' in item) {\n      isNavigator = true;\n      component = createComponentForStaticNavigation(item, `${name}Navigator`);\n    }\n\n    if (component == null) {\n      throw new Error(\n        `Couldn't find a 'screen' property for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`\n      );\n    }\n\n    const element = isNavigator ? (\n      React.createElement(component, {})\n    ) : (\n      <MemoizedScreen component={component} />\n    );\n\n    return () => {\n      const shouldRender = useIf == null || useIf();\n\n      if (!shouldRender) {\n        return null;\n      }\n\n      return (\n        <Screen key={name} name={name} {...props}>\n          {() => element}\n        </Screen>\n      );\n    };\n  });\n};\n\n/**\n * Create a component that renders a navigator based on the static configuration.\n *\n * @param tree Static navigation config.\n * @param displayName Name of the component to be displayed in React DevTools.\n * @returns A component which renders the navigator.\n */\nexport function createComponentForStaticNavigation(\n  tree: StaticNavigation<any, any, any>,\n  displayName: string\n): React.ComponentType<{}> {\n  const { Navigator, Group, Screen, config } = tree;\n  const { screens, groups, ...rest } = config;\n\n  if (screens == null && groups == null) {\n    throw new Error(\n      \"Couldn't find a 'screens' or 'groups' property. Make sure to define your screens under a 'screens' property in the configuration.\"\n    );\n  }\n\n  const items: (() => React.JSX.Element | null)[] = [];\n\n  // Loop through the config to find screens and groups\n  // So we add the screens and groups in the same order as they are defined\n  for (const key in config) {\n    if (key === 'screens' && screens) {\n      items.push(...getItemsFromScreens(Screen, screens));\n    }\n\n    if (key === 'groups' && groups) {\n      items.push(\n        ...Object.entries(groups).map(([key, { if: useIf, ...group }]) => {\n          const groupItems = getItemsFromScreens(Screen, group.screens);\n\n          return () => {\n            // Call unconditionally since screen configs may contain `useIf` hooks\n            const children = groupItems.map((item) => item());\n\n            const shouldRender = useIf == null || useIf();\n\n            if (!shouldRender) {\n              return null;\n            }\n\n            return (\n              <Group navigationKey={key} {...group} key={key}>\n                {children}\n              </Group>\n            );\n          };\n        })\n      );\n    }\n  }\n\n  const NavigatorComponent = () => {\n    const children = items.map((item) => item());\n\n    return <Navigator {...rest}>{children}</Navigator>;\n  };\n\n  NavigatorComponent.displayName = displayName;\n\n  return NavigatorComponent;\n}\n\ntype TreeForPathConfig = {\n  config: {\n    initialRouteName?: string;\n    screens?: StaticConfigScreens<\n      ParamListBase,\n      NavigationState,\n      {},\n      EventMapBase,\n      Record<string, unknown>\n    >;\n    groups?: {\n      [key: string]: {\n        screens: StaticConfigScreens<\n          ParamListBase,\n          NavigationState,\n          {},\n          EventMapBase,\n          Record<string, unknown>\n        >;\n      };\n    };\n  };\n};\n\n/**\n * Create a path config object from a static navigation config for deep linking.\n *\n * @param tree Static navigation config.\n * @param options Additional options from `linking.config`.\n * @param auto Whether to automatically generate paths for leaf screens.\n * @returns Path config object to use in linking config.\n *\n * @example\n * ```js\n * const config = {\n *   screens: {\n *     Home: {\n *       screens: createPathConfigForStaticNavigation(HomeTabs),\n *     },\n *   },\n * };\n * ```\n */\nexport function createPathConfigForStaticNavigation(\n  tree: TreeForPathConfig,\n  options?: {\n    initialRouteName?: string;\n  },\n  auto?: boolean\n) {\n  let initialScreenConfig: PathConfig<ParamListBase> | undefined;\n\n  const createPathConfigForTree = (\n    t: TreeForPathConfig,\n    o: { initialRouteName?: string } | undefined,\n    // If a screen is a leaf node, but inside a screen with path,\n    // It should not be used for initial detection\n    skipInitialDetection: boolean\n  ) => {\n    const createPathConfigForScreens = (\n      screens: StaticConfigScreens<\n        ParamListBase,\n        NavigationState,\n        {},\n        EventMapBase,\n        Record<string, unknown>\n      >,\n      initialRouteName: string | undefined\n    ) => {\n      return Object.fromEntries(\n        Object.entries(screens)\n          // Re-order to move the initial route to the front\n          // This way we can detect the initial route correctly\n          .sort(([a], [b]) => {\n            if (a === initialRouteName) {\n              return -1;\n            }\n\n            if (b === initialRouteName) {\n              return 1;\n            }\n\n            return 0;\n          })\n          .map(([key, item]) => {\n            const screenConfig: PathConfig<ParamListBase> = {};\n\n            if ('linking' in item) {\n              if (typeof item.linking === 'string') {\n                screenConfig.path = item.linking;\n              } else {\n                Object.assign(screenConfig, item.linking);\n              }\n\n              if (typeof screenConfig.path === 'string') {\n                screenConfig.path = screenConfig.path\n                  .replace(/^\\//, '') // Remove extra leading slash\n                  .replace(/\\/$/, ''); // Remove extra trailing slash\n              }\n            }\n\n            let screens;\n\n            const skipInitialDetectionInChild =\n              skipInitialDetection ||\n              (screenConfig.path != null && screenConfig.path !== '');\n\n            if ('config' in item) {\n              screens = createPathConfigForTree(\n                item,\n                undefined,\n                skipInitialDetectionInChild\n              );\n            } else if (\n              'screen' in item &&\n              'config' in item.screen &&\n              (item.screen.config.screens || item.screen.config.groups)\n            ) {\n              screens = createPathConfigForTree(\n                item.screen,\n                undefined,\n                skipInitialDetectionInChild\n              );\n            }\n\n            if (screens) {\n              screenConfig.screens = screens;\n            }\n\n            if (\n              auto &&\n              !screenConfig.screens &&\n              // Skip generating path for screens that specify linking config as `undefined` or `null` explicitly\n              !('linking' in item && item.linking == null)\n            ) {\n              if (screenConfig.path != null) {\n                if (!skipInitialDetection && screenConfig.path === '') {\n                  // We encounter a leaf screen with empty path,\n                  // Clear the initial screen config as it's not needed anymore\n                  initialScreenConfig = undefined;\n                }\n              } else {\n                if (!skipInitialDetection && initialScreenConfig == null) {\n                  initialScreenConfig = screenConfig;\n                }\n\n                screenConfig.path = key\n                  .replace(/([A-Z]+)/g, '-$1')\n                  .replace(/^-/, '')\n                  .toLowerCase();\n              }\n            }\n\n            return [key, screenConfig] as const;\n          })\n          .filter(([, screen]) => Object.keys(screen).length > 0)\n      );\n    };\n\n    const screens = {};\n\n    // Loop through the config to find screens and groups\n    // So we add the screens and groups in the same order as they are defined\n    for (const key in t.config) {\n      if (key === 'screens' && t.config.screens) {\n        Object.assign(\n          screens,\n          createPathConfigForScreens(\n            t.config.screens,\n            o?.initialRouteName ?? t.config.initialRouteName\n          )\n        );\n      }\n\n      if (key === 'groups' && t.config.groups) {\n        Object.entries(t.config.groups).forEach(([, group]) => {\n          Object.assign(\n            screens,\n            createPathConfigForScreens(\n              group.screens,\n              o?.initialRouteName ?? t.config.initialRouteName\n            )\n          );\n        });\n      }\n    }\n\n    if (Object.keys(screens).length === 0) {\n      return undefined;\n    }\n\n    return screens;\n  };\n\n  const screens = createPathConfigForTree(tree, options, false);\n\n  if (auto && initialScreenConfig) {\n    initialScreenConfig.path = '';\n  }\n\n  return screens;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}