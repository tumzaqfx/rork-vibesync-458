{"ast":null,"code":"function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}import{State}from'../../State';import GestureHandler from'./GestureHandler';import RotationGestureDetector from'../detectors/RotationGestureDetector';const ROTATION_RECOGNITION_THRESHOLD=Math.PI/36;export default class RotationGestureHandler extends GestureHandler{constructor(...args){super(...args);_defineProperty(this,\"rotation\",0);_defineProperty(this,\"velocity\",0);_defineProperty(this,\"cachedAnchorX\",0);_defineProperty(this,\"cachedAnchorY\",0);_defineProperty(this,\"rotationGestureListener\",{onRotationBegin:_detector=>true,onRotation:detector=>{const previousRotation=this.rotation;this.rotation+=detector.rotation;const delta=detector.timeDelta;if(delta>0){this.velocity=(this.rotation-previousRotation)/delta;}if(Math.abs(this.rotation)>=ROTATION_RECOGNITION_THRESHOLD&&this.state===State.BEGAN){this.activate();}return true;},onRotationEnd:_detector=>{this.end();}});_defineProperty(this,\"rotationGestureDetector\",new RotationGestureDetector(this.rotationGestureListener));}init(ref,propsRef){super.init(ref,propsRef);this.shouldCancelWhenOutside=false;}transformNativeEvent(){return{rotation:this.rotation?this.rotation:0,anchorX:this.getAnchorX(),anchorY:this.getAnchorY(),velocity:this.velocity?this.velocity:0};}getAnchorX(){const anchorX=this.rotationGestureDetector.anchorX;return anchorX?anchorX:this.cachedAnchorX;}getAnchorY(){const anchorY=this.rotationGestureDetector.anchorY;return anchorY?anchorY:this.cachedAnchorY;}onPointerDown(event){this.tracker.addToTracker(event);super.onPointerDown(event);this.tryToSendTouchEvent(event);}onPointerAdd(event){this.tracker.addToTracker(event);super.onPointerAdd(event);this.tryBegin();this.rotationGestureDetector.onTouchEvent(event,this.tracker);}onPointerMove(event){if(this.tracker.trackedPointersCount<2){return;}if(this.getAnchorX()){this.cachedAnchorX=this.getAnchorX();}if(this.getAnchorY()){this.cachedAnchorY=this.getAnchorY();}this.tracker.track(event);this.rotationGestureDetector.onTouchEvent(event,this.tracker);super.onPointerMove(event);}onPointerOutOfBounds(event){if(this.tracker.trackedPointersCount<2){return;}if(this.getAnchorX()){this.cachedAnchorX=this.getAnchorX();}if(this.getAnchorY()){this.cachedAnchorY=this.getAnchorY();}this.tracker.track(event);this.rotationGestureDetector.onTouchEvent(event,this.tracker);super.onPointerOutOfBounds(event);}onPointerUp(event){super.onPointerUp(event);this.tracker.removeFromTracker(event.pointerId);this.rotationGestureDetector.onTouchEvent(event,this.tracker);if(this.state!==State.ACTIVE){return;}if(this.state===State.ACTIVE){this.end();}else{this.fail();}}onPointerRemove(event){super.onPointerRemove(event);this.rotationGestureDetector.onTouchEvent(event,this.tracker);this.tracker.removeFromTracker(event.pointerId);}tryBegin(){if(this.state!==State.UNDETERMINED){return;}this.begin();}onReset(){if(this.state===State.ACTIVE){return;}this.rotation=0;this.velocity=0;this.rotationGestureDetector.reset();}}","map":{"version":3,"names":["State","GestureHandler","RotationGestureDetector","ROTATION_RECOGNITION_THRESHOLD","Math","PI","RotationGestureHandler","constructor","args","_defineProperty","onRotationBegin","_detector","onRotation","detector","previousRotation","rotation","delta","timeDelta","velocity","abs","state","BEGAN","activate","onRotationEnd","end","rotationGestureListener","init","ref","propsRef","shouldCancelWhenOutside","transformNativeEvent","anchorX","getAnchorX","anchorY","getAnchorY","rotationGestureDetector","cachedAnchorX","cachedAnchorY","onPointerDown","event","tracker","addToTracker","tryToSendTouchEvent","onPointerAdd","tryBegin","onTouchEvent","onPointerMove","trackedPointersCount","track","onPointerOutOfBounds","onPointerUp","removeFromTracker","pointerId","ACTIVE","fail","onPointerRemove","UNDETERMINED","begin","onReset","reset"],"sources":["/home/user/rork-vibesync-458/node_modules/react-native-gesture-handler/lib/module/web/handlers/RotationGestureHandler.ts"],"sourcesContent":["import { State } from '../../State';\nimport { AdaptedEvent } from '../interfaces';\n\nimport GestureHandler from './GestureHandler';\nimport RotationGestureDetector, {\n  RotationGestureListener,\n} from '../detectors/RotationGestureDetector';\n\nconst ROTATION_RECOGNITION_THRESHOLD = Math.PI / 36;\n\nexport default class RotationGestureHandler extends GestureHandler {\n  private rotation = 0;\n  private velocity = 0;\n\n  private cachedAnchorX = 0;\n  private cachedAnchorY = 0;\n\n  private rotationGestureListener: RotationGestureListener = {\n    onRotationBegin: (_detector: RotationGestureDetector): boolean => true,\n    onRotation: (detector: RotationGestureDetector): boolean => {\n      const previousRotation: number = this.rotation;\n      this.rotation += detector.rotation;\n\n      const delta = detector.timeDelta;\n\n      if (delta > 0) {\n        this.velocity = (this.rotation - previousRotation) / delta;\n      }\n\n      if (\n        Math.abs(this.rotation) >= ROTATION_RECOGNITION_THRESHOLD &&\n        this.state === State.BEGAN\n      ) {\n        this.activate();\n      }\n\n      return true;\n    },\n    onRotationEnd: (_detector: RotationGestureDetector): void => {\n      this.end();\n    },\n  };\n\n  private rotationGestureDetector: RotationGestureDetector =\n    new RotationGestureDetector(this.rotationGestureListener);\n\n  public init(ref: number, propsRef: React.RefObject<unknown>): void {\n    super.init(ref, propsRef);\n\n    this.shouldCancelWhenOutside = false;\n  }\n\n  protected transformNativeEvent() {\n    return {\n      rotation: this.rotation ? this.rotation : 0,\n      anchorX: this.getAnchorX(),\n      anchorY: this.getAnchorY(),\n      velocity: this.velocity ? this.velocity : 0,\n    };\n  }\n\n  public getAnchorX(): number {\n    const anchorX = this.rotationGestureDetector.anchorX;\n\n    return anchorX ? anchorX : this.cachedAnchorX;\n  }\n\n  public getAnchorY(): number {\n    const anchorY = this.rotationGestureDetector.anchorY;\n\n    return anchorY ? anchorY : this.cachedAnchorY;\n  }\n\n  protected onPointerDown(event: AdaptedEvent): void {\n    this.tracker.addToTracker(event);\n    super.onPointerDown(event);\n\n    this.tryToSendTouchEvent(event);\n  }\n\n  protected onPointerAdd(event: AdaptedEvent): void {\n    this.tracker.addToTracker(event);\n    super.onPointerAdd(event);\n\n    this.tryBegin();\n    this.rotationGestureDetector.onTouchEvent(event, this.tracker);\n  }\n\n  protected onPointerMove(event: AdaptedEvent): void {\n    if (this.tracker.trackedPointersCount < 2) {\n      return;\n    }\n\n    if (this.getAnchorX()) {\n      this.cachedAnchorX = this.getAnchorX();\n    }\n    if (this.getAnchorY()) {\n      this.cachedAnchorY = this.getAnchorY();\n    }\n\n    this.tracker.track(event);\n\n    this.rotationGestureDetector.onTouchEvent(event, this.tracker);\n\n    super.onPointerMove(event);\n  }\n\n  protected onPointerOutOfBounds(event: AdaptedEvent): void {\n    if (this.tracker.trackedPointersCount < 2) {\n      return;\n    }\n\n    if (this.getAnchorX()) {\n      this.cachedAnchorX = this.getAnchorX();\n    }\n    if (this.getAnchorY()) {\n      this.cachedAnchorY = this.getAnchorY();\n    }\n\n    this.tracker.track(event);\n\n    this.rotationGestureDetector.onTouchEvent(event, this.tracker);\n\n    super.onPointerOutOfBounds(event);\n  }\n\n  protected onPointerUp(event: AdaptedEvent): void {\n    super.onPointerUp(event);\n    this.tracker.removeFromTracker(event.pointerId);\n    this.rotationGestureDetector.onTouchEvent(event, this.tracker);\n\n    if (this.state !== State.ACTIVE) {\n      return;\n    }\n\n    if (this.state === State.ACTIVE) {\n      this.end();\n    } else {\n      this.fail();\n    }\n  }\n\n  protected onPointerRemove(event: AdaptedEvent): void {\n    super.onPointerRemove(event);\n    this.rotationGestureDetector.onTouchEvent(event, this.tracker);\n    this.tracker.removeFromTracker(event.pointerId);\n  }\n\n  protected tryBegin(): void {\n    if (this.state !== State.UNDETERMINED) {\n      return;\n    }\n\n    this.begin();\n  }\n\n  protected onReset(): void {\n    if (this.state === State.ACTIVE) {\n      return;\n    }\n\n    this.rotation = 0;\n    this.velocity = 0;\n    this.rotationGestureDetector.reset();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}