{"ast":null,"code":"import{PointerType}from'../PointerType';export function isPointerInBounds(view,{x,y}){const rect=view.getBoundingClientRect();return x>=rect.left&&x<=rect.right&&y>=rect.top&&y<=rect.bottom;}export const PointerTypeMapping=new Map([['mouse',PointerType.MOUSE],['touch',PointerType.TOUCH],['pen',PointerType.STYLUS],['none',PointerType.OTHER]]);export const degToRad=degrees=>degrees*Math.PI/180;export const coneToDeviation=degrees=>Math.cos(degToRad(degrees/2));export function calculateViewScale(view){var _RegExp$exec;const styles=getComputedStyle(view);const resultScales={scaleX:1,scaleY:1};if(styles.scale!==undefined&&styles.scale!=='none'){const scales=styles.scale.split(' ');if(scales[0]){resultScales.scaleX=parseFloat(scales[0]);}resultScales.scaleY=scales[1]?parseFloat(scales[1]):parseFloat(scales[0]);}const matrixElements=(_RegExp$exec=new RegExp(/matrix\\((.+)\\)/).exec(styles.transform))===null||_RegExp$exec===void 0?void 0:_RegExp$exec[1];if(matrixElements){const matrixElementsArray=matrixElements.split(', ');resultScales.scaleX*=parseFloat(matrixElementsArray[0]);resultScales.scaleY*=parseFloat(matrixElementsArray[3]);}return resultScales;}export function tryExtractStylusData(event){const pointerType=PointerTypeMapping.get(event.pointerType);if(pointerType!==PointerType.STYLUS){return;}const eventAzimuthAngle=event.azimuthAngle;const eventAltitudeAngle=event.altitudeAngle;if(event.tiltX===0&&event.tiltY===0){if(eventAzimuthAngle===undefined||eventAltitudeAngle===undefined){return{tiltX:0,tiltY:0,azimuthAngle:Math.PI/2,altitudeAngle:Math.PI/2,pressure:event.pressure};}const{tiltX,tiltY}=spherical2tilt(eventAltitudeAngle,eventAzimuthAngle);return{tiltX,tiltY,azimuthAngle:eventAzimuthAngle,altitudeAngle:eventAltitudeAngle,pressure:event.pressure};}const{altitudeAngle,azimuthAngle}=tilt2spherical(event.tiltX,event.tiltY);return{tiltX:event.tiltX,tiltY:event.tiltY,azimuthAngle,altitudeAngle,pressure:event.pressure};}function tilt2spherical(tiltX,tiltY){const tiltXrad=tiltX*Math.PI/180;const tiltYrad=tiltY*Math.PI/180;let azimuthAngle=0;if(tiltX===0){if(tiltY>0){azimuthAngle=Math.PI/2;}else if(tiltY<0){azimuthAngle=3*Math.PI/2;}}else if(tiltY===0){if(tiltX<0){azimuthAngle=Math.PI;}}else if(Math.abs(tiltX)===90||Math.abs(tiltY)===90){azimuthAngle=0;}else{const tanX=Math.tan(tiltXrad);const tanY=Math.tan(tiltYrad);azimuthAngle=Math.atan2(tanY,tanX);if(azimuthAngle<0){azimuthAngle+=2*Math.PI;}}let altitudeAngle=0;if(Math.abs(tiltX)===90||Math.abs(tiltY)===90){altitudeAngle=0;}else if(tiltX===0){altitudeAngle=Math.PI/2-Math.abs(tiltYrad);}else if(tiltY===0){altitudeAngle=Math.PI/2-Math.abs(tiltXrad);}else{altitudeAngle=Math.atan(1.0/Math.sqrt(Math.pow(Math.tan(tiltXrad),2)+Math.pow(Math.tan(tiltYrad),2)));}return{altitudeAngle:altitudeAngle,azimuthAngle:azimuthAngle};}function spherical2tilt(altitudeAngle,azimuthAngle){const radToDeg=180/Math.PI;let tiltXrad=0;let tiltYrad=0;if(altitudeAngle===0){if(azimuthAngle===0||azimuthAngle===2*Math.PI){tiltXrad=Math.PI/2;}if(azimuthAngle===Math.PI/2){tiltYrad=Math.PI/2;}if(azimuthAngle===Math.PI){tiltXrad=-Math.PI/2;}if(azimuthAngle===3*Math.PI/2){tiltYrad=-Math.PI/2;}if(azimuthAngle>0&&azimuthAngle<Math.PI/2){tiltXrad=Math.PI/2;tiltYrad=Math.PI/2;}if(azimuthAngle>Math.PI/2&&azimuthAngle<Math.PI){tiltXrad=-Math.PI/2;tiltYrad=Math.PI/2;}if(azimuthAngle>Math.PI&&azimuthAngle<3*Math.PI/2){tiltXrad=-Math.PI/2;tiltYrad=-Math.PI/2;}if(azimuthAngle>3*Math.PI/2&&azimuthAngle<2*Math.PI){tiltXrad=Math.PI/2;tiltYrad=-Math.PI/2;}}if(altitudeAngle!==0){const tanAlt=Math.tan(altitudeAngle);tiltXrad=Math.atan(Math.cos(azimuthAngle)/tanAlt);tiltYrad=Math.atan(Math.sin(azimuthAngle)/tanAlt);}const tiltX=Math.round(tiltXrad*radToDeg);const tiltY=Math.round(tiltYrad*radToDeg);return{tiltX,tiltY};}export const RNSVGElements=new Set(['Circle','ClipPath','Ellipse','ForeignObject','G','Image','Line','Marker','Mask','Path','Pattern','Polygon','Polyline','Rect','Svg','Symbol','TSpan','Text','TextPath','Use']);export function isRNSVGElement(viewRef){const componentClassName=Object.getPrototypeOf(viewRef).constructor.name;return RNSVGElements.has(componentClassName)&&Object.hasOwn(viewRef,'elementRef');}export function isRNSVGNode(node){var _node$ref,_Object$getPrototypeO,_node$type;if((_node$ref=node.ref)!==null&&_node$ref!==void 0&&_node$ref.rngh){return false;}return((_Object$getPrototypeO=Object.getPrototypeOf(node===null||node===void 0?void 0:node.type))===null||_Object$getPrototypeO===void 0?void 0:_Object$getPrototypeO.name)==='WebShape'||RNSVGElements.has(node===null||node===void 0?void 0:(_node$type=node.type)===null||_node$type===void 0?void 0:_node$type.displayName);}","map":{"version":3,"names":["PointerType","isPointerInBounds","view","x","y","rect","getBoundingClientRect","left","right","top","bottom","PointerTypeMapping","Map","MOUSE","TOUCH","STYLUS","OTHER","degToRad","degrees","Math","PI","coneToDeviation","cos","calculateViewScale","_RegExp$exec","styles","getComputedStyle","resultScales","scaleX","scaleY","scale","undefined","scales","split","parseFloat","matrixElements","RegExp","exec","transform","matrixElementsArray","tryExtractStylusData","event","pointerType","get","eventAzimuthAngle","azimuthAngle","eventAltitudeAngle","altitudeAngle","tiltX","tiltY","pressure","spherical2tilt","tilt2spherical","tiltXrad","tiltYrad","abs","tanX","tan","tanY","atan2","atan","sqrt","pow","radToDeg","tanAlt","sin","round","RNSVGElements","Set","isRNSVGElement","viewRef","componentClassName","Object","getPrototypeOf","constructor","name","has","hasOwn","isRNSVGNode","node","_node$ref","_Object$getPrototypeO","_node$type","ref","rngh","type","displayName"],"sources":["/home/user/rork-vibesync-458/node_modules/react-native-gesture-handler/lib/module/web/utils.ts"],"sourcesContent":["import { PointerType } from '../PointerType';\nimport type {\n  GestureHandlerRef,\n  Point,\n  StylusData,\n  SVGRef,\n} from './interfaces';\n\nexport function isPointerInBounds(view: HTMLElement, { x, y }: Point): boolean {\n  const rect: DOMRect = view.getBoundingClientRect();\n\n  return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;\n}\n\nexport const PointerTypeMapping = new Map<string, PointerType>([\n  ['mouse', PointerType.MOUSE],\n  ['touch', PointerType.TOUCH],\n  ['pen', PointerType.STYLUS],\n  ['none', PointerType.OTHER],\n]);\n\nexport const degToRad = (degrees: number) => (degrees * Math.PI) / 180;\n\nexport const coneToDeviation = (degrees: number) =>\n  Math.cos(degToRad(degrees / 2));\n\nexport function calculateViewScale(view: HTMLElement) {\n  const styles = getComputedStyle(view);\n\n  const resultScales = {\n    scaleX: 1,\n    scaleY: 1,\n  };\n\n  // Get scales from scale property\n  if (styles.scale !== undefined && styles.scale !== 'none') {\n    const scales = styles.scale.split(' ');\n\n    if (scales[0]) {\n      resultScales.scaleX = parseFloat(scales[0]);\n    }\n\n    resultScales.scaleY = scales[1]\n      ? parseFloat(scales[1])\n      : parseFloat(scales[0]);\n  }\n\n  // Get scales from transform property\n  const matrixElements = new RegExp(/matrix\\((.+)\\)/).exec(\n    styles.transform\n  )?.[1];\n\n  if (matrixElements) {\n    const matrixElementsArray = matrixElements.split(', ');\n\n    resultScales.scaleX *= parseFloat(matrixElementsArray[0]);\n    resultScales.scaleY *= parseFloat(matrixElementsArray[3]);\n  }\n\n  return resultScales;\n}\n\nexport function tryExtractStylusData(\n  event: PointerEvent\n): StylusData | undefined {\n  const pointerType = PointerTypeMapping.get(event.pointerType);\n\n  if (pointerType !== PointerType.STYLUS) {\n    return;\n  }\n\n  // @ts-ignore This property exists (https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent#instance_properties)\n  const eventAzimuthAngle: number | undefined = event.azimuthAngle;\n  // @ts-ignore This property exists (https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent#instance_properties)\n  const eventAltitudeAngle: number | undefined = event.altitudeAngle;\n\n  if (event.tiltX === 0 && event.tiltY === 0) {\n    // If we are in this branch, it means that either tilt properties are not supported and we have to calculate them from altitude and azimuth angles,\n    // or stylus is perpendicular to the screen and we can use altitude / azimuth instead of tilt\n\n    // If azimuth and altitude are undefined in this branch, it means that we are either perpendicular to the screen,\n    // or that none of the position sets is supported. In that case, we can treat stylus as perpendicular\n    if (eventAzimuthAngle === undefined || eventAltitudeAngle === undefined) {\n      return {\n        tiltX: 0,\n        tiltY: 0,\n        azimuthAngle: Math.PI / 2,\n        altitudeAngle: Math.PI / 2,\n        pressure: event.pressure,\n      };\n    }\n\n    const { tiltX, tiltY } = spherical2tilt(\n      eventAltitudeAngle,\n      eventAzimuthAngle\n    );\n\n    return {\n      tiltX,\n      tiltY,\n      azimuthAngle: eventAzimuthAngle,\n      altitudeAngle: eventAltitudeAngle,\n      pressure: event.pressure,\n    };\n  }\n\n  const { altitudeAngle, azimuthAngle } = tilt2spherical(\n    event.tiltX,\n    event.tiltY\n  );\n\n  return {\n    tiltX: event.tiltX,\n    tiltY: event.tiltY,\n    azimuthAngle,\n    altitudeAngle,\n    pressure: event.pressure,\n  };\n}\n\n// `altitudeAngle` and `azimuthAngle` are experimental properties, which are not supported on Firefox and Safari.\n// Given that, we use `tilt` properties and algorithm that converts one value to another.\n//\n// Source: https://w3c.github.io/pointerevents/#converting-between-tiltx-tilty-and-altitudeangle-azimuthangle\nfunction tilt2spherical(tiltX: number, tiltY: number) {\n  const tiltXrad = (tiltX * Math.PI) / 180;\n  const tiltYrad = (tiltY * Math.PI) / 180;\n\n  // calculate azimuth angle\n  let azimuthAngle = 0;\n\n  if (tiltX === 0) {\n    if (tiltY > 0) {\n      azimuthAngle = Math.PI / 2;\n    } else if (tiltY < 0) {\n      azimuthAngle = (3 * Math.PI) / 2;\n    }\n  } else if (tiltY === 0) {\n    if (tiltX < 0) {\n      azimuthAngle = Math.PI;\n    }\n  } else if (Math.abs(tiltX) === 90 || Math.abs(tiltY) === 90) {\n    // not enough information to calculate azimuth\n    azimuthAngle = 0;\n  } else {\n    // Non-boundary case: neither tiltX nor tiltY is equal to 0 or +-90\n    const tanX = Math.tan(tiltXrad);\n    const tanY = Math.tan(tiltYrad);\n\n    azimuthAngle = Math.atan2(tanY, tanX);\n    if (azimuthAngle < 0) {\n      azimuthAngle += 2 * Math.PI;\n    }\n  }\n\n  // calculate altitude angle\n  let altitudeAngle = 0;\n\n  if (Math.abs(tiltX) === 90 || Math.abs(tiltY) === 90) {\n    altitudeAngle = 0;\n  } else if (tiltX === 0) {\n    altitudeAngle = Math.PI / 2 - Math.abs(tiltYrad);\n  } else if (tiltY === 0) {\n    altitudeAngle = Math.PI / 2 - Math.abs(tiltXrad);\n  } else {\n    // Non-boundary case: neither tiltX nor tiltY is equal to 0 or +-90\n    altitudeAngle = Math.atan(\n      1.0 /\n        Math.sqrt(\n          Math.pow(Math.tan(tiltXrad), 2) + Math.pow(Math.tan(tiltYrad), 2)\n        )\n    );\n  }\n\n  return { altitudeAngle: altitudeAngle, azimuthAngle: azimuthAngle };\n}\n\n// If we are on a platform that doesn't support `tiltX` and `tiltY`, we have to calculate them from `altitude` and `azimuth` angles.\n//\n// Source: https://w3c.github.io/pointerevents/#converting-between-tiltx-tilty-and-altitudeangle-azimuthangle\nfunction spherical2tilt(altitudeAngle: number, azimuthAngle: number) {\n  const radToDeg = 180 / Math.PI;\n\n  let tiltXrad = 0;\n  let tiltYrad = 0;\n\n  if (altitudeAngle === 0) {\n    // the pen is in the X-Y plane\n    if (azimuthAngle === 0 || azimuthAngle === 2 * Math.PI) {\n      // pen is on positive X axis\n      tiltXrad = Math.PI / 2;\n    }\n    if (azimuthAngle === Math.PI / 2) {\n      // pen is on positive Y axis\n      tiltYrad = Math.PI / 2;\n    }\n    if (azimuthAngle === Math.PI) {\n      // pen is on negative X axis\n      tiltXrad = -Math.PI / 2;\n    }\n    if (azimuthAngle === (3 * Math.PI) / 2) {\n      // pen is on negative Y axis\n      tiltYrad = -Math.PI / 2;\n    }\n    if (azimuthAngle > 0 && azimuthAngle < Math.PI / 2) {\n      tiltXrad = Math.PI / 2;\n      tiltYrad = Math.PI / 2;\n    }\n    if (azimuthAngle > Math.PI / 2 && azimuthAngle < Math.PI) {\n      tiltXrad = -Math.PI / 2;\n      tiltYrad = Math.PI / 2;\n    }\n    if (azimuthAngle > Math.PI && azimuthAngle < (3 * Math.PI) / 2) {\n      tiltXrad = -Math.PI / 2;\n      tiltYrad = -Math.PI / 2;\n    }\n    if (azimuthAngle > (3 * Math.PI) / 2 && azimuthAngle < 2 * Math.PI) {\n      tiltXrad = Math.PI / 2;\n      tiltYrad = -Math.PI / 2;\n    }\n  }\n\n  if (altitudeAngle !== 0) {\n    const tanAlt = Math.tan(altitudeAngle);\n\n    tiltXrad = Math.atan(Math.cos(azimuthAngle) / tanAlt);\n    tiltYrad = Math.atan(Math.sin(azimuthAngle) / tanAlt);\n  }\n\n  const tiltX = Math.round(tiltXrad * radToDeg);\n  const tiltY = Math.round(tiltYrad * radToDeg);\n\n  return { tiltX, tiltY };\n}\n\nexport const RNSVGElements = new Set([\n  'Circle',\n  'ClipPath',\n  'Ellipse',\n  'ForeignObject',\n  'G',\n  'Image',\n  'Line',\n  'Marker',\n  'Mask',\n  'Path',\n  'Pattern',\n  'Polygon',\n  'Polyline',\n  'Rect',\n  'Svg',\n  'Symbol',\n  'TSpan',\n  'Text',\n  'TextPath',\n  'Use',\n]);\n\n// This function helps us determine whether given node is SVGElement or not. In our implementation of\n// findNodeHandle, we can encounter such element in 2 forms - SVG tag or ref to SVG Element. Since Gesture Handler\n// does not depend on SVG, we use our simplified SVGRef type that has `elementRef` field. This is something that is present\n// in actual SVG ref object.\n//\n// In order to make sure that node passed into this function is in fact SVG element, first we check if its constructor name\n// corresponds to one of the possible SVG elements. Then we also check if `elementRef` field exists.\n// By doing both steps we decrease probability of detecting situations where, for example, user makes custom `Circle` and\n// we treat it as SVG.\nexport function isRNSVGElement(viewRef: SVGRef | GestureHandlerRef) {\n  const componentClassName = Object.getPrototypeOf(viewRef).constructor.name;\n\n  return (\n    RNSVGElements.has(componentClassName) &&\n    Object.hasOwn(viewRef, 'elementRef')\n  );\n}\n\n// This function checks if given node is SVGElement. Unlike the function above, this one\n// operates on React Nodes, not DOM nodes.\n//\n// Second condition was introduced to handle case where SVG element was wrapped with\n// `createAnimatedComponent` from Reanimated.\nexport function isRNSVGNode(node: any) {\n  // If `ref` has `rngh` field, it means that component comes from Gesture Handler. This is a special case for\n  // `Text` component, which is present in `RNSVGElements` set, yet we don't want to treat it as SVG.\n  if (node.ref?.rngh) {\n    return false;\n  }\n\n  return (\n    Object.getPrototypeOf(node?.type)?.name === 'WebShape' ||\n    RNSVGElements.has(node?.type?.displayName)\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}