{"ast":null,"code":"\"use strict\";var _objectWithoutPropertiesLoose=require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\");const _excluded=[\"path\"];var __createBinding=this&&this.__createBinding||(Object.create?function(o,m,k,k2){if(k2===undefined)k2=k;var desc=Object.getOwnPropertyDescriptor(m,k);if(!desc||(\"get\"in desc?!m.__esModule:desc.writable||desc.configurable)){desc={enumerable:true,get:function(){return m[k];}};}Object.defineProperty(o,k2,desc);}:function(o,m,k,k2){if(k2===undefined)k2=k;o[k2]=m[k];});var __setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(o,v){Object.defineProperty(o,\"default\",{enumerable:true,value:v});}:function(o,v){o[\"default\"]=v;});var __importStar=this&&this.__importStar||function(){var ownKeys=function(o){ownKeys=Object.getOwnPropertyNames||function(o){var ar=[];for(var k in o)if(Object.prototype.hasOwnProperty.call(o,k))ar[ar.length]=k;return ar;};return ownKeys(o);};return function(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k=ownKeys(mod),i=0;i<k.length;i++)if(k[i]!==\"default\")__createBinding(result,mod,k[i]);__setModuleDefault(result,mod);return result;};}();var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{\"default\":mod};};Object.defineProperty(exports,\"__esModule\",{value:true});exports.getStateFromPath=getStateFromPath;const native_1=require(\"@react-navigation/native\");const escape_string_regexp_1=__importDefault(require(\"escape-string-regexp\"));const findFocusedRoute_1=require(\"./findFocusedRoute\");const expo=__importStar(require(\"./getStateFromPath-forks\"));const constants_1=require(\"../constants\");function getStateFromPath(path,options,segments=[]){const{initialRoutes,configs,configWithRegexes}=getConfigResources(options,segments);const screens=options?.screens;const expoPath=expo.getUrlWithReactNavigationConcessions(path);let remaining=expo.cleanPath(expoPath.nonstandardPathname);const prefix=options?.path?.replace(/^\\//,'');if(prefix){const normalizedPrefix=prefix.endsWith('/')?prefix:`${prefix}/`;if(!remaining.startsWith(normalizedPrefix)){return undefined;}remaining=remaining.replace(normalizedPrefix,'');}if(screens===undefined){const routes=remaining.split('/').filter(Boolean).map(segment=>{const name=decodeURIComponent(segment);return{name};});if(routes.length){return createNestedStateObject(expoPath,routes,initialRoutes,[],expoPath.url.hash);}return undefined;}if(remaining==='/'){const match=expo.matchForEmptyPath(configWithRegexes);if(match){return createNestedStateObject(expoPath,match.routeNames.map(name=>({name})),initialRoutes,configs,expoPath.url.hash);}return undefined;}let result;let current;const{routes,remainingPath}=matchAgainstConfigs(remaining,configWithRegexes);if(routes!==undefined){current=createNestedStateObject(expoPath,routes,initialRoutes,configs,expoPath.url.hash);remaining=remainingPath;result=current;}if(current==null||result==null){return undefined;}return result;}let cachedConfigResources=[undefined,prepareConfigResources()];function getConfigResources(options,previousSegments){cachedConfigResources=[options,prepareConfigResources(options,previousSegments)];return cachedConfigResources[1];}function prepareConfigResources(options,previousSegments){if(options){(0,native_1.validatePathConfig)(options);}const initialRoutes=getInitialRoutes(options);const configs=getNormalizedConfigs(initialRoutes,options?.screens,previousSegments);checkForDuplicatedConfigs(configs);const configWithRegexes=getConfigsWithRegexes(configs);return{initialRoutes,configs,configWithRegexes};}function getInitialRoutes(options){const initialRoutes=[];if(options?.initialRouteName){initialRoutes.push({initialRouteName:options.initialRouteName,parentScreens:[]});}return initialRoutes;}function getNormalizedConfigs(initialRoutes,screens={},previousSegments){return[].concat(...Object.keys(screens).map(key=>createNormalizedConfigs(key,screens,[],initialRoutes,[]))).map(expo.appendIsInitial(initialRoutes)).sort(expo.getRouteConfigSorter(previousSegments));}function checkForDuplicatedConfigs(configs){configs.reduce((acc,config)=>{if(acc[config.pattern]){const a=acc[config.pattern].routeNames;const b=config.routeNames;const intersects=a.length>b.length?b.every((it,i)=>a[i]===it):a.every((it,i)=>b[i]===it);if(!intersects){throw new Error(`Found conflicting screens with the same pattern. The pattern '${config.pattern}' resolves to both '${a.join(' > ')}' and '${b.join(' > ')}'. Patterns must be unique and cannot resolve to more than one screen.`);}}return Object.assign(acc,{[config.pattern]:config});},{});}function getConfigsWithRegexes(configs){return configs.map(c=>Object.assign({},c,{regex:expo.configRegExp(c)}));}const joinPaths=(...paths)=>[].concat(...paths.map(p=>p.split('/'))).filter(Boolean).join('/');const matchAgainstConfigs=(remaining,configs)=>{let routes;let remainingPath=remaining;const allParams=Object.create(null);for(const config of configs){if(!config.regex){continue;}const match=remainingPath.match(config.regex);if(match){const matchResult=config.pattern?.split('/').reduce((acc,p,index)=>{if(!expo.isDynamicPart(p)){return acc;}acc.pos+=1;const decodedParamSegment=expo.safelyDecodeURIComponent(match[(acc.pos+1)*2].replace(/\\/$/,''));Object.assign(acc.matchedParams,{[p]:Object.assign(acc.matchedParams[p]||{},{[index]:decodedParamSegment})});return acc;},{pos:-1,matchedParams:{}});const matchedParams=matchResult.matchedParams||{};routes=config.routeNames.map(name=>{const routeConfig=configs.find(c=>{return c.screen===name&&config.pattern.startsWith(c.pattern);});const normalizedPath=routeConfig?.path.split('/').filter(Boolean).join('/');const numInitialSegments=routeConfig?.pattern.replace(new RegExp(`${(0,escape_string_regexp_1.default)(normalizedPath)}$`),'')?.split('/').length;const params=normalizedPath?.split('/').reduce((acc,p,index)=>{if(!expo.isDynamicPart(p)){return acc;}const offset=numInitialSegments?numInitialSegments-1:0;const value=expo.getParamValue(p,matchedParams[p]?.[index+offset]);if(value){const key=expo.replacePart(p);acc[key]=routeConfig?.parse?.[key]?routeConfig.parse[key](value):value;}return acc;},{});if(params&&Object.keys(params).length){Object.assign(allParams,params);return{name,params};}return{name};});remainingPath=remainingPath.replace(match[1],'');break;}}expo.populateParams(routes,allParams);return{routes,remainingPath};};const createNormalizedConfigs=(screen,routeConfig,routeNames=[],initials,parentScreens,parentPattern)=>{const configs=[];routeNames.push(screen);parentScreens.push(screen);const config=routeConfig[screen];if(typeof config==='string'){const pattern=parentPattern?joinPaths(parentPattern,config):config;configs.push(createConfigItem(screen,routeNames,pattern,config));}else if(typeof config==='object'){let pattern;if(typeof config.path==='string'){if(config.exact&&config.path===undefined){throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");}pattern=config.exact!==true?joinPaths(parentPattern||'',config.path||''):config.path||'';if(screen!==constants_1.INTERNAL_SLOT_NAME){configs.push(createConfigItem(screen,routeNames,pattern,config.path,config.parse,config));}}if(config.screens){if(config.initialRouteName){initials.push({initialRouteName:config.initialRouteName,parentScreens});}Object.keys(config.screens).forEach(nestedConfig=>{const result=createNormalizedConfigs(nestedConfig,config.screens,routeNames,initials,[...parentScreens],pattern??parentPattern);configs.push(...result);});}}routeNames.pop();return configs;};const createConfigItem=(screen,routeNames,pattern,path,parse=undefined,config={})=>{pattern=pattern.split('/').filter(Boolean).join('/');const regex=pattern?expo.routePatternToRegex(pattern):undefined;return Object.assign({screen,regex,pattern,path,routeNames:[...routeNames],parse},expo.createConfig(screen,pattern,routeNames,config));};const findParseConfigForRoute=(routeName,flatConfig)=>{for(const config of flatConfig){if(routeName===config.routeNames[config.routeNames.length-1]){return config.parse;}}return undefined;};const findInitialRoute=(routeName,parentScreens,initialRoutes)=>{for(const config of initialRoutes){if(parentScreens.length===config.parentScreens.length){let sameParents=true;for(let i=0;i<parentScreens.length;i++){if(parentScreens[i].localeCompare(config.parentScreens[i])!==0){sameParents=false;break;}}if(sameParents){return routeName!==config.initialRouteName?config.initialRouteName:undefined;}}}return undefined;};const createStateObject=(initialRoute,route,isEmpty)=>{if(isEmpty){if(initialRoute){return{index:1,routes:[{name:initialRoute,params:route.params},route]};}else{return{routes:[route]};}}else{if(initialRoute){return{index:1,routes:[{name:initialRoute,params:route.params},Object.assign({},route,{state:{routes:[]}})]};}else{return{routes:[Object.assign({},route,{state:{routes:[]}})]};}}};const createNestedStateObject=(_ref,routes,initialRoutes,flatConfig,hash)=>{let{path}=_ref,expoURL=_objectWithoutPropertiesLoose(_ref,_excluded);let route=routes.shift();const parentScreens=[];let initialRoute=findInitialRoute(route.name,parentScreens,initialRoutes);parentScreens.push(route.name);const state=createStateObject(initialRoute,route,routes.length===0);if(routes.length>0){let nestedState=state;while(route=routes.shift()){initialRoute=findInitialRoute(route.name,parentScreens,initialRoutes);const nestedStateIndex=nestedState.index||nestedState.routes.length-1;nestedState.routes[nestedStateIndex].state=createStateObject(initialRoute,route,routes.length===0);if(routes.length>0){nestedState=nestedState.routes[nestedStateIndex].state;}parentScreens.push(route.name);}}route=(0,findFocusedRoute_1.findFocusedRoute)(state);route.path=expoURL.pathWithoutGroups;const params=expo.parseQueryParams(path,route,flatConfig?findParseConfigForRoute(route.name,flatConfig):undefined,hash);if(params){route.params=Object.assign({},route.params,params);}return state;};","map":{"version":3,"names":["exports","getStateFromPath","native_1","require","escape_string_regexp_1","__importDefault","findFocusedRoute_1","expo","__importStar","constants_1","path","options","segments","initialRoutes","configs","configWithRegexes","getConfigResources","screens","expoPath","getUrlWithReactNavigationConcessions","remaining","cleanPath","nonstandardPathname","prefix","replace","normalizedPrefix","endsWith","startsWith","undefined","routes","split","filter","Boolean","map","segment","name","decodeURIComponent","length","createNestedStateObject","url","hash","match","matchForEmptyPath","routeNames","result","current","remainingPath","matchAgainstConfigs","cachedConfigResources","prepareConfigResources","previousSegments","validatePathConfig","getInitialRoutes","getNormalizedConfigs","checkForDuplicatedConfigs","getConfigsWithRegexes","initialRouteName","push","parentScreens","concat","Object","keys","key","createNormalizedConfigs","appendIsInitial","sort","getRouteConfigSorter","reduce","acc","config","pattern","a","b","intersects","every","it","i","Error","join","assign","c","regex","configRegExp","joinPaths","paths","p","allParams","create","matchResult","index","isDynamicPart","pos","decodedParamSegment","safelyDecodeURIComponent","matchedParams","routeConfig","find","screen","normalizedPath","numInitialSegments","RegExp","default","params","offset","value","getParamValue","replacePart","parse","populateParams","initials","parentPattern","createConfigItem","exact","INTERNAL_SLOT_NAME","forEach","nestedConfig","pop","routePatternToRegex","createConfig","findParseConfigForRoute","routeName","flatConfig","findInitialRoute","sameParents","localeCompare","createStateObject","initialRoute","route","isEmpty","state","_ref","expoURL","_objectWithoutPropertiesLoose","_excluded","shift","nestedState","nestedStateIndex","findFocusedRoute","pathWithoutGroups","parseQueryParams"],"sources":["/home/user/rork-vibesync-458/node_modules/expo-router/src/fork/getStateFromPath.ts"],"sourcesContent":["import { PathConfigMap, validatePathConfig } from '@react-navigation/native';\nimport type { InitialState, NavigationState, PartialState } from '@react-navigation/routers';\nimport escape from 'escape-string-regexp';\n\nimport { findFocusedRoute } from './findFocusedRoute';\nimport type { ExpoOptions, ExpoRouteConfig } from './getStateFromPath-forks';\nimport * as expo from './getStateFromPath-forks';\nimport { INTERNAL_SLOT_NAME } from '../constants';\n\nexport type Options<ParamList extends object> = ExpoOptions & {\n  path?: string;\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n};\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\nexport type RouteConfig = ExpoRouteConfig & {\n  screen: string;\n  regex?: RegExp;\n  path: string;\n  pattern: string;\n  routeNames: string[];\n  parse?: ParseConfig;\n};\n\nexport type InitialRouteConfig = {\n  initialRouteName: string;\n  parentScreens: string[];\n};\n\nexport type ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\nexport type ParsedRoute = {\n  name: string;\n  path?: string;\n  params?: Record<string, any> | undefined;\n};\n\ntype ConfigResources = {\n  initialRoutes: InitialRouteConfig[];\n  configs: RouteConfig[];\n  configWithRegexes: RouteConfig[];\n};\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * @example\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         parse: { id: Number }\n *       }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport function getStateFromPath<ParamList extends object>(\n  path: string,\n  options?: Options<ParamList>,\n  // START FORK\n  segments: string[] = []\n  // END FORK\n): ResultState | undefined {\n  const { initialRoutes, configs, configWithRegexes } = getConfigResources(\n    options,\n    // START FORK\n    segments\n    // END FORK\n  );\n\n  const screens = options?.screens;\n\n  // START FORK\n  const expoPath = expo.getUrlWithReactNavigationConcessions(path);\n  // END FORK\n\n  // START FORK\n  let remaining = expo.cleanPath(expoPath.nonstandardPathname);\n  // let remaining = path\n  //   .replace(/\\/+/g, '/') // Replace multiple slash (//) with single ones\n  //   .replace(/^\\//, '') // Remove extra leading slash\n  //   .replace(/\\?.*$/, ''); // Remove query params which we will handle later\n\n  // // Make sure there is a trailing slash\n  // remaining = remaining.endsWith('/') ? remaining : `${remaining}/`;\n  // END FORK\n\n  const prefix = options?.path?.replace(/^\\//, ''); // Remove extra leading slash\n\n  if (prefix) {\n    // Make sure there is a trailing slash\n    const normalizedPrefix = prefix.endsWith('/') ? prefix : `${prefix}/`;\n\n    // If the path doesn't start with the prefix, it's not a match\n    if (!remaining.startsWith(normalizedPrefix)) {\n      return undefined;\n    }\n\n    // Remove the prefix from the path\n    remaining = remaining.replace(normalizedPrefix, '');\n  }\n\n  if (screens === undefined) {\n    // When no config is specified, use the path segments as route names\n    const routes = remaining\n      .split('/')\n      .filter(Boolean)\n      .map((segment) => {\n        const name = decodeURIComponent(segment);\n        return { name };\n      });\n\n    if (routes.length) {\n      return createNestedStateObject(expoPath, routes, initialRoutes, [], expoPath.url.hash);\n    }\n\n    return undefined;\n  }\n\n  if (remaining === '/') {\n    // We need to add special handling of empty path so navigation to empty path also works\n    // When handling empty path, we should only look at the root level config\n    // START FORK\n    const match = expo.matchForEmptyPath(configWithRegexes);\n    // const match = configs.find(\n    //   (config) =>\n    //     config.path === '' &&\n    //     config.routeNames.every(\n    //       // Make sure that none of the parent configs have a non-empty path defined\n    //       (name) => !configs.find((c) => c.screen === name)?.path\n    //     )\n    // );\n    // END FORK\n\n    if (match) {\n      return createNestedStateObject(\n        expoPath,\n        match.routeNames.map((name) => ({ name })),\n        initialRoutes,\n        configs,\n        expoPath.url.hash\n      );\n    }\n\n    return undefined;\n  }\n\n  let result: PartialState<NavigationState> | undefined;\n  let current: PartialState<NavigationState> | undefined;\n\n  // We match the whole path against the regex instead of segments\n  // This makes sure matches such as wildcard will catch any unmatched routes, even if nested\n  const { routes, remainingPath } = matchAgainstConfigs(remaining, configWithRegexes);\n\n  if (routes !== undefined) {\n    // This will always be empty if full path matched\n    current = createNestedStateObject(expoPath, routes, initialRoutes, configs, expoPath.url.hash);\n    remaining = remainingPath;\n    result = current;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  return result;\n}\n\n/**\n * Reference to the last used config resources. This is used to avoid recomputing the config resources when the options are the same.\n */\nlet cachedConfigResources: [Options<object> | undefined, ConfigResources] = [\n  undefined,\n  prepareConfigResources(),\n];\n\nfunction getConfigResources<ParamList extends object>(\n  options: Options<ParamList> | undefined,\n  // START FORK\n  previousSegments?: string[]\n  // END FORK\n) {\n  // START FORK - We need to disable this caching as our configs can change based upon the current state\n  // if (cachedConfigResources[0] !== options) {\n  cachedConfigResources = [options, prepareConfigResources(options, previousSegments)];\n  // }\n  // END FORK FORK\n\n  return cachedConfigResources[1];\n}\n\nfunction prepareConfigResources(options?: Options<object>, previousSegments?: string[]) {\n  if (options) {\n    validatePathConfig(options);\n  }\n\n  const initialRoutes = getInitialRoutes(options);\n\n  const configs = getNormalizedConfigs(initialRoutes, options?.screens, previousSegments);\n\n  checkForDuplicatedConfigs(configs);\n\n  const configWithRegexes = getConfigsWithRegexes(configs);\n\n  return {\n    initialRoutes,\n    configs,\n    configWithRegexes,\n  };\n}\n\nfunction getInitialRoutes(options?: Options<object>) {\n  const initialRoutes: InitialRouteConfig[] = [];\n\n  if (options?.initialRouteName) {\n    initialRoutes.push({\n      initialRouteName: options.initialRouteName,\n      parentScreens: [],\n    });\n  }\n\n  return initialRoutes;\n}\n\nfunction getNormalizedConfigs(\n  initialRoutes: InitialRouteConfig[],\n  screens: PathConfigMap<object> = {},\n  // START FORK\n  previousSegments?: string[]\n  // END FORK\n) {\n  // Create a normalized configs array which will be easier to use\n  return ([] as RouteConfig[])\n    .concat(\n      ...Object.keys(screens).map((key) =>\n        createNormalizedConfigs(key, screens as PathConfigMap<object>, [], initialRoutes, [])\n      )\n    )\n    .map(expo.appendIsInitial(initialRoutes))\n    .sort(expo.getRouteConfigSorter(previousSegments));\n  // .sort((a, b) => {\n  //   // Sort config so that:\n  //   // - the most exhaustive ones are always at the beginning\n  //   // - patterns with wildcard are always at the end\n\n  //   // If 2 patterns are same, move the one with less route names up\n  //   // This is an error state, so it's only useful for consistent error messages\n  //   if (a.pattern === b.pattern) {\n  //     return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));\n  //   }\n\n  //   // If one of the patterns starts with the other, it's more exhaustive\n  //   // So move it up\n  //   if (a.pattern.startsWith(b.pattern)) {\n  //     return -1;\n  //   }\n\n  //   if (b.pattern.startsWith(a.pattern)) {\n  //     return 1;\n  //   }\n\n  //   const aParts = a.pattern.split('/');\n  //   const bParts = b.pattern.split('/');\n\n  //   for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {\n  //     // if b is longer, b get higher priority\n  //     if (aParts[i] == null) {\n  //       return 1;\n  //     }\n  //     // if a is longer, a get higher priority\n  //     if (bParts[i] == null) {\n  //       return -1;\n  //     }\n  //     const aWildCard = aParts[i] === '*' || aParts[i].startsWith(':');\n  //     const bWildCard = bParts[i] === '*' || bParts[i].startsWith(':');\n  //     // if both are wildcard we compare next component\n  //     if (aWildCard && bWildCard) {\n  //       continue;\n  //     }\n  //     // if only a is wild card, b get higher priority\n  //     if (aWildCard) {\n  //       return 1;\n  //     }\n  //     // if only b is wild card, a get higher priority\n  //     if (bWildCard) {\n  //       return -1;\n  //     }\n  //   }\n  //   return bParts.length - aParts.length;\n  // });\n}\n\nfunction checkForDuplicatedConfigs(configs: RouteConfig[]) {\n  // Check for duplicate patterns in the config\n  configs.reduce<Record<string, RouteConfig>>((acc, config) => {\n    if (acc[config.pattern]) {\n      const a = acc[config.pattern].routeNames;\n      const b = config.routeNames;\n\n      // It's not a problem if the path string omitted from a inner most screen\n      // For example, it's ok if a path resolves to `A > B > C` or `A > B`\n      const intersects =\n        a.length > b.length ? b.every((it, i) => a[i] === it) : a.every((it, i) => b[i] === it);\n\n      if (!intersects) {\n        throw new Error(\n          `Found conflicting screens with the same pattern. The pattern '${\n            config.pattern\n          }' resolves to both '${a.join(' > ')}' and '${b.join(\n            ' > '\n          )}'. Patterns must be unique and cannot resolve to more than one screen.`\n        );\n      }\n    }\n\n    return Object.assign(acc, {\n      [config.pattern]: config,\n    });\n  }, {});\n}\n\nfunction getConfigsWithRegexes(configs: RouteConfig[]) {\n  return configs.map((c) => ({\n    ...c,\n    // Add `$` to the regex to make sure it matches till end of the path and not just beginning\n    // START FORK\n    // regex: c.regex ? new RegExp(c.regex.source + '$') : undefined,\n    regex: expo.configRegExp(c),\n    // END FORK\n  }));\n}\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nconst matchAgainstConfigs = (remaining: string, configs: RouteConfig[]) => {\n  let routes: ParsedRoute[] | undefined;\n  let remainingPath = remaining;\n\n  // START FORK\n  const allParams = Object.create(null);\n  // END FORK\n\n  // Go through all configs, and see if the next path segment matches our regex\n  for (const config of configs) {\n    if (!config.regex) {\n      continue;\n    }\n\n    const match = remainingPath.match(config.regex);\n\n    // If our regex matches, we need to extract params from the path\n    if (match) {\n      const matchResult = config.pattern?.split('/').reduce<{\n        pos: number; // Position of the current path param segment in the path (e.g in pattern `a/:b/:c`, `:a` is 0 and `:b` is 1)\n        matchedParams: Record<string, Record<string, string>>; // The extracted params\n      }>(\n        (acc, p, index) => {\n          if (!expo.isDynamicPart(p)) {\n            return acc;\n          }\n\n          acc.pos += 1;\n\n          // START FORK\n          const decodedParamSegment = expo.safelyDecodeURIComponent(\n            // const decodedParamSegment = decodeURIComponent(\n            // The param segments appear every second item starting from 2 in the regex match result\n            match![(acc.pos + 1) * 2]\n              // Remove trailing slash\n              .replace(/\\/$/, '')\n          );\n          // END FORK\n\n          Object.assign(acc.matchedParams, {\n            [p]: Object.assign(acc.matchedParams[p] || {}, {\n              [index]: decodedParamSegment,\n            }),\n          });\n\n          return acc;\n        },\n        { pos: -1, matchedParams: {} }\n      );\n\n      const matchedParams = matchResult.matchedParams || {};\n\n      routes = config.routeNames.map((name) => {\n        const routeConfig = configs.find((c) => {\n          // Check matching name AND pattern in case same screen is used at different levels in config\n          return c.screen === name && config.pattern.startsWith(c.pattern);\n        });\n\n        // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n        const normalizedPath = routeConfig?.path.split('/').filter(Boolean).join('/');\n\n        // Get the number of segments in the initial pattern\n        const numInitialSegments = routeConfig?.pattern\n          // Extract the prefix from the pattern by removing the ending path pattern (e.g pattern=`a/b/c/d` and normalizedPath=`c/d` becomes `a/b`)\n          .replace(new RegExp(`${escape(normalizedPath!)}$`), '')\n          ?.split('/').length;\n\n        const params = normalizedPath\n          ?.split('/')\n          .reduce<Record<string, unknown>>((acc, p, index) => {\n            if (!expo.isDynamicPart(p)) {\n              return acc;\n            }\n\n            // Get the real index of the path parameter in the matched path\n            // by offsetting by the number of segments in the initial pattern\n            const offset = numInitialSegments ? numInitialSegments - 1 : 0;\n            // START FORK\n            // const value = matchedParams[p]?.[index + offset];\n            const value = expo.getParamValue(p, matchedParams[p]?.[index + offset]);\n            // END FORK\n\n            if (value) {\n              // START FORK\n              // const key = p.replace(/^:/, '').replace(/\\?$/, '');\n              const key = expo.replacePart(p);\n              // END FORK\n              acc[key] = routeConfig?.parse?.[key] ? routeConfig.parse[key](value as any) : value;\n            }\n\n            return acc;\n          }, {});\n\n        if (params && Object.keys(params).length) {\n          Object.assign(allParams, params);\n          return { name, params };\n        }\n\n        return { name };\n      });\n\n      remainingPath = remainingPath.replace(match[1], '');\n\n      break;\n    }\n  }\n\n  // START FORK\n  expo.populateParams(routes, allParams);\n  // END FORK\n\n  return { routes, remainingPath };\n};\n\nconst createNormalizedConfigs = (\n  screen: string,\n  routeConfig: PathConfigMap<object>,\n  routeNames: string[] = [],\n  initials: InitialRouteConfig[],\n  parentScreens: string[],\n  parentPattern?: string\n): RouteConfig[] => {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(screen);\n\n  parentScreens.push(screen);\n\n  // @ts-expect-error: TODO(@kitten): This is entirely untyped. The index access just flags this, but we're not typing the config properly here\n  const config = routeConfig[screen];\n\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    configs.push(createConfigItem(screen, routeNames, pattern, config));\n  } else if (typeof config === 'object') {\n    let pattern: string | undefined;\n\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (typeof config.path === 'string') {\n      if (config.exact && config.path === undefined) {\n        throw new Error(\n          \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n        );\n      }\n\n      pattern =\n        config.exact !== true\n          ? joinPaths(parentPattern || '', config.path || '')\n          : config.path || '';\n\n      if (screen !== INTERNAL_SLOT_NAME) {\n        configs.push(\n          createConfigItem(screen, routeNames, pattern!, config.path, config.parse, config)\n        );\n      }\n    }\n\n    if (config.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (config.initialRouteName) {\n        initials.push({\n          initialRouteName: config.initialRouteName,\n          parentScreens,\n        });\n      }\n\n      Object.keys(config.screens).forEach((nestedConfig) => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          config.screens as PathConfigMap<object>,\n          routeNames,\n          initials,\n          [...parentScreens],\n          pattern ?? parentPattern\n        );\n\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n};\n\nconst createConfigItem = (\n  screen: string,\n  routeNames: string[],\n  pattern: string,\n  path: string,\n  parse: ParseConfig | undefined = undefined,\n  config: Record<string, any> = {}\n): RouteConfig => {\n  // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n  pattern = pattern.split('/').filter(Boolean).join('/');\n\n  // START FORK\n  const regex = pattern ? expo.routePatternToRegex(pattern) : undefined;\n  // const regex = pattern\n  //   ? new RegExp(\n  //       `^(${pattern\n  //         .split('/')\n  //         .map((it) => {\n  //           if (it.startsWith(':')) {\n  //             return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  //           }\n\n  //           return `${it === '*' ? '.*' : escape(it)}\\\\/`;\n  //         })\n  //         .join('')})`\n  //     )\n  //   : undefined;\n  // END FORK\n\n  return {\n    screen,\n    regex,\n    pattern,\n    path,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse,\n    // START FORK\n    ...expo.createConfig(screen, pattern, routeNames, config),\n    // END FORK\n  };\n};\n\nconst findParseConfigForRoute = (\n  routeName: string,\n  flatConfig: RouteConfig[]\n): ParseConfig | undefined => {\n  for (const config of flatConfig) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n\n  return undefined;\n};\n\n// Try to find an initial route connected with the one passed\nconst findInitialRoute = (\n  routeName: string,\n  parentScreens: string[],\n  initialRoutes: InitialRouteConfig[]\n): string | undefined => {\n  for (const config of initialRoutes) {\n    if (parentScreens.length === config.parentScreens.length) {\n      let sameParents = true;\n      for (let i = 0; i < parentScreens.length; i++) {\n        if (parentScreens[i].localeCompare(config.parentScreens[i]) !== 0) {\n          sameParents = false;\n          break;\n        }\n      }\n      if (sameParents) {\n        return routeName !== config.initialRouteName ? config.initialRouteName : undefined;\n      }\n    }\n  }\n  return undefined;\n};\n\n// returns state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nconst createStateObject = (\n  initialRoute: string | undefined,\n  route: ParsedRoute,\n  isEmpty: boolean\n): InitialState => {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{ name: initialRoute, params: route.params }, route],\n      };\n    } else {\n      return {\n        routes: [route],\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute, params: route.params },\n          { ...route, state: { routes: [] } },\n        ],\n      };\n    } else {\n      return {\n        routes: [{ ...route, state: { routes: [] } }],\n      };\n    }\n  }\n};\n\nconst createNestedStateObject = (\n  { path, ...expoURL }: ReturnType<typeof expo.getUrlWithReactNavigationConcessions>,\n  routes: ParsedRoute[],\n  initialRoutes: InitialRouteConfig[],\n  flatConfig?: RouteConfig[],\n  hash?: string\n) => {\n  let route = routes.shift() as ParsedRoute;\n  const parentScreens: string[] = [];\n\n  let initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n  parentScreens.push(route.name);\n\n  const state: InitialState = createStateObject(initialRoute, route, routes.length === 0);\n\n  if (routes.length > 0) {\n    let nestedState = state;\n\n    while ((route = routes.shift() as ParsedRoute)) {\n      initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n      const nestedStateIndex = nestedState.index || nestedState.routes.length - 1;\n\n      nestedState.routes[nestedStateIndex].state = createStateObject(\n        initialRoute,\n        route,\n        routes.length === 0\n      );\n\n      if (routes.length > 0) {\n        nestedState = nestedState.routes[nestedStateIndex].state as InitialState;\n      }\n\n      parentScreens.push(route.name);\n    }\n  }\n\n  route = findFocusedRoute(state) as ParsedRoute;\n  // START FORK\n  route.path = expoURL.pathWithoutGroups;\n  // route.path = path;\n  // END FORK\n\n  // START FORK\n  // const params = parseQueryParams(\n  const params = expo.parseQueryParams(\n    path,\n    route,\n    flatConfig ? findParseConfigForRoute(route.name, flatConfig) : undefined,\n    hash\n  );\n  // END FORK\n\n  // START FORK\n  // expo.handleUrlParams(route, params, hash);\n  if (params) {\n    route.params = { ...route.params, ...params };\n  }\n  // END FORK\n\n  return state;\n};\n\n// START FORK\n// const parseQueryParams = (path: string, parseConfig?: Record<string, (value: string) => any>) => {\n//   const query = path.split('?')[1];\n//   const params = queryString.parse(query);\n\n//   if (parseConfig) {\n//     Object.keys(params).forEach((name) => {\n//       if (Object.hasOwnProperty.call(parseConfig, name) && typeof params[name] === 'string') {\n//         params[name] = parseConfig[name](params[name] as string);\n//       }\n//     });\n//   }\n\n//   return Object.keys(params).length ? params : undefined;\n// };\n// END FORK\n"],"mappings":"wyCAoEAA,OAAA,CAAAC,gBAAA,CAAAA,gBAAA,CApEA,MAAAC,QAAA,CAAAC,OAAA,6BAEA,MAAAC,sBAAA,CAAAC,eAAA,CAAAF,OAAA,0BAEA,MAAAG,kBAAA,CAAAH,OAAA,uBAEA,MAAAI,IAAA,CAAAC,YAAA,CAAAL,OAAA,8BACA,MAAAM,WAAA,CAAAN,OAAA,iBA6DA,QAAgB,CAAAF,gBAAgBA,CAC9BS,IAAY,CACZC,OAA4B,CAE5BC,QAAA,CAAqB,EAAE,C,CAGvB,KAAM,CAAEC,aAAa,CAAEC,OAAO,CAAEC,iBAAiB,CAAE,CAAGC,kBAAkB,CACtEL,OAAO,CAEPC,Q,CAED,CAED,KAAM,CAAAK,OAAO,CAAGN,OAAO,EAAEM,OAAO,CAGhC,KAAM,CAAAC,QAAQ,CAAGX,IAAI,CAACY,oCAAoC,CAACT,IAAI,CAAC,CAIhE,GAAI,CAAAU,SAAS,CAAGb,IAAI,CAACc,SAAS,CAACH,QAAQ,CAACI,mBAAmB,CAAC,CAU5D,KAAM,CAAAC,MAAM,CAAGZ,OAAO,EAAED,IAAI,EAAEc,OAAO,CAAC,KAAK,CAAE,EAAE,CAAC,CAEhD,GAAID,MAAM,CAAE,CAEV,KAAM,CAAAE,gBAAgB,CAAGF,MAAM,CAACG,QAAQ,CAAC,GAAG,CAAC,CAAGH,MAAM,CAAG,GAAGA,MAAM,GAAG,CAGrE,GAAI,CAACH,SAAS,CAACO,UAAU,CAACF,gBAAgB,CAAC,CAAE,CAC3C,MAAO,CAAAG,SAAS,CAClB,CAGAR,SAAS,CAAGA,SAAS,CAACI,OAAO,CAACC,gBAAgB,CAAE,EAAE,CAAC,CACrD,CAEA,GAAIR,OAAO,GAAKW,SAAS,CAAE,CAEzB,KAAM,CAAAC,MAAM,CAAGT,SAAS,CACrBU,KAAK,CAAC,GAAG,CAAC,CACVC,MAAM,CAACC,OAAO,CAAC,CACfC,GAAG,CAAEC,OAAO,EAAI,CACf,KAAM,CAAAC,IAAI,CAAGC,kBAAkB,CAACF,OAAO,CAAC,CACxC,MAAO,CAAEC,IAAI,CAAE,CACjB,CAAC,CAAC,CAEJ,GAAIN,MAAM,CAACQ,MAAM,CAAE,CACjB,MAAO,CAAAC,uBAAuB,CAACpB,QAAQ,CAAEW,MAAM,CAAEhB,aAAa,CAAE,EAAE,CAAEK,QAAQ,CAACqB,GAAG,CAACC,IAAI,CAAC,CACxF,CAEA,MAAO,CAAAZ,SAAS,CAClB,CAEA,GAAIR,SAAS,GAAK,GAAG,CAAE,CAIrB,KAAM,CAAAqB,KAAK,CAAGlC,IAAI,CAACmC,iBAAiB,CAAC3B,iBAAiB,CAAC,CAWvD,GAAI0B,KAAK,CAAE,CACT,MAAO,CAAAH,uBAAuB,CAC5BpB,QAAQ,CACRuB,KAAK,CAACE,UAAU,CAACV,GAAG,CAAEE,IAAI,GAAM,CAAEA,IAAI,CAAE,CAAC,CAAC,CAC1CtB,aAAa,CACbC,OAAO,CACPI,QAAQ,CAACqB,GAAG,CAACC,IAAI,CAClB,CACH,CAEA,MAAO,CAAAZ,SAAS,CAClB,CAEA,GAAI,CAAAgB,MAAiD,CACrD,GAAI,CAAAC,OAAkD,CAItD,KAAM,CAAEhB,MAAM,CAAEiB,aAAa,CAAE,CAAGC,mBAAmB,CAAC3B,SAAS,CAAEL,iBAAiB,CAAC,CAEnF,GAAIc,MAAM,GAAKD,SAAS,CAAE,CAExBiB,OAAO,CAAGP,uBAAuB,CAACpB,QAAQ,CAAEW,MAAM,CAAEhB,aAAa,CAAEC,OAAO,CAAEI,QAAQ,CAACqB,GAAG,CAACC,IAAI,CAAC,CAC9FpB,SAAS,CAAG0B,aAAa,CACzBF,MAAM,CAAGC,OAAO,CAClB,CAEA,GAAIA,OAAO,EAAI,IAAI,EAAID,MAAM,EAAI,IAAI,CAAE,CACrC,MAAO,CAAAhB,SAAS,CAClB,CAEA,MAAO,CAAAgB,MAAM,CACf,CAKA,GAAI,CAAAI,qBAAqB,CAAmD,CAC1EpB,SAAS,CACTqB,sBAAsB,EAAE,CACzB,CAED,QAAS,CAAAjC,kBAAkBA,CACzBL,OAAuC,CAEvCuC,gBAA2B,C,CAK3BF,qBAAqB,CAAG,CAACrC,OAAO,CAAEsC,sBAAsB,CAACtC,OAAO,CAAEuC,gBAAgB,CAAC,CAAC,CAIpF,MAAO,CAAAF,qBAAqB,CAAC,CAAC,CAAC,CACjC,CAEA,QAAS,CAAAC,sBAAsBA,CAACtC,OAAyB,CAAEuC,gBAA2B,EACpF,GAAIvC,OAAO,CAAE,CACX,GAAAT,QAAA,CAAAiD,kBAAkB,EAACxC,OAAO,CAAC,CAC7B,CAEA,KAAM,CAAAE,aAAa,CAAGuC,gBAAgB,CAACzC,OAAO,CAAC,CAE/C,KAAM,CAAAG,OAAO,CAAGuC,oBAAoB,CAACxC,aAAa,CAAEF,OAAO,EAAEM,OAAO,CAAEiC,gBAAgB,CAAC,CAEvFI,yBAAyB,CAACxC,OAAO,CAAC,CAElC,KAAM,CAAAC,iBAAiB,CAAGwC,qBAAqB,CAACzC,OAAO,CAAC,CAExD,MAAO,CACLD,aAAa,CACbC,OAAO,CACPC,iB,CACD,CACH,CAEA,QAAS,CAAAqC,gBAAgBA,CAACzC,OAAyB,EACjD,KAAM,CAAAE,aAAa,CAAyB,EAAE,CAE9C,GAAIF,OAAO,EAAE6C,gBAAgB,CAAE,CAC7B3C,aAAa,CAAC4C,IAAI,CAAC,CACjBD,gBAAgB,CAAE7C,OAAO,CAAC6C,gBAAgB,CAC1CE,aAAa,CAAE,E,CAChB,CAAC,CACJ,CAEA,MAAO,CAAA7C,aAAa,CACtB,CAEA,QAAS,CAAAwC,oBAAoBA,CAC3BxC,aAAmC,CACnCI,OAAA,CAAiC,EAAE,CAEnCiC,gBAA2B,C,CAI3B,MAAQ,EAAoB,CACzBS,MAAM,CACL,GAAGC,MAAM,CAACC,IAAI,CAAC5C,OAAO,CAAC,CAACgB,GAAG,CAAE6B,GAAG,EAC9BC,uBAAuB,CAACD,GAAG,CAAE7C,OAAgC,CAAE,EAAE,CAAEJ,aAAa,CAAE,EAAE,CAAC,CACtF,CACF,CACAoB,GAAG,CAAC1B,IAAI,CAACyD,eAAe,CAACnD,aAAa,CAAC,CAAC,CACxCoD,IAAI,CAAC1D,IAAI,CAAC2D,oBAAoB,CAAChB,gBAAgB,CAAC,CAAC,CAmDtD,CAEA,QAAS,CAAAI,yBAAyBA,CAACxC,OAAsB,EAEvDA,OAAO,CAACqD,MAAM,CAA8B,CAACC,GAAG,CAAEC,MAAM,GAAI,CAC1D,GAAID,GAAG,CAACC,MAAM,CAACC,OAAO,CAAC,CAAE,CACvB,KAAM,CAAAC,CAAC,CAAGH,GAAG,CAACC,MAAM,CAACC,OAAO,CAAC,CAAC3B,UAAU,CACxC,KAAM,CAAA6B,CAAC,CAAGH,MAAM,CAAC1B,UAAU,CAI3B,KAAM,CAAA8B,UAAU,CACdF,CAAC,CAAClC,MAAM,CAAGmC,CAAC,CAACnC,MAAM,CAAGmC,CAAC,CAACE,KAAK,CAAC,CAACC,EAAE,CAAEC,CAAC,GAAKL,CAAC,CAACK,CAAC,CAAC,GAAKD,EAAE,CAAC,CAAGJ,CAAC,CAACG,KAAK,CAAC,CAACC,EAAE,CAAEC,CAAC,GAAKJ,CAAC,CAACI,CAAC,CAAC,GAAKD,EAAE,CAAC,CAEzF,GAAI,CAACF,UAAU,CAAE,CACf,KAAM,IAAI,CAAAI,KAAK,CACb,iEACER,MAAM,CAACC,OACT,uBAAuBC,CAAC,CAACO,IAAI,CAAC,KAAK,CAAC,UAAUN,CAAC,CAACM,IAAI,CAClD,KAAK,CACN,wEAAwE,CAC1E,CACH,CACF,CAEA,MAAO,CAAAlB,MAAM,CAACmB,MAAM,CAACX,GAAG,CAAE,CACxB,CAACC,MAAM,CAACC,OAAO,EAAGD,M,CACnB,CAAC,CACJ,CAAC,CAAE,EAAE,CAAC,CACR,CAEA,QAAS,CAAAd,qBAAqBA,CAACzC,OAAsB,EACnD,MAAO,CAAAA,OAAO,CAACmB,GAAG,CAAE+C,CAAC,EAAApB,MAAA,CAAAmB,MAAA,IAChBC,CAAC,EAIJC,KAAK,CAAE1E,IAAI,CAAC2E,YAAY,CAACF,CAAC,CAAC,EAE3B,CAAC,CACL,CAEA,KAAM,CAAAG,SAAS,CAAGA,CAAC,GAAGC,KAAe,GAClC,EAAe,CACbzB,MAAM,CAAC,GAAGyB,KAAK,CAACnD,GAAG,CAAEoD,CAAC,EAAKA,CAAC,CAACvD,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CACzCC,MAAM,CAACC,OAAO,CAAC,CACf8C,IAAI,CAAC,GAAG,CAAC,CAEd,KAAM,CAAA/B,mBAAmB,CAAGA,CAAC3B,SAAiB,CAAEN,OAAsB,GAAI,CACxE,GAAI,CAAAe,MAAiC,CACrC,GAAI,CAAAiB,aAAa,CAAG1B,SAAS,CAG7B,KAAM,CAAAkE,SAAS,CAAG1B,MAAM,CAAC2B,MAAM,CAAC,IAAI,CAAC,CAIrC,IAAK,KAAM,CAAAlB,MAAM,GAAI,CAAAvD,OAAO,CAAE,CAC5B,GAAI,CAACuD,MAAM,CAACY,KAAK,CAAE,CACjB,SACF,CAEA,KAAM,CAAAxC,KAAK,CAAGK,aAAa,CAACL,KAAK,CAAC4B,MAAM,CAACY,KAAK,CAAC,CAG/C,GAAIxC,KAAK,CAAE,CACT,KAAM,CAAA+C,WAAW,CAAGnB,MAAM,CAACC,OAAO,EAAExC,KAAK,CAAC,GAAG,CAAC,CAACqC,MAAM,CAInD,CAACC,GAAG,CAAEiB,CAAC,CAAEI,KAAK,GAAI,CAChB,GAAI,CAAClF,IAAI,CAACmF,aAAa,CAACL,CAAC,CAAC,CAAE,CAC1B,MAAO,CAAAjB,GAAG,CACZ,CAEAA,GAAG,CAACuB,GAAG,EAAI,CAAC,CAGZ,KAAM,CAAAC,mBAAmB,CAAGrF,IAAI,CAACsF,wBAAwB,CAGvDpD,KAAM,CAAC,CAAC2B,GAAG,CAACuB,GAAG,CAAG,CAAC,EAAI,CAAC,CAAC,CAEtBnE,OAAO,CAAC,KAAK,CAAE,EAAE,CAAC,CACtB,CAGDoC,MAAM,CAACmB,MAAM,CAACX,GAAG,CAAC0B,aAAa,CAAE,CAC/B,CAACT,CAAC,EAAGzB,MAAM,CAACmB,MAAM,CAACX,GAAG,CAAC0B,aAAa,CAACT,CAAC,CAAC,EAAI,EAAE,CAAE,CAC7C,CAACI,KAAK,EAAGG,mB,CACV,C,CACF,CAAC,CAEF,MAAO,CAAAxB,GAAG,CACZ,CAAC,CACD,CAAEuB,GAAG,CAAE,CAAC,CAAC,CAAEG,aAAa,CAAE,EAAE,CAAE,CAC/B,CAED,KAAM,CAAAA,aAAa,CAAGN,WAAW,CAACM,aAAa,EAAI,EAAE,CAErDjE,MAAM,CAAGwC,MAAM,CAAC1B,UAAU,CAACV,GAAG,CAAEE,IAAI,EAAI,CACtC,KAAM,CAAA4D,WAAW,CAAGjF,OAAO,CAACkF,IAAI,CAAEhB,CAAC,EAAI,CAErC,MAAO,CAAAA,CAAC,CAACiB,MAAM,GAAK9D,IAAI,EAAIkC,MAAM,CAACC,OAAO,CAAC3C,UAAU,CAACqD,CAAC,CAACV,OAAO,CAAC,CAClE,CAAC,CAAC,CAGF,KAAM,CAAA4B,cAAc,CAAGH,WAAW,EAAErF,IAAI,CAACoB,KAAK,CAAC,GAAG,CAAC,CAACC,MAAM,CAACC,OAAO,CAAC,CAAC8C,IAAI,CAAC,GAAG,CAAC,CAG7E,KAAM,CAAAqB,kBAAkB,CAAGJ,WAAW,EAAEzB,OAAO,CAE5C9C,OAAO,CAAC,GAAI,CAAA4E,MAAM,CAAC,GAAG,GAAAhG,sBAAA,CAAAiG,OAAM,EAACH,cAAe,CAAC,GAAG,CAAC,CAAE,EAAE,CAAC,EACrDpE,KAAK,CAAC,GAAG,CAAC,CAACO,MAAM,CAErB,KAAM,CAAAiE,MAAM,CAAGJ,cAAc,EACzBpE,KAAK,CAAC,GAAG,CAAC,CACXqC,MAAM,CAA0B,CAACC,GAAG,CAAEiB,CAAC,CAAEI,KAAK,GAAI,CACjD,GAAI,CAAClF,IAAI,CAACmF,aAAa,CAACL,CAAC,CAAC,CAAE,CAC1B,MAAO,CAAAjB,GAAG,CACZ,CAIA,KAAM,CAAAmC,MAAM,CAAGJ,kBAAkB,CAAGA,kBAAkB,CAAG,CAAC,CAAG,CAAC,CAG9D,KAAM,CAAAK,KAAK,CAAGjG,IAAI,CAACkG,aAAa,CAACpB,CAAC,CAAES,aAAa,CAACT,CAAC,CAAC,GAAGI,KAAK,CAAGc,MAAM,CAAC,CAAC,CAGvE,GAAIC,KAAK,CAAE,CAGT,KAAM,CAAA1C,GAAG,CAAGvD,IAAI,CAACmG,WAAW,CAACrB,CAAC,CAAC,CAE/BjB,GAAG,CAACN,GAAG,CAAC,CAAGiC,WAAW,EAAEY,KAAK,GAAG7C,GAAG,CAAC,CAAGiC,WAAW,CAACY,KAAK,CAAC7C,GAAG,CAAC,CAAC0C,KAAY,CAAC,CAAGA,KAAK,CACrF,CAEA,MAAO,CAAApC,GAAG,CACZ,CAAC,CAAE,EAAE,CAAC,CAER,GAAIkC,MAAM,EAAI1C,MAAM,CAACC,IAAI,CAACyC,MAAM,CAAC,CAACjE,MAAM,CAAE,CACxCuB,MAAM,CAACmB,MAAM,CAACO,SAAS,CAAEgB,MAAM,CAAC,CAChC,MAAO,CAAEnE,IAAI,CAAEmE,MAAM,CAAE,CACzB,CAEA,MAAO,CAAEnE,IAAI,CAAE,CACjB,CAAC,CAAC,CAEFW,aAAa,CAAGA,aAAa,CAACtB,OAAO,CAACiB,KAAK,CAAC,CAAC,CAAC,CAAE,EAAE,CAAC,CAEnD,MACF,CACF,CAGAlC,IAAI,CAACqG,cAAc,CAAC/E,MAAM,CAAEyD,SAAS,CAAC,CAGtC,MAAO,CAAEzD,MAAM,CAAEiB,aAAa,CAAE,CAClC,CAAC,CAED,KAAM,CAAAiB,uBAAuB,CAAGA,CAC9BkC,MAAc,CACdF,WAAkC,CAClCpD,UAAA,CAAuB,EAAE,CACzBkE,QAA8B,CAC9BnD,aAAuB,CACvBoD,aAAsB,GACL,CACjB,KAAM,CAAAhG,OAAO,CAAkB,EAAE,CAEjC6B,UAAU,CAACc,IAAI,CAACwC,MAAM,CAAC,CAEvBvC,aAAa,CAACD,IAAI,CAACwC,MAAM,CAAC,CAG1B,KAAM,CAAA5B,MAAM,CAAG0B,WAAW,CAACE,MAAM,CAAC,CAElC,GAAI,MAAO,CAAA5B,MAAM,GAAK,QAAQ,CAAE,CAE9B,KAAM,CAAAC,OAAO,CAAGwC,aAAa,CAAG3B,SAAS,CAAC2B,aAAa,CAAEzC,MAAM,CAAC,CAAGA,MAAM,CAEzEvD,OAAO,CAAC2C,IAAI,CAACsD,gBAAgB,CAACd,MAAM,CAAEtD,UAAU,CAAE2B,OAAO,CAAED,MAAM,CAAC,CAAC,CACrE,CAAC,IAAM,IAAI,MAAO,CAAAA,MAAM,GAAK,QAAQ,CAAE,CACrC,GAAI,CAAAC,OAA2B,CAK/B,GAAI,MAAO,CAAAD,MAAM,CAAC3D,IAAI,GAAK,QAAQ,CAAE,CACnC,GAAI2D,MAAM,CAAC2C,KAAK,EAAI3C,MAAM,CAAC3D,IAAI,GAAKkB,SAAS,CAAE,CAC7C,KAAM,IAAI,CAAAiD,KAAK,CACb,sJAAsJ,CACvJ,CACH,CAEAP,OAAO,CACLD,MAAM,CAAC2C,KAAK,GAAK,IAAI,CACjB7B,SAAS,CAAC2B,aAAa,EAAI,EAAE,CAAEzC,MAAM,CAAC3D,IAAI,EAAI,EAAE,CAAC,CACjD2D,MAAM,CAAC3D,IAAI,EAAI,EAAE,CAEvB,GAAIuF,MAAM,GAAKxF,WAAA,CAAAwG,kBAAkB,CAAE,CACjCnG,OAAO,CAAC2C,IAAI,CACVsD,gBAAgB,CAACd,MAAM,CAAEtD,UAAU,CAAE2B,OAAQ,CAAED,MAAM,CAAC3D,IAAI,CAAE2D,MAAM,CAACsC,KAAK,CAAEtC,MAAM,CAAC,CAClF,CACH,CACF,CAEA,GAAIA,MAAM,CAACpD,OAAO,CAAE,CAElB,GAAIoD,MAAM,CAACb,gBAAgB,CAAE,CAC3BqD,QAAQ,CAACpD,IAAI,CAAC,CACZD,gBAAgB,CAAEa,MAAM,CAACb,gBAAgB,CACzCE,a,CACD,CAAC,CACJ,CAEAE,MAAM,CAACC,IAAI,CAACQ,MAAM,CAACpD,OAAO,CAAC,CAACiG,OAAO,CAAEC,YAAY,EAAI,CACnD,KAAM,CAAAvE,MAAM,CAAGmB,uBAAuB,CACpCoD,YAAY,CACZ9C,MAAM,CAACpD,OAAgC,CACvC0B,UAAU,CACVkE,QAAQ,CACR,CAAC,GAAGnD,aAAa,CAAC,CAClBY,OAAO,EAAIwC,aAAa,CACzB,CAEDhG,OAAO,CAAC2C,IAAI,CAAC,GAAGb,MAAM,CAAC,CACzB,CAAC,CAAC,CACJ,CACF,CAEAD,UAAU,CAACyE,GAAG,EAAE,CAEhB,MAAO,CAAAtG,OAAO,CAChB,CAAC,CAED,KAAM,CAAAiG,gBAAgB,CAAGA,CACvBd,MAAc,CACdtD,UAAoB,CACpB2B,OAAe,CACf5D,IAAY,CACZiG,KAAA,CAAiC/E,SAAS,CAC1CyC,MAAA,CAA8B,EAAE,GACjB,CAEfC,OAAO,CAAGA,OAAO,CAACxC,KAAK,CAAC,GAAG,CAAC,CAACC,MAAM,CAACC,OAAO,CAAC,CAAC8C,IAAI,CAAC,GAAG,CAAC,CAGtD,KAAM,CAAAG,KAAK,CAAGX,OAAO,CAAG/D,IAAI,CAAC8G,mBAAmB,CAAC/C,OAAO,CAAC,CAAG1C,SAAS,CAiBrE,OAAAgC,MAAA,CAAAmB,MAAA,EACEkB,MAAM,CACNhB,KAAK,CACLX,OAAO,CACP5D,IAAI,CAEJiC,UAAU,CAAE,CAAC,GAAGA,UAAU,CAAC,CAC3BgE,KAAK,EAEFpG,IAAI,CAAC+G,YAAY,CAACrB,MAAM,CAAE3B,OAAO,CAAE3B,UAAU,CAAE0B,MAAM,CAAC,EAG7D,CAAC,CAED,KAAM,CAAAkD,uBAAuB,CAAGA,CAC9BC,SAAiB,CACjBC,UAAyB,GACE,CAC3B,IAAK,KAAM,CAAApD,MAAM,GAAI,CAAAoD,UAAU,CAAE,CAC/B,GAAID,SAAS,GAAKnD,MAAM,CAAC1B,UAAU,CAAC0B,MAAM,CAAC1B,UAAU,CAACN,MAAM,CAAG,CAAC,CAAC,CAAE,CACjE,MAAO,CAAAgC,MAAM,CAACsC,KAAK,CACrB,CACF,CAEA,MAAO,CAAA/E,SAAS,CAClB,CAAC,CAGD,KAAM,CAAA8F,gBAAgB,CAAGA,CACvBF,SAAiB,CACjB9D,aAAuB,CACvB7C,aAAmC,GACb,CACtB,IAAK,KAAM,CAAAwD,MAAM,GAAI,CAAAxD,aAAa,CAAE,CAClC,GAAI6C,aAAa,CAACrB,MAAM,GAAKgC,MAAM,CAACX,aAAa,CAACrB,MAAM,CAAE,CACxD,GAAI,CAAAsF,WAAW,CAAG,IAAI,CACtB,IAAK,GAAI,CAAA/C,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGlB,aAAa,CAACrB,MAAM,CAAEuC,CAAC,EAAE,CAAE,CAC7C,GAAIlB,aAAa,CAACkB,CAAC,CAAC,CAACgD,aAAa,CAACvD,MAAM,CAACX,aAAa,CAACkB,CAAC,CAAC,CAAC,GAAK,CAAC,CAAE,CACjE+C,WAAW,CAAG,KAAK,CACnB,MACF,CACF,CACA,GAAIA,WAAW,CAAE,CACf,MAAO,CAAAH,SAAS,GAAKnD,MAAM,CAACb,gBAAgB,CAAGa,MAAM,CAACb,gBAAgB,CAAG5B,SAAS,CACpF,CACF,CACF,CACA,MAAO,CAAAA,SAAS,CAClB,CAAC,CAID,KAAM,CAAAiG,iBAAiB,CAAGA,CACxBC,YAAgC,CAChCC,KAAkB,CAClBC,OAAgB,GACA,CAChB,GAAIA,OAAO,CAAE,CACX,GAAIF,YAAY,CAAE,CAChB,MAAO,CACLrC,KAAK,CAAE,CAAC,CACR5D,MAAM,CAAE,CAAC,CAAEM,IAAI,CAAE2F,YAAY,CAAExB,MAAM,CAAEyB,KAAK,CAACzB,MAAM,CAAE,CAAEyB,KAAK,C,CAC7D,CACH,CAAC,IAAM,CACL,MAAO,CACLlG,MAAM,CAAE,CAACkG,KAAK,C,CACf,CACH,CACF,CAAC,IAAM,CACL,GAAID,YAAY,CAAE,CAChB,MAAO,CACLrC,KAAK,CAAE,CAAC,CACR5D,MAAM,CAAE,CACN,CAAEM,IAAI,CAAE2F,YAAY,CAAExB,MAAM,CAAEyB,KAAK,CAACzB,MAAM,CAAE,CAAA1C,MAAA,CAAAmB,MAAA,IACvCgD,KAAK,EAAEE,KAAK,CAAE,CAAEpG,MAAM,CAAE,EAAE,CAAE,G,CAEpC,CACH,CAAC,IAAM,CACL,MAAO,CACLA,MAAM,CAAE,CAAA+B,MAAA,CAAAmB,MAAA,IAAMgD,KAAK,EAAEE,KAAK,CAAE,CAAEpG,MAAM,CAAE,EAAE,CAAE,G,CAC3C,CACH,CACF,CACF,CAAC,CAED,KAAM,CAAAS,uBAAuB,CAAGA,CAAA4F,IAAA,CAE9BrG,MAAqB,CACrBhB,aAAmC,CACnC4G,UAA0B,CAC1BjF,IAAa,GACX,IALF,CAAE9B,IAAgB,CAAgE,CAAAwH,IAAA,CAAvEC,OAAO,CAAAC,6BAAA,CAAAF,IAAA,CAAAG,SAAA,EAMlB,GAAI,CAAAN,KAAK,CAAGlG,MAAM,CAACyG,KAAK,EAAiB,CACzC,KAAM,CAAA5E,aAAa,CAAa,EAAE,CAElC,GAAI,CAAAoE,YAAY,CAAGJ,gBAAgB,CAACK,KAAK,CAAC5F,IAAI,CAAEuB,aAAa,CAAE7C,aAAa,CAAC,CAE7E6C,aAAa,CAACD,IAAI,CAACsE,KAAK,CAAC5F,IAAI,CAAC,CAE9B,KAAM,CAAA8F,KAAK,CAAiBJ,iBAAiB,CAACC,YAAY,CAAEC,KAAK,CAAElG,MAAM,CAACQ,MAAM,GAAK,CAAC,CAAC,CAEvF,GAAIR,MAAM,CAACQ,MAAM,CAAG,CAAC,CAAE,CACrB,GAAI,CAAAkG,WAAW,CAAGN,KAAK,CAEvB,MAAQF,KAAK,CAAGlG,MAAM,CAACyG,KAAK,EAAiB,CAAG,CAC9CR,YAAY,CAAGJ,gBAAgB,CAACK,KAAK,CAAC5F,IAAI,CAAEuB,aAAa,CAAE7C,aAAa,CAAC,CAEzE,KAAM,CAAA2H,gBAAgB,CAAGD,WAAW,CAAC9C,KAAK,EAAI8C,WAAW,CAAC1G,MAAM,CAACQ,MAAM,CAAG,CAAC,CAE3EkG,WAAW,CAAC1G,MAAM,CAAC2G,gBAAgB,CAAC,CAACP,KAAK,CAAGJ,iBAAiB,CAC5DC,YAAY,CACZC,KAAK,CACLlG,MAAM,CAACQ,MAAM,GAAK,CAAC,CACpB,CAED,GAAIR,MAAM,CAACQ,MAAM,CAAG,CAAC,CAAE,CACrBkG,WAAW,CAAGA,WAAW,CAAC1G,MAAM,CAAC2G,gBAAgB,CAAC,CAACP,KAAqB,CAC1E,CAEAvE,aAAa,CAACD,IAAI,CAACsE,KAAK,CAAC5F,IAAI,CAAC,CAChC,CACF,CAEA4F,KAAK,CAAG,GAAAzH,kBAAA,CAAAmI,gBAAgB,EAACR,KAAK,CAAgB,CAE9CF,KAAK,CAACrH,IAAI,CAAGyH,OAAO,CAACO,iBAAiB,CAMtC,KAAM,CAAApC,MAAM,CAAG/F,IAAI,CAACoI,gBAAgB,CAClCjI,IAAI,CACJqH,KAAK,CACLN,UAAU,CAAGF,uBAAuB,CAACQ,KAAK,CAAC5F,IAAI,CAAEsF,UAAU,CAAC,CAAG7F,SAAS,CACxEY,IAAI,CACL,CAKD,GAAI8D,MAAM,CAAE,CACVyB,KAAK,CAACzB,MAAM,CAAA1C,MAAA,CAAAmB,MAAA,IAAQgD,KAAK,CAACzB,MAAM,CAAKA,MAAM,CAAE,CAC/C,CAGA,MAAO,CAAA2B,KAAK,CACd,CAAC","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}