{"ast":null,"code":"import{isRunningInExpoGo}from'expo';import{createPermissionHook,Platform}from'expo-modules-core';import ExpoLocation from'./ExpoLocation';import{LocationAccuracy}from'./Location.types';import{LocationSubscriber,HeadingSubscriber,LocationErrorSubscriber}from'./LocationSubscribers';let warnAboutExpoGoDisplayed=false;export async function getProviderStatusAsync(){return ExpoLocation.getProviderStatusAsync();}export async function enableNetworkProviderAsync(){if(false){return ExpoLocation.enableNetworkProviderAsync();}}export async function getCurrentPositionAsync(options={}){return ExpoLocation.getCurrentPositionAsync(options);}export async function getLastKnownPositionAsync(options={}){return ExpoLocation.getLastKnownPositionAsync(options);}export async function watchPositionAsync(options,callback,errorHandler){const watchId=LocationSubscriber.registerCallback(callback);errorHandler&&LocationErrorSubscriber.registerCallbackForId(watchId,errorHandler);await ExpoLocation.watchPositionImplAsync(watchId,options);return{remove(){LocationSubscriber.unregisterCallback(watchId);errorHandler&&LocationErrorSubscriber.unregisterCallback(watchId);}};}export async function getHeadingAsync(){return new Promise(async(resolve,reject)=>{let tries=0;let subscriber=undefined;try{subscriber=await watchHeadingAsync(heading=>{if(heading.accuracy>1||tries>5){subscriber?.remove();resolve(heading);}else{tries+=1;}},reason=>{subscriber?.remove();reject(reason);});}catch(e){reject(e);}});}export async function watchHeadingAsync(callback,errorHandler){const watchId=HeadingSubscriber.registerCallback(callback);errorHandler&&LocationErrorSubscriber.registerCallbackForId(watchId,errorHandler);await ExpoLocation.watchDeviceHeading(watchId);return{remove(){HeadingSubscriber.unregisterCallback(watchId);errorHandler&&LocationErrorSubscriber.unregisterCallback(watchId);}};}export async function geocodeAsync(address){if(typeof address!=='string'){throw new TypeError(`Address to geocode must be a string. Got ${address} instead.`);}if(true){if(false){console.warn('The Geocoding API has been removed in SDK 49, use Place Autocomplete service instead'+'(https://developers.google.com/maps/documentation/places/web-service/autocomplete)');}return[];}return await ExpoLocation.geocodeAsync(address);}export async function reverseGeocodeAsync(location){if(typeof location.latitude!=='number'||typeof location.longitude!=='number'){throw new TypeError('Location to reverse-geocode must be an object with number properties `latitude` and `longitude`.');}if(true){if(false){console.warn('The Geocoding API has been removed in SDK 49, use Place Autocomplete service instead'+'(https://developers.google.com/maps/documentation/places/web-service/autocomplete)');}return[];}return await ExpoLocation.reverseGeocodeAsync(location);}export async function getForegroundPermissionsAsync(){return await ExpoLocation.getForegroundPermissionsAsync();}export async function requestForegroundPermissionsAsync(){return await ExpoLocation.requestForegroundPermissionsAsync();}export const useForegroundPermissions=createPermissionHook({getMethod:getForegroundPermissionsAsync,requestMethod:requestForegroundPermissionsAsync});export async function getBackgroundPermissionsAsync(){return await ExpoLocation.getBackgroundPermissionsAsync();}export async function requestBackgroundPermissionsAsync(){return await ExpoLocation.requestBackgroundPermissionsAsync();}export const useBackgroundPermissions=createPermissionHook({getMethod:getBackgroundPermissionsAsync,requestMethod:requestBackgroundPermissionsAsync});export async function hasServicesEnabledAsync(){return await ExpoLocation.hasServicesEnabledAsync();}function _validate(taskName){if(!taskName||typeof taskName!=='string'){throw new Error(`\\`taskName\\` must be a non-empty string. Got ${taskName} instead.`);}if(isRunningInExpoGo()){if(!warnAboutExpoGoDisplayed){const message='Background location is limited in Expo Go:\\n'+'On Android, it is not available at all.\\n'+'On iOS, it works when running in the Simulator.\\n'+'Please use a development build to avoid limitations. Learn more: https://expo.fyi/dev-client.';console.warn(message);warnAboutExpoGoDisplayed=true;}}}export async function isBackgroundLocationAvailableAsync(){const providerStatus=await getProviderStatusAsync();return providerStatus.backgroundModeEnabled;}export async function startLocationUpdatesAsync(taskName,options={accuracy:LocationAccuracy.Balanced}){_validate(taskName);await ExpoLocation.startLocationUpdatesAsync(taskName,options);}export async function stopLocationUpdatesAsync(taskName){_validate(taskName);await ExpoLocation.stopLocationUpdatesAsync(taskName);}export async function hasStartedLocationUpdatesAsync(taskName){_validate(taskName);return ExpoLocation.hasStartedLocationUpdatesAsync(taskName);}function _validateRegions(regions){if(!regions||regions.length===0){throw new Error('Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions');}for(const region of regions){if(typeof region.latitude!=='number'){throw new TypeError(`Region's latitude must be a number. Got '${region.latitude}' instead.`);}if(typeof region.longitude!=='number'){throw new TypeError(`Region's longitude must be a number. Got '${region.longitude}' instead.`);}if(typeof region.radius!=='number'){throw new TypeError(`Region's radius must be a number. Got '${region.radius}' instead.`);}}}export async function startGeofencingAsync(taskName,regions=[]){_validate(taskName);_validateRegions(regions);await ExpoLocation.startGeofencingAsync(taskName,{regions});}export async function stopGeofencingAsync(taskName){_validate(taskName);await ExpoLocation.stopGeofencingAsync(taskName);}export async function hasStartedGeofencingAsync(taskName){_validate(taskName);return ExpoLocation.hasStartedGeofencingAsync(taskName);}","map":{"version":3,"names":["isRunningInExpoGo","createPermissionHook","Platform","ExpoLocation","LocationAccuracy","LocationSubscriber","HeadingSubscriber","LocationErrorSubscriber","warnAboutExpoGoDisplayed","getProviderStatusAsync","enableNetworkProviderAsync","getCurrentPositionAsync","options","getLastKnownPositionAsync","watchPositionAsync","callback","errorHandler","watchId","registerCallback","registerCallbackForId","watchPositionImplAsync","remove","unregisterCallback","getHeadingAsync","Promise","resolve","reject","tries","subscriber","undefined","watchHeadingAsync","heading","accuracy","reason","e","watchDeviceHeading","geocodeAsync","address","TypeError","console","warn","reverseGeocodeAsync","location","latitude","longitude","getForegroundPermissionsAsync","requestForegroundPermissionsAsync","useForegroundPermissions","getMethod","requestMethod","getBackgroundPermissionsAsync","requestBackgroundPermissionsAsync","useBackgroundPermissions","hasServicesEnabledAsync","_validate","taskName","Error","message","isBackgroundLocationAvailableAsync","providerStatus","backgroundModeEnabled","startLocationUpdatesAsync","Balanced","stopLocationUpdatesAsync","hasStartedLocationUpdatesAsync","_validateRegions","regions","length","region","radius","startGeofencingAsync","stopGeofencingAsync","hasStartedGeofencingAsync"],"sources":["/home/user/rork-vibesync-458/node_modules/expo-location/src/Location.ts"],"sourcesContent":["import { isRunningInExpoGo } from 'expo';\nimport { PermissionResponse, createPermissionHook, Platform } from 'expo-modules-core';\n\nimport ExpoLocation from './ExpoLocation';\nimport {\n  LocationErrorCallback,\n  LocationAccuracy,\n  LocationCallback,\n  LocationGeocodedAddress,\n  LocationGeocodedLocation,\n  LocationHeadingCallback,\n  LocationHeadingObject,\n  LocationLastKnownOptions,\n  LocationObject,\n  LocationOptions,\n  LocationPermissionResponse,\n  LocationProviderStatus,\n  LocationRegion,\n  LocationSubscription,\n  LocationTaskOptions,\n} from './Location.types';\nimport {\n  LocationSubscriber,\n  HeadingSubscriber,\n  LocationErrorSubscriber,\n} from './LocationSubscribers';\n\n// Flag for warning about background services not being available in Expo Go\nlet warnAboutExpoGoDisplayed = false;\n\n// @needsAudit\n/**\n * Check status of location providers.\n * @return A promise which fulfills with an object of type [`LocationProviderStatus`](#locationproviderstatus).\n */\nexport async function getProviderStatusAsync(): Promise<LocationProviderStatus> {\n  return ExpoLocation.getProviderStatusAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to turn on high accuracy location mode which enables network provider that uses\n * Google Play services to improve location accuracy and location-based services.\n * @return A promise resolving as soon as the user accepts the dialog. Rejects if denied.\n *\n * @platform android\n */\nexport async function enableNetworkProviderAsync(): Promise<void> {\n  // If network provider is disabled (user's location mode is set to \"Device only\"),\n  // Android's location provider may not give you any results. Use this method in order to ask the user\n  // to change the location mode to \"High accuracy\" which uses Google Play services and enables network provider.\n  // `getCurrentPositionAsync` and `watchPositionAsync` are doing it automatically anyway.\n\n  if (Platform.OS === 'android') {\n    return ExpoLocation.enableNetworkProviderAsync();\n  }\n}\n\n// @needsAudit\n/**\n * Requests for one-time delivery of the user's current location.\n * Depending on given `accuracy` option it may take some time to resolve,\n * especially when you're inside a building.\n * > __Note:__ Calling it causes the location manager to obtain a location fix which may take several\n * > seconds. Consider using [`getLastKnownPositionAsync`](#locationgetlastknownpositionasyncoptions)\n * > if you expect to get a quick response and high accuracy is not required.\n * @param options\n * @return A promise which fulfills with an object of type [`LocationObject`](#locationobject).\n */\nexport async function getCurrentPositionAsync(\n  options: LocationOptions = {}\n): Promise<LocationObject> {\n  return ExpoLocation.getCurrentPositionAsync(options);\n}\n\n// @needsAudit\n/**\n * Gets the last known position of the device or `null` if it's not available or doesn't match given\n * requirements such as maximum age or required accuracy.\n * It's considered to be faster than `getCurrentPositionAsync` as it doesn't request for the current\n * location, but keep in mind the returned location may not be up-to-date.\n * @param options\n * @return A promise which fulfills with an object of type [`LocationObject`](#locationobject) or\n * `null` if it's not available or doesn't match given requirements such as maximum age or required\n * accuracy.\n */\nexport async function getLastKnownPositionAsync(\n  options: LocationLastKnownOptions = {}\n): Promise<LocationObject | null> {\n  return ExpoLocation.getLastKnownPositionAsync(options);\n}\n\n// @needsAudit\n/**\n * Subscribe to location updates from the device. Please note that updates will only occur while the\n * application is in the foreground. To get location updates while in background you'll need to use\n * [`startLocationUpdatesAsync`](#locationstartlocationupdatesasynctaskname-options).\n * @param options\n * @param callback This function is called on each location update. It receives an object of type\n * [`LocationObject`](#locationobject) as the first argument.\n * @param errorHandler This function is called when an error occurs. It receives a string with the\n * error message as the first argument.\n * @return A promise which fulfills with a [`LocationSubscription`](#locationsubscription) object.\n */\nexport async function watchPositionAsync(\n  options: LocationOptions,\n  callback: LocationCallback,\n  errorHandler?: LocationErrorCallback\n): Promise<LocationSubscription> {\n  const watchId = LocationSubscriber.registerCallback(callback);\n  errorHandler && LocationErrorSubscriber.registerCallbackForId(watchId, errorHandler);\n\n  await ExpoLocation.watchPositionImplAsync(watchId, options);\n\n  return {\n    remove() {\n      LocationSubscriber.unregisterCallback(watchId);\n      errorHandler && LocationErrorSubscriber.unregisterCallback(watchId);\n    },\n  };\n}\n\n// @needsAudit\n/**\n * Gets the current heading information from the device. To simplify, it calls `watchHeadingAsync`\n * and waits for a couple of updates, and then returns the one that is accurate enough.\n * @return A promise which fulfills with an object of type [`LocationHeadingObject`](#locationheadingobject).\n */\nexport async function getHeadingAsync(): Promise<LocationHeadingObject> {\n  return new Promise(async (resolve, reject) => {\n    let tries = 0;\n    let subscriber: LocationSubscription | undefined = undefined;\n\n    try {\n      subscriber = await watchHeadingAsync(\n        (heading) => {\n          if (heading.accuracy > 1 || tries > 5) {\n            subscriber?.remove();\n            resolve(heading);\n          } else {\n            tries += 1;\n          }\n        },\n        (reason) => {\n          subscriber?.remove();\n          reject(reason);\n        }\n      );\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\n// @needsAudit\n/**\n * Subscribe to compass updates from the device.\n *\n * @param callback This function is called on each compass update. It receives an object of type\n * [LocationHeadingObject](#locationheadingobject) as the first argument.\n * @param errorHandler This function is called when an error occurs. It receives a string with the\n * error message as the first argument.\n * @return A promise which fulfills with a [`LocationSubscription`](#locationsubscription) object.\n *\n * @platform android\n * @platform ios\n */\nexport async function watchHeadingAsync(\n  callback: LocationHeadingCallback,\n  errorHandler?: LocationErrorCallback\n): Promise<LocationSubscription> {\n  const watchId = HeadingSubscriber.registerCallback(callback);\n  errorHandler && LocationErrorSubscriber.registerCallbackForId(watchId, errorHandler);\n\n  await ExpoLocation.watchDeviceHeading(watchId);\n\n  return {\n    remove() {\n      HeadingSubscriber.unregisterCallback(watchId);\n      errorHandler && LocationErrorSubscriber.unregisterCallback(watchId);\n    },\n  };\n}\n\n// @needsAudit\n/**\n * Geocode an address string to latitude-longitude location.\n *\n * On Android, you must request location permissions with [`requestForegroundPermissionsAsync`](#locationrequestforegroundpermissionsasync)\n * before geocoding can be used.\n *\n * > **Note**: Geocoding is resource consuming and has to be used reasonably. Creating too many\n * > requests at a time can result in an error, so they have to be managed properly.\n * > It's also discouraged to use geocoding while the app is in the background and its results won't\n * > be shown to the user immediately.\n *\n * @param address A string representing address, eg. `\"Baker Street London\"`.\n * @return A promise which fulfills with an array (in most cases its size is 1) of [`LocationGeocodedLocation`](#locationgeocodedlocation)\n * objects.\n *\n * @platform android\n * @platform ios\n */\nexport async function geocodeAsync(address: string): Promise<LocationGeocodedLocation[]> {\n  if (typeof address !== 'string') {\n    throw new TypeError(`Address to geocode must be a string. Got ${address} instead.`);\n  }\n\n  if (Platform.OS === 'web') {\n    if (__DEV__) {\n      console.warn(\n        'The Geocoding API has been removed in SDK 49, use Place Autocomplete service instead' +\n          '(https://developers.google.com/maps/documentation/places/web-service/autocomplete)'\n      );\n    }\n    return [];\n  }\n\n  return await ExpoLocation.geocodeAsync(address);\n}\n\n// @needsAudit\n/**\n * Reverse geocode a location to postal address.\n *\n * On Android, you must request location permissions with [`requestForegroundPermissionsAsync`](#locationrequestforegroundpermissionsasync)\n * before geocoding can be used.\n *\n * > **Note**: Geocoding is resource consuming and has to be used reasonably. Creating too many\n * > requests at a time can result in an error, so they have to be managed properly.\n * > It's also discouraged to use geocoding while the app is in the background and its results won't\n * > be shown to the user immediately.\n *\n * @param location An object representing a location.\n * @return A promise which fulfills with an array (in most cases its size is 1) of [`LocationGeocodedAddress`](#locationgeocodedaddress) objects.\n *\n * @platform android\n * @platform ios\n */\nexport async function reverseGeocodeAsync(\n  location: Pick<LocationGeocodedLocation, 'latitude' | 'longitude'>\n): Promise<LocationGeocodedAddress[]> {\n  if (typeof location.latitude !== 'number' || typeof location.longitude !== 'number') {\n    throw new TypeError(\n      'Location to reverse-geocode must be an object with number properties `latitude` and `longitude`.'\n    );\n  }\n\n  if (Platform.OS === 'web') {\n    if (__DEV__) {\n      console.warn(\n        'The Geocoding API has been removed in SDK 49, use Place Autocomplete service instead' +\n          '(https://developers.google.com/maps/documentation/places/web-service/autocomplete)'\n      );\n    }\n    return [];\n  }\n\n  return await ExpoLocation.reverseGeocodeAsync(location);\n}\n\n// @needsAudit\n/**\n * Checks user's permissions for accessing location while the app is in the foreground.\n * @return A promise that fulfills with an object of type [`LocationPermissionResponse`](#locationpermissionresponse).\n */\nexport async function getForegroundPermissionsAsync(): Promise<LocationPermissionResponse> {\n  return await ExpoLocation.getForegroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to grant permissions for location while the app is in the foreground.\n * @return A promise that fulfills with an object of type [`LocationPermissionResponse`](#locationpermissionresponse).\n */\nexport async function requestForegroundPermissionsAsync(): Promise<LocationPermissionResponse> {\n  return await ExpoLocation.requestForegroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Check or request permissions for the foreground location.\n * This uses both `requestForegroundPermissionsAsync` and `getForegroundPermissionsAsync` to interact with the permissions.\n *\n * @example\n * ```ts\n * const [status, requestPermission] = Location.useForegroundPermissions();\n * ```\n */\nexport const useForegroundPermissions = createPermissionHook({\n  getMethod: getForegroundPermissionsAsync,\n  requestMethod: requestForegroundPermissionsAsync,\n});\n\n// @needsAudit\n/**\n * Checks user's permissions for accessing location while the app is in the background.\n * @return A promise that fulfills with an object of type [`PermissionResponse`](#permissionresponse).\n */\nexport async function getBackgroundPermissionsAsync(): Promise<PermissionResponse> {\n  return await ExpoLocation.getBackgroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Asks the user to grant permissions for location while the app is in the background.\n * On __Android 11 or higher__: this method will open the system settings page - before that happens\n * you should explain to the user why your application needs background location permission.\n * For example, you can use `Modal` component from `react-native` to do that.\n * > __Note__: Foreground permissions should be granted before asking for the background permissions\n * (your app can't obtain background permission without foreground permission).\n * @return A promise that fulfills with an object of type [`PermissionResponse`](#permissionresponse).\n */\nexport async function requestBackgroundPermissionsAsync(): Promise<PermissionResponse> {\n  return await ExpoLocation.requestBackgroundPermissionsAsync();\n}\n\n// @needsAudit\n/**\n * Check or request permissions for the background location.\n * This uses both `requestBackgroundPermissionsAsync` and `getBackgroundPermissionsAsync` to\n * interact with the permissions.\n *\n * @example\n * ```ts\n * const [status, requestPermission] = Location.useBackgroundPermissions();\n * ```\n */\nexport const useBackgroundPermissions = createPermissionHook({\n  getMethod: getBackgroundPermissionsAsync,\n  requestMethod: requestBackgroundPermissionsAsync,\n});\n\n// --- Location service\n\n// @needsAudit\n/**\n * Checks whether location services are enabled by the user.\n * @return A promise which fulfills to `true` if location services are enabled on the device,\n * or `false` if not.\n */\nexport async function hasServicesEnabledAsync(): Promise<boolean> {\n  return await ExpoLocation.hasServicesEnabledAsync();\n}\n\n// --- Background location updates\n\nfunction _validate(taskName: string) {\n  if (!taskName || typeof taskName !== 'string') {\n    throw new Error(`\\`taskName\\` must be a non-empty string. Got ${taskName} instead.`);\n  }\n  if (isRunningInExpoGo()) {\n    if (!warnAboutExpoGoDisplayed) {\n      const message =\n        'Background location is limited in Expo Go:\\n' +\n        'On Android, it is not available at all.\\n' +\n        'On iOS, it works when running in the Simulator.\\n' +\n        'Please use a development build to avoid limitations. Learn more: https://expo.fyi/dev-client.';\n      console.warn(message);\n      warnAboutExpoGoDisplayed = true;\n    }\n  }\n}\n\n// @docsMissing\nexport async function isBackgroundLocationAvailableAsync(): Promise<boolean> {\n  const providerStatus = await getProviderStatusAsync();\n  return providerStatus.backgroundModeEnabled;\n}\n\n// @needsAudit\n/**\n * Registers for receiving location updates that can also come when the app is in the background.\n *\n * # Task parameters\n *\n * Background location task will be receiving following data:\n * - `locations` - An array of the new locations.\n *\n * @example\n * ```ts\n * import * as TaskManager from 'expo-task-manager';\n *\n * TaskManager.defineTask(YOUR_TASK_NAME, ({ data: { locations }, error }) => {\n *  if (error) {\n *    // check `error.message` for more details.\n *    return;\n *  }\n *  console.log('Received new locations', locations);\n * });\n * ```\n *\n * @param taskName Name of the task receiving location updates.\n * @param options An object of options passed to the location manager.\n *\n * @return A promise resolving once the task with location updates is registered.\n */\nexport async function startLocationUpdatesAsync(\n  taskName: string,\n  options: LocationTaskOptions = { accuracy: LocationAccuracy.Balanced }\n): Promise<void> {\n  _validate(taskName);\n  await ExpoLocation.startLocationUpdatesAsync(taskName, options);\n}\n\n// @needsAudit\n/**\n * Stops location updates for specified task.\n * @param taskName Name of the background location task to stop.\n * @return A promise resolving as soon as the task is unregistered.\n */\nexport async function stopLocationUpdatesAsync(taskName: string): Promise<void> {\n  _validate(taskName);\n  await ExpoLocation.stopLocationUpdatesAsync(taskName);\n}\n\n// @needsAudit\n/**\n * @param taskName Name of the location task to check.\n * @return A promise which fulfills with boolean value indicating whether the location task is\n * started or not.\n */\nexport async function hasStartedLocationUpdatesAsync(taskName: string): Promise<boolean> {\n  _validate(taskName);\n  return ExpoLocation.hasStartedLocationUpdatesAsync(taskName);\n}\n\n// --- Geofencing\n\nfunction _validateRegions(regions: LocationRegion[]) {\n  if (!regions || regions.length === 0) {\n    throw new Error(\n      'Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions'\n    );\n  }\n  for (const region of regions) {\n    if (typeof region.latitude !== 'number') {\n      throw new TypeError(`Region's latitude must be a number. Got '${region.latitude}' instead.`);\n    }\n    if (typeof region.longitude !== 'number') {\n      throw new TypeError(\n        `Region's longitude must be a number. Got '${region.longitude}' instead.`\n      );\n    }\n    if (typeof region.radius !== 'number') {\n      throw new TypeError(`Region's radius must be a number. Got '${region.radius}' instead.`);\n    }\n  }\n}\n\n// @needsAudit\n/**\n * Starts geofencing for given regions. When the new event comes, the task with specified name will\n * be called with the region that the device enter to or exit from.\n * If you want to add or remove regions from already running geofencing task, you can just call\n * `startGeofencingAsync` again with the new array of regions.\n *\n * # Task parameters\n *\n * Geofencing task will be receiving following data:\n *  - `eventType` - Indicates the reason for calling the task, which can be triggered by entering or exiting the region.\n *    See [`GeofencingEventType`](#geofencingeventtype).\n *  - `region` - Object containing details about updated region. See [`LocationRegion`](#locationregion) for more details.\n *\n * @param taskName Name of the task that will be called when the device enters or exits from specified regions.\n * @param regions Array of region objects to be geofenced.\n *\n * @return A promise resolving as soon as the task is registered.\n *\n * @example\n * ```ts\n * import { GeofencingEventType } from 'expo-location';\n * import * as TaskManager from 'expo-task-manager';\n *\n *  TaskManager.defineTask(YOUR_TASK_NAME, ({ data: { eventType, region }, error }) => {\n *   if (error) {\n *     // check `error.message` for more details.\n *     return;\n *   }\n *   if (eventType === GeofencingEventType.Enter) {\n *     console.log(\"You've entered region:\", region);\n *   } else if (eventType === GeofencingEventType.Exit) {\n *     console.log(\"You've left region:\", region);\n *   }\n * });\n * ```\n */\nexport async function startGeofencingAsync(\n  taskName: string,\n  regions: LocationRegion[] = []\n): Promise<void> {\n  _validate(taskName);\n  _validateRegions(regions);\n  await ExpoLocation.startGeofencingAsync(taskName, { regions });\n}\n\n// @needsAudit\n/**\n * Stops geofencing for specified task. It unregisters the background task so the app will not be\n * receiving any updates, especially in the background.\n * @param taskName Name of the task to unregister.\n * @return A promise resolving as soon as the task is unregistered.\n */\nexport async function stopGeofencingAsync(taskName: string): Promise<void> {\n  _validate(taskName);\n  await ExpoLocation.stopGeofencingAsync(taskName);\n}\n\n// @needsAudit\n/**\n * @param taskName Name of the geofencing task to check.\n * @return A promise which fulfills with boolean value indicating whether the geofencing task is\n * started or not.\n */\nexport async function hasStartedGeofencingAsync(taskName: string): Promise<boolean> {\n  _validate(taskName);\n  return ExpoLocation.hasStartedGeofencingAsync(taskName);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}