{"ast":null,"code":"'use strict';import{_updatePropsJS}from\"../../js-reanimated/index.js\";export const snapshots=new WeakMap();export function makeElementVisible(element,delay){if(delay===0){_updatePropsJS({visibility:'initial'},element);}else{setTimeout(()=>{_updatePropsJS({visibility:'initial'},element);},delay*1000);}}function fixElementPosition(element,parent,snapshot){const parentRect=parent.getBoundingClientRect();const parentBorderTopValue=parseInt(getComputedStyle(parent).borderTopWidth);const parentBorderLeftValue=parseInt(getComputedStyle(parent).borderLeftWidth);const dummyRect=element.getBoundingClientRect();if(dummyRect.top!==snapshot.top){element.style.top=`${snapshot.top-parentRect.top-parentBorderTopValue}px`;}if(dummyRect.left!==snapshot.left){element.style.left=`${snapshot.left-parentRect.left-parentBorderLeftValue}px`;}}export function setElementPosition(element,snapshot){element.style.transform='';element.style.position='absolute';element.style.top=`${snapshot.top}px`;element.style.left=`${snapshot.left}px`;element.style.width=`${snapshot.width}px`;element.style.height=`${snapshot.height}px`;element.style.margin='0px';if(element.parentElement){fixElementPosition(element,element.parentElement,snapshot);}}","map":{"version":3,"names":["_updatePropsJS","snapshots","WeakMap","makeElementVisible","element","delay","visibility","setTimeout","fixElementPosition","parent","snapshot","parentRect","getBoundingClientRect","parentBorderTopValue","parseInt","getComputedStyle","borderTopWidth","parentBorderLeftValue","borderLeftWidth","dummyRect","top","style","left","setElementPosition","transform","position","width","height","margin","parentElement"],"sources":["/home/user/rork-vibesync-458/node_modules/react-native-reanimated/src/layoutReanimation/web/componentStyle.ts"],"sourcesContent":["'use strict';\n\nimport { _updatePropsJS } from '../../js-reanimated';\nimport type { ReanimatedHTMLElement } from '../../js-reanimated';\n\nexport interface ReanimatedSnapshot {\n  top: number;\n  left: number;\n  width: number;\n  height: number;\n  scrollOffsets: ScrollOffsets;\n}\n\nexport interface ScrollOffsets {\n  scrollTopOffset: number;\n  scrollLeftOffset: number;\n}\n\nexport const snapshots = new WeakMap<HTMLElement, ReanimatedSnapshot>();\n\nexport function makeElementVisible(element: HTMLElement, delay: number) {\n  if (delay === 0) {\n    _updatePropsJS({ visibility: 'initial' }, element as ReanimatedHTMLElement);\n  } else {\n    setTimeout(() => {\n      _updatePropsJS(\n        { visibility: 'initial' },\n        element as ReanimatedHTMLElement\n      );\n    }, delay * 1000);\n  }\n}\n\nfunction fixElementPosition(\n  element: HTMLElement,\n  parent: HTMLElement,\n  snapshot: ReanimatedSnapshot\n) {\n  const parentRect = parent.getBoundingClientRect();\n\n  const parentBorderTopValue = parseInt(\n    getComputedStyle(parent).borderTopWidth\n  );\n\n  const parentBorderLeftValue = parseInt(\n    getComputedStyle(parent).borderLeftWidth\n  );\n\n  const dummyRect = element.getBoundingClientRect();\n  // getBoundingClientRect returns DOMRect with position of the element with respect to document body.\n  // However, using position `absolute` doesn't guarantee, that the dummy will be placed relative to body element.\n  // The trick below allows us to once again get position relative to body, by comparing snapshot with new position of the dummy.\n  if (dummyRect.top !== snapshot.top) {\n    element.style.top = `${\n      snapshot.top - parentRect.top - parentBorderTopValue\n    }px`;\n  }\n\n  if (dummyRect.left !== snapshot.left) {\n    element.style.left = `${\n      snapshot.left - parentRect.left - parentBorderLeftValue\n    }px`;\n  }\n}\n\nexport function setElementPosition(\n  element: HTMLElement,\n  snapshot: ReanimatedSnapshot\n) {\n  element.style.transform = '';\n  element.style.position = 'absolute';\n  element.style.top = `${snapshot.top}px`;\n  element.style.left = `${snapshot.left}px`;\n  element.style.width = `${snapshot.width}px`;\n  element.style.height = `${snapshot.height}px`;\n  element.style.margin = '0px'; // tmpElement has absolute position, so margin is not necessary\n\n  if (element.parentElement) {\n    fixElementPosition(element, element.parentElement, snapshot);\n  }\n}\n"],"mappings":"AAAA,YAAY,CAEZ,OAASA,cAAc,KAAQ,8BAAqB,CAgBpD,MAAO,MAAM,CAAAC,SAAS,CAAG,GAAI,CAAAC,OAAO,CAAkC,CAAC,CAEvE,MAAO,SAAS,CAAAC,kBAAkBA,CAACC,OAAoB,CAAEC,KAAa,CAAE,CACtE,GAAIA,KAAK,GAAK,CAAC,CAAE,CACfL,cAAc,CAAC,CAAEM,UAAU,CAAE,SAAU,CAAC,CAAEF,OAAgC,CAAC,CAC7E,CAAC,IAAM,CACLG,UAAU,CAAC,IAAM,CACfP,cAAc,CACZ,CAAEM,UAAU,CAAE,SAAU,CAAC,CACzBF,OACF,CAAC,CACH,CAAC,CAAEC,KAAK,CAAG,IAAI,CAAC,CAClB,CACF,CAEA,QAAS,CAAAG,kBAAkBA,CACzBJ,OAAoB,CACpBK,MAAmB,CACnBC,QAA4B,CAC5B,CACA,KAAM,CAAAC,UAAU,CAAGF,MAAM,CAACG,qBAAqB,CAAC,CAAC,CAEjD,KAAM,CAAAC,oBAAoB,CAAGC,QAAQ,CACnCC,gBAAgB,CAACN,MAAM,CAAC,CAACO,cAC3B,CAAC,CAED,KAAM,CAAAC,qBAAqB,CAAGH,QAAQ,CACpCC,gBAAgB,CAACN,MAAM,CAAC,CAACS,eAC3B,CAAC,CAED,KAAM,CAAAC,SAAS,CAAGf,OAAO,CAACQ,qBAAqB,CAAC,CAAC,CAIjD,GAAIO,SAAS,CAACC,GAAG,GAAKV,QAAQ,CAACU,GAAG,CAAE,CAClChB,OAAO,CAACiB,KAAK,CAACD,GAAG,CAAG,GAClBV,QAAQ,CAACU,GAAG,CAAGT,UAAU,CAACS,GAAG,CAAGP,oBAAoB,IAClD,CACN,CAEA,GAAIM,SAAS,CAACG,IAAI,GAAKZ,QAAQ,CAACY,IAAI,CAAE,CACpClB,OAAO,CAACiB,KAAK,CAACC,IAAI,CAAG,GACnBZ,QAAQ,CAACY,IAAI,CAAGX,UAAU,CAACW,IAAI,CAAGL,qBAAqB,IACrD,CACN,CACF,CAEA,MAAO,SAAS,CAAAM,kBAAkBA,CAChCnB,OAAoB,CACpBM,QAA4B,CAC5B,CACAN,OAAO,CAACiB,KAAK,CAACG,SAAS,CAAG,EAAE,CAC5BpB,OAAO,CAACiB,KAAK,CAACI,QAAQ,CAAG,UAAU,CACnCrB,OAAO,CAACiB,KAAK,CAACD,GAAG,CAAG,GAAGV,QAAQ,CAACU,GAAG,IAAI,CACvChB,OAAO,CAACiB,KAAK,CAACC,IAAI,CAAG,GAAGZ,QAAQ,CAACY,IAAI,IAAI,CACzClB,OAAO,CAACiB,KAAK,CAACK,KAAK,CAAG,GAAGhB,QAAQ,CAACgB,KAAK,IAAI,CAC3CtB,OAAO,CAACiB,KAAK,CAACM,MAAM,CAAG,GAAGjB,QAAQ,CAACiB,MAAM,IAAI,CAC7CvB,OAAO,CAACiB,KAAK,CAACO,MAAM,CAAG,KAAK,CAE5B,GAAIxB,OAAO,CAACyB,aAAa,CAAE,CACzBrB,kBAAkB,CAACJ,OAAO,CAAEA,OAAO,CAACyB,aAAa,CAAEnB,QAAQ,CAAC,CAC9D,CACF","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}