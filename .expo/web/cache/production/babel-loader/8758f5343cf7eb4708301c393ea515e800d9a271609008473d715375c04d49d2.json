{"ast":null,"code":"function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}import{PointerType}from'../../PointerType';import{State}from'../../State';import PointerTracker from'./PointerTracker';export default class GestureHandlerOrchestrator{constructor(){_defineProperty(this,\"gestureHandlers\",[]);_defineProperty(this,\"awaitingHandlers\",[]);_defineProperty(this,\"awaitingHandlersTags\",new Set());_defineProperty(this,\"handlingChangeSemaphore\",0);_defineProperty(this,\"activationIndex\",0);}scheduleFinishedHandlersCleanup(){if(this.handlingChangeSemaphore===0){this.cleanupFinishedHandlers();}}cleanHandler(handler){handler.reset();handler.active=false;handler.awaiting=false;handler.activationIndex=Number.MAX_VALUE;}removeHandlerFromOrchestrator(handler){const indexInGestureHandlers=this.gestureHandlers.indexOf(handler);const indexInAwaitingHandlers=this.awaitingHandlers.indexOf(handler);if(indexInGestureHandlers>=0){this.gestureHandlers.splice(indexInGestureHandlers,1);}if(indexInAwaitingHandlers>=0){this.awaitingHandlers.splice(indexInAwaitingHandlers,1);this.awaitingHandlersTags.delete(handler.handlerTag);}}cleanupFinishedHandlers(){const handlersToRemove=new Set();for(let i=this.gestureHandlers.length-1;i>=0;--i){const handler=this.gestureHandlers[i];if(this.isFinished(handler.state)&&!handler.awaiting){this.cleanHandler(handler);handlersToRemove.add(handler);}}this.gestureHandlers=this.gestureHandlers.filter(handler=>!handlersToRemove.has(handler));}hasOtherHandlerToWaitFor(handler){const hasToWaitFor=otherHandler=>{return!this.isFinished(otherHandler.state)&&this.shouldHandlerWaitForOther(handler,otherHandler);};return this.gestureHandlers.some(hasToWaitFor);}shouldBeCancelledByFinishedHandler(handler){const shouldBeCancelled=otherHandler=>{return this.shouldHandlerWaitForOther(handler,otherHandler)&&otherHandler.state===State.END;};return this.gestureHandlers.some(shouldBeCancelled);}tryActivate(handler){if(this.shouldBeCancelledByFinishedHandler(handler)){handler.cancel();return;}if(this.hasOtherHandlerToWaitFor(handler)){this.addAwaitingHandler(handler);return;}const handlerState=handler.state;if(handlerState===State.CANCELLED||handlerState===State.FAILED){return;}if(this.shouldActivate(handler)){this.makeActive(handler);return;}if(handlerState===State.ACTIVE){handler.fail();return;}if(handlerState===State.BEGAN){handler.cancel();}}shouldActivate(handler){const shouldBeCancelledBy=otherHandler=>{return this.shouldHandlerBeCancelledBy(handler,otherHandler);};return!this.gestureHandlers.some(shouldBeCancelledBy);}cleanupAwaitingHandlers(handler){const shouldWait=otherHandler=>{return!otherHandler.awaiting&&this.shouldHandlerWaitForOther(otherHandler,handler);};for(const otherHandler of this.awaitingHandlers){if(shouldWait(otherHandler)){this.cleanHandler(otherHandler);this.awaitingHandlersTags.delete(otherHandler.handlerTag);}}this.awaitingHandlers=this.awaitingHandlers.filter(otherHandler=>this.awaitingHandlersTags.has(otherHandler.handlerTag));}onHandlerStateChange(handler,newState,oldState,sendIfDisabled){if(!handler.enabled&&!sendIfDisabled){return;}this.handlingChangeSemaphore+=1;if(this.isFinished(newState)){for(const otherHandler of this.awaitingHandlers){if(!this.shouldHandlerWaitForOther(otherHandler,handler)||!this.awaitingHandlersTags.has(otherHandler.handlerTag)){continue;}if(newState!==State.END){this.tryActivate(otherHandler);continue;}otherHandler.cancel();if(otherHandler.state===State.END){otherHandler.sendEvent(State.CANCELLED,State.BEGAN);}otherHandler.awaiting=false;}}if(newState===State.ACTIVE){this.tryActivate(handler);}else if(oldState===State.ACTIVE||oldState===State.END){if(handler.active){handler.sendEvent(newState,oldState);}else if(oldState===State.ACTIVE&&(newState===State.CANCELLED||newState===State.FAILED)){handler.sendEvent(newState,State.BEGAN);}}else if(oldState!==State.UNDETERMINED||newState!==State.CANCELLED){handler.sendEvent(newState,oldState);}this.handlingChangeSemaphore-=1;this.scheduleFinishedHandlersCleanup();if(!this.awaitingHandlers.includes(handler)){this.cleanupAwaitingHandlers(handler);}}makeActive(handler){const currentState=handler.state;handler.active=true;handler.shouldResetProgress=true;handler.activationIndex=this.activationIndex++;for(let i=this.gestureHandlers.length-1;i>=0;--i){if(this.shouldHandlerBeCancelledBy(this.gestureHandlers[i],handler)){this.gestureHandlers[i].cancel();}}for(const otherHandler of this.awaitingHandlers){if(this.shouldHandlerBeCancelledBy(otherHandler,handler)){otherHandler.awaiting=false;}}handler.sendEvent(State.ACTIVE,State.BEGAN);if(currentState!==State.ACTIVE){handler.sendEvent(State.END,State.ACTIVE);if(currentState!==State.END){handler.sendEvent(State.UNDETERMINED,State.END);}}if(!handler.awaiting){return;}handler.awaiting=false;this.awaitingHandlers=this.awaitingHandlers.filter(otherHandler=>otherHandler!==handler);}addAwaitingHandler(handler){if(this.awaitingHandlers.includes(handler)){return;}this.awaitingHandlers.push(handler);this.awaitingHandlersTags.add(handler.handlerTag);handler.awaiting=true;handler.activationIndex=this.activationIndex++;}recordHandlerIfNotPresent(handler){if(this.gestureHandlers.includes(handler)){return;}this.gestureHandlers.push(handler);handler.active=false;handler.awaiting=false;handler.activationIndex=Number.MAX_SAFE_INTEGER;}shouldHandlerWaitForOther(handler,otherHandler){return handler!==otherHandler&&(handler.shouldWaitForHandlerFailure(otherHandler)||otherHandler.shouldRequireToWaitForFailure(handler));}canRunSimultaneously(gh1,gh2){return gh1===gh2||gh1.shouldRecognizeSimultaneously(gh2)||gh2.shouldRecognizeSimultaneously(gh1);}shouldHandlerBeCancelledBy(handler,otherHandler){if(this.canRunSimultaneously(handler,otherHandler)){return false;}if(handler.awaiting||handler.state===State.ACTIVE){return handler.shouldBeCancelledByOther(otherHandler);}const handlerPointers=handler.getTrackedPointersID();const otherPointers=otherHandler.getTrackedPointersID();if(!PointerTracker.shareCommonPointers(handlerPointers,otherPointers)&&handler.delegate.view!==otherHandler.delegate.view){return this.checkOverlap(handler,otherHandler);}return true;}checkOverlap(handler,otherHandler){const isPointerWithinBothBounds=pointer=>{const point=handler.tracker.getLastAbsoluteCoords(pointer);return handler.delegate.isPointerInBounds(point)&&otherHandler.delegate.isPointerInBounds(point);};return handler.getTrackedPointersID().some(isPointerWithinBothBounds);}isFinished(state){return state===State.END||state===State.FAILED||state===State.CANCELLED;}cancelMouseAndPenGestures(currentHandler){this.gestureHandlers.forEach(handler=>{if(handler.pointerType!==PointerType.MOUSE&&handler.pointerType!==PointerType.STYLUS){return;}if(handler!==currentHandler){handler.cancel();}else{handler.tracker.resetTracker();}});}static get instance(){if(!GestureHandlerOrchestrator._instance){GestureHandlerOrchestrator._instance=new GestureHandlerOrchestrator();}return GestureHandlerOrchestrator._instance;}}_defineProperty(GestureHandlerOrchestrator,\"_instance\",void 0);","map":{"version":3,"names":["PointerType","State","PointerTracker","GestureHandlerOrchestrator","constructor","_defineProperty","Set","scheduleFinishedHandlersCleanup","handlingChangeSemaphore","cleanupFinishedHandlers","cleanHandler","handler","reset","active","awaiting","activationIndex","Number","MAX_VALUE","removeHandlerFromOrchestrator","indexInGestureHandlers","gestureHandlers","indexOf","indexInAwaitingHandlers","awaitingHandlers","splice","awaitingHandlersTags","delete","handlerTag","handlersToRemove","i","length","isFinished","state","add","filter","has","hasOtherHandlerToWaitFor","hasToWaitFor","otherHandler","shouldHandlerWaitForOther","some","shouldBeCancelledByFinishedHandler","shouldBeCancelled","END","tryActivate","cancel","addAwaitingHandler","handlerState","CANCELLED","FAILED","shouldActivate","makeActive","ACTIVE","fail","BEGAN","shouldBeCancelledBy","shouldHandlerBeCancelledBy","cleanupAwaitingHandlers","shouldWait","onHandlerStateChange","newState","oldState","sendIfDisabled","enabled","sendEvent","UNDETERMINED","includes","currentState","shouldResetProgress","push","recordHandlerIfNotPresent","MAX_SAFE_INTEGER","shouldWaitForHandlerFailure","shouldRequireToWaitForFailure","canRunSimultaneously","gh1","gh2","shouldRecognizeSimultaneously","shouldBeCancelledByOther","handlerPointers","getTrackedPointersID","otherPointers","shareCommonPointers","delegate","view","checkOverlap","isPointerWithinBothBounds","pointer","point","tracker","getLastAbsoluteCoords","isPointerInBounds","cancelMouseAndPenGestures","currentHandler","forEach","pointerType","MOUSE","STYLUS","resetTracker","instance","_instance"],"sources":["/home/user/rork-vibesync-458/node_modules/react-native-gesture-handler/lib/module/web/tools/GestureHandlerOrchestrator.ts"],"sourcesContent":["import { PointerType } from '../../PointerType';\nimport { State } from '../../State';\n\nimport type IGestureHandler from '../handlers/IGestureHandler';\nimport PointerTracker from './PointerTracker';\n\nexport default class GestureHandlerOrchestrator {\n  private static _instance: GestureHandlerOrchestrator;\n\n  private gestureHandlers: IGestureHandler[] = [];\n  private awaitingHandlers: IGestureHandler[] = [];\n  private awaitingHandlersTags: Set<number> = new Set();\n\n  private handlingChangeSemaphore = 0;\n  private activationIndex = 0;\n\n  // Private beacuse of Singleton\n  // eslint-disable-next-line no-useless-constructor, @typescript-eslint/no-empty-function\n  private constructor() {}\n\n  private scheduleFinishedHandlersCleanup(): void {\n    if (this.handlingChangeSemaphore === 0) {\n      this.cleanupFinishedHandlers();\n    }\n  }\n\n  private cleanHandler(handler: IGestureHandler): void {\n    handler.reset();\n    handler.active = false;\n    handler.awaiting = false;\n    handler.activationIndex = Number.MAX_VALUE;\n  }\n\n  public removeHandlerFromOrchestrator(handler: IGestureHandler): void {\n    const indexInGestureHandlers = this.gestureHandlers.indexOf(handler);\n    const indexInAwaitingHandlers = this.awaitingHandlers.indexOf(handler);\n\n    if (indexInGestureHandlers >= 0) {\n      this.gestureHandlers.splice(indexInGestureHandlers, 1);\n    }\n\n    if (indexInAwaitingHandlers >= 0) {\n      this.awaitingHandlers.splice(indexInAwaitingHandlers, 1);\n      this.awaitingHandlersTags.delete(handler.handlerTag);\n    }\n  }\n\n  private cleanupFinishedHandlers(): void {\n    const handlersToRemove = new Set<IGestureHandler>();\n\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      const handler = this.gestureHandlers[i];\n\n      if (this.isFinished(handler.state) && !handler.awaiting) {\n        this.cleanHandler(handler);\n        handlersToRemove.add(handler);\n      }\n    }\n\n    this.gestureHandlers = this.gestureHandlers.filter(\n      (handler) => !handlersToRemove.has(handler)\n    );\n  }\n\n  private hasOtherHandlerToWaitFor(handler: IGestureHandler): boolean {\n    const hasToWaitFor = (otherHandler: IGestureHandler) => {\n      return (\n        !this.isFinished(otherHandler.state) &&\n        this.shouldHandlerWaitForOther(handler, otherHandler)\n      );\n    };\n\n    return this.gestureHandlers.some(hasToWaitFor);\n  }\n\n  private shouldBeCancelledByFinishedHandler(\n    handler: IGestureHandler\n  ): boolean {\n    const shouldBeCancelled = (otherHandler: IGestureHandler) => {\n      return (\n        this.shouldHandlerWaitForOther(handler, otherHandler) &&\n        otherHandler.state === State.END\n      );\n    };\n\n    return this.gestureHandlers.some(shouldBeCancelled);\n  }\n\n  private tryActivate(handler: IGestureHandler): void {\n    if (this.shouldBeCancelledByFinishedHandler(handler)) {\n      handler.cancel();\n      return;\n    }\n\n    if (this.hasOtherHandlerToWaitFor(handler)) {\n      this.addAwaitingHandler(handler);\n      return;\n    }\n\n    const handlerState = handler.state;\n\n    if (handlerState === State.CANCELLED || handlerState === State.FAILED) {\n      return;\n    }\n\n    if (this.shouldActivate(handler)) {\n      this.makeActive(handler);\n      return;\n    }\n\n    if (handlerState === State.ACTIVE) {\n      handler.fail();\n      return;\n    }\n\n    if (handlerState === State.BEGAN) {\n      handler.cancel();\n    }\n  }\n\n  private shouldActivate(handler: IGestureHandler): boolean {\n    const shouldBeCancelledBy = (otherHandler: IGestureHandler) => {\n      return this.shouldHandlerBeCancelledBy(handler, otherHandler);\n    };\n\n    return !this.gestureHandlers.some(shouldBeCancelledBy);\n  }\n\n  private cleanupAwaitingHandlers(handler: IGestureHandler): void {\n    const shouldWait = (otherHandler: IGestureHandler) => {\n      return (\n        !otherHandler.awaiting &&\n        this.shouldHandlerWaitForOther(otherHandler, handler)\n      );\n    };\n\n    for (const otherHandler of this.awaitingHandlers) {\n      if (shouldWait(otherHandler)) {\n        this.cleanHandler(otherHandler);\n        this.awaitingHandlersTags.delete(otherHandler.handlerTag);\n      }\n    }\n\n    this.awaitingHandlers = this.awaitingHandlers.filter((otherHandler) =>\n      this.awaitingHandlersTags.has(otherHandler.handlerTag)\n    );\n  }\n\n  public onHandlerStateChange(\n    handler: IGestureHandler,\n    newState: State,\n    oldState: State,\n    sendIfDisabled?: boolean\n  ): void {\n    if (!handler.enabled && !sendIfDisabled) {\n      return;\n    }\n\n    this.handlingChangeSemaphore += 1;\n\n    if (this.isFinished(newState)) {\n      for (const otherHandler of this.awaitingHandlers) {\n        if (\n          !this.shouldHandlerWaitForOther(otherHandler, handler) ||\n          !this.awaitingHandlersTags.has(otherHandler.handlerTag)\n        ) {\n          continue;\n        }\n\n        if (newState !== State.END) {\n          this.tryActivate(otherHandler);\n          continue;\n        }\n\n        otherHandler.cancel();\n\n        if (otherHandler.state === State.END) {\n          // Handle edge case, where discrete gestures end immediately after activation thus\n          // their state is set to END and when the gesture they are waiting for activates they\n          // should be cancelled, however `cancel` was never sent as gestures were already in the END state.\n          // Send synthetic BEGAN -> CANCELLED to properly handle JS logic\n          otherHandler.sendEvent(State.CANCELLED, State.BEGAN);\n        }\n\n        otherHandler.awaiting = false;\n      }\n    }\n\n    if (newState === State.ACTIVE) {\n      this.tryActivate(handler);\n    } else if (oldState === State.ACTIVE || oldState === State.END) {\n      if (handler.active) {\n        handler.sendEvent(newState, oldState);\n      } else if (\n        oldState === State.ACTIVE &&\n        (newState === State.CANCELLED || newState === State.FAILED)\n      ) {\n        handler.sendEvent(newState, State.BEGAN);\n      }\n    } else if (\n      oldState !== State.UNDETERMINED ||\n      newState !== State.CANCELLED\n    ) {\n      handler.sendEvent(newState, oldState);\n    }\n\n    this.handlingChangeSemaphore -= 1;\n\n    this.scheduleFinishedHandlersCleanup();\n\n    if (!this.awaitingHandlers.includes(handler)) {\n      this.cleanupAwaitingHandlers(handler);\n    }\n  }\n\n  private makeActive(handler: IGestureHandler): void {\n    const currentState = handler.state;\n\n    handler.active = true;\n    handler.shouldResetProgress = true;\n    handler.activationIndex = this.activationIndex++;\n\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      if (this.shouldHandlerBeCancelledBy(this.gestureHandlers[i], handler)) {\n        this.gestureHandlers[i].cancel();\n      }\n    }\n\n    for (const otherHandler of this.awaitingHandlers) {\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        otherHandler.awaiting = false;\n      }\n    }\n\n    handler.sendEvent(State.ACTIVE, State.BEGAN);\n\n    if (currentState !== State.ACTIVE) {\n      handler.sendEvent(State.END, State.ACTIVE);\n      if (currentState !== State.END) {\n        handler.sendEvent(State.UNDETERMINED, State.END);\n      }\n    }\n\n    if (!handler.awaiting) {\n      return;\n    }\n\n    handler.awaiting = false;\n\n    this.awaitingHandlers = this.awaitingHandlers.filter(\n      (otherHandler) => otherHandler !== handler\n    );\n  }\n\n  private addAwaitingHandler(handler: IGestureHandler): void {\n    if (this.awaitingHandlers.includes(handler)) {\n      return;\n    }\n\n    this.awaitingHandlers.push(handler);\n    this.awaitingHandlersTags.add(handler.handlerTag);\n\n    handler.awaiting = true;\n    handler.activationIndex = this.activationIndex++;\n  }\n\n  public recordHandlerIfNotPresent(handler: IGestureHandler): void {\n    if (this.gestureHandlers.includes(handler)) {\n      return;\n    }\n\n    this.gestureHandlers.push(handler);\n\n    handler.active = false;\n    handler.awaiting = false;\n    handler.activationIndex = Number.MAX_SAFE_INTEGER;\n  }\n\n  private shouldHandlerWaitForOther(\n    handler: IGestureHandler,\n    otherHandler: IGestureHandler\n  ): boolean {\n    return (\n      handler !== otherHandler &&\n      (handler.shouldWaitForHandlerFailure(otherHandler) ||\n        otherHandler.shouldRequireToWaitForFailure(handler))\n    );\n  }\n\n  private canRunSimultaneously(\n    gh1: IGestureHandler,\n    gh2: IGestureHandler\n  ): boolean {\n    return (\n      gh1 === gh2 ||\n      gh1.shouldRecognizeSimultaneously(gh2) ||\n      gh2.shouldRecognizeSimultaneously(gh1)\n    );\n  }\n\n  private shouldHandlerBeCancelledBy(\n    handler: IGestureHandler,\n    otherHandler: IGestureHandler\n  ): boolean {\n    if (this.canRunSimultaneously(handler, otherHandler)) {\n      return false;\n    }\n\n    if (handler.awaiting || handler.state === State.ACTIVE) {\n      // For now it always returns false\n      return handler.shouldBeCancelledByOther(otherHandler);\n    }\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    if (\n      !PointerTracker.shareCommonPointers(handlerPointers, otherPointers) &&\n      handler.delegate.view !== otherHandler.delegate.view\n    ) {\n      return this.checkOverlap(handler, otherHandler);\n    }\n\n    return true;\n  }\n\n  private checkOverlap(\n    handler: IGestureHandler,\n    otherHandler: IGestureHandler\n  ): boolean {\n    // If handlers don't have common pointers, default return value is false.\n    // However, if at least on pointer overlaps with both handlers, we return true\n    // This solves issue in overlapping parents example\n\n    // TODO: Find better way to handle that issue, for example by activation order and handler cancelling\n\n    const isPointerWithinBothBounds = (pointer: number) => {\n      const point = handler.tracker.getLastAbsoluteCoords(pointer);\n\n      return (\n        handler.delegate.isPointerInBounds(point) &&\n        otherHandler.delegate.isPointerInBounds(point)\n      );\n    };\n\n    return handler.getTrackedPointersID().some(isPointerWithinBothBounds);\n  }\n\n  private isFinished(state: State): boolean {\n    return (\n      state === State.END || state === State.FAILED || state === State.CANCELLED\n    );\n  }\n\n  // This function is called when handler receives touchdown event\n  // If handler is using mouse or pen as a pointer and any handler receives touch event,\n  // mouse/pen event dissappears - it doesn't send onPointerCancel nor onPointerUp (and others)\n  // This became a problem because handler was left at active state without any signal to end or fail\n  // To handle this, when new touch event is received, we loop through active handlers and check which type of\n  // pointer they're using. If there are any handler with mouse/pen as a pointer, we cancel them\n  public cancelMouseAndPenGestures(currentHandler: IGestureHandler): void {\n    this.gestureHandlers.forEach((handler: IGestureHandler) => {\n      if (\n        handler.pointerType !== PointerType.MOUSE &&\n        handler.pointerType !== PointerType.STYLUS\n      ) {\n        return;\n      }\n\n      if (handler !== currentHandler) {\n        handler.cancel();\n      } else {\n        // Handler that received touch event should have its pointer tracker reset\n        // This allows handler to smoothly change from mouse/pen to touch\n        // The drawback is, that when we try to use mouse/pen one more time, it doesn't send onPointerDown at the first time\n        // so it is required to click two times to get handler to work\n        //\n        // However, handler will receive manually created onPointerEnter that is triggered in EventManager in onPointerMove method.\n        // There may be possibility to use that fact to make handler respond properly to first mouse click\n        handler.tracker.resetTracker();\n      }\n    });\n  }\n\n  public static get instance(): GestureHandlerOrchestrator {\n    if (!GestureHandlerOrchestrator._instance) {\n      GestureHandlerOrchestrator._instance = new GestureHandlerOrchestrator();\n    }\n\n    return GestureHandlerOrchestrator._instance;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}