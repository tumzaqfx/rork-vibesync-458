{"ast":null,"code":"import{Platform,UnavailabilityError}from'expo-modules-core';import{Component,createRef}from'react';import ExpoCamera from'./ExpoCamera';import CameraManager from'./ExpoCameraManager';import{ConversionTables,ensureNativeProps}from'./utils/props';import{jsx as _jsx}from\"react/jsx-runtime\";const EventThrottleMs=500;const _PICTURE_SAVED_CALLBACKS={};let loggedRenderingChildrenWarning=false;let _GLOBAL_PICTURE_ID=1;function ensurePictureOptions(options){if(!options||typeof options!=='object'){return{};}if(options.quality===undefined){options.quality=1;}if(options.mirror){console.warn('The `mirror` option is deprecated. Please use the `mirror` prop on the `CameraView` instead.');}if(options.onPictureSaved){const id=_GLOBAL_PICTURE_ID++;_PICTURE_SAVED_CALLBACKS[id]=options.onPictureSaved;options.id=id;options.fastMode=true;}return options;}function ensureRecordingOptions(options={}){if(!options||typeof options!=='object'){return{};}if(options.mirror){console.warn('The `mirror` option is deprecated. Please use the `mirror` prop on the `CameraView` instead.');}return options;}function _onPictureSaved({nativeEvent}){const{id,data}=nativeEvent;const callback=_PICTURE_SAVED_CALLBACKS[id];if(callback){callback(data);delete _PICTURE_SAVED_CALLBACKS[id];}}export default class CameraView extends Component{static isModernBarcodeScannerAvailable=CameraManager.isModernBarcodeScannerAvailable;static async isAvailableAsync(){if(!CameraManager.isAvailableAsync){throw new UnavailabilityError('expo-camera','isAvailableAsync');}return CameraManager.isAvailableAsync();}static async getAvailableVideoCodecsAsync(){if(!CameraManager.getAvailableVideoCodecsAsync){throw new UnavailabilityError('Camera','getAvailableVideoCodecsAsync');}return CameraManager.getAvailableVideoCodecsAsync();}async getAvailablePictureSizesAsync(){return(await this._cameraRef.current?.getAvailablePictureSizes())??[];}async getAvailableLensesAsync(){return(await this._cameraRef.current?.getAvailableLenses())??[];}getSupportedFeatures(){return{isModernBarcodeScannerAvailable:CameraManager.isModernBarcodeScannerAvailable,toggleRecordingAsyncAvailable:CameraManager.toggleRecordingAsyncAvailable};}async resumePreview(){return this._cameraRef.current?.resumePreview();}async pausePreview(){return this._cameraRef.current?.pausePreview();}static ConversionTables=ConversionTables;static defaultProps={zoom:0,facing:'back',enableTorch:false,mode:'picture',flash:'off'};_cameraRef=createRef();_lastEvents={};_lastEventsTimes={};async takePictureAsync(options){const pictureOptions=ensurePictureOptions(options);if(false&&options?.pictureRef){return this._cameraRef.current?.takePictureRef?.(options);}return this._cameraRef.current?.takePicture(pictureOptions);}static async launchScanner(options){if(!options){options={barcodeTypes:[]};}if(false&&CameraView.isModernBarcodeScannerAvailable){await CameraManager.launchScanner(options);}}static async dismissScanner(){if(false&&CameraView.isModernBarcodeScannerAvailable){await CameraManager.dismissScanner();}}static onModernBarcodeScanned(listener){return CameraManager.addListener('onModernBarcodeScanned',listener);}async recordAsync(options){const recordingOptions=ensureRecordingOptions(options);return this._cameraRef.current?.record(recordingOptions);}async toggleRecordingAsync(){return this._cameraRef.current?.toggleRecording();}stopRecording(){this._cameraRef.current?.stopRecording();}_onCameraReady=()=>{if(this.props.onCameraReady){this.props.onCameraReady();}};_onAvailableLensesChanged=({nativeEvent})=>{if(this.props.onAvailableLensesChanged){this.props.onAvailableLensesChanged(nativeEvent);}};_onMountError=({nativeEvent})=>{if(this.props.onMountError){this.props.onMountError(nativeEvent);}};_onResponsiveOrientationChanged=({nativeEvent})=>{if(this.props.onResponsiveOrientationChanged){this.props.onResponsiveOrientationChanged(nativeEvent);}};_onObjectDetected=callback=>({nativeEvent})=>{const{type}=nativeEvent;if(this._lastEvents[type]&&this._lastEventsTimes[type]&&JSON.stringify(nativeEvent)===this._lastEvents[type]&&new Date().getTime()-this._lastEventsTimes[type].getTime()<EventThrottleMs){return;}if(callback){callback(nativeEvent);this._lastEventsTimes[type]=new Date();this._lastEvents[type]=JSON.stringify(nativeEvent);}};_setReference=ref=>{if(ref){if(true){this._cameraHandle=ref;}}};render(){const nativeProps=ensureNativeProps(this.props);const onBarcodeScanned=this.props.onBarcodeScanned?this._onObjectDetected(this.props.onBarcodeScanned):undefined;if(nativeProps.children&&!loggedRenderingChildrenWarning){console.warn('The <CameraView> component does not support children. This may lead to inconsistent behaviour or crashes. If you want to render content on top of the Camera, consider using absolute positioning.');loggedRenderingChildrenWarning=true;}return _jsx(ExpoCamera,Object.assign({},nativeProps,{ref:this._cameraRef,onCameraReady:this._onCameraReady,onMountError:this._onMountError,onBarcodeScanned:onBarcodeScanned,onAvailableLensesChanged:this._onAvailableLensesChanged,onPictureSaved:_onPictureSaved,onResponsiveOrientationChanged:this._onResponsiveOrientationChanged}));}}","map":{"version":3,"names":["Platform","UnavailabilityError","Component","createRef","ExpoCamera","CameraManager","ConversionTables","ensureNativeProps","jsx","_jsx","EventThrottleMs","_PICTURE_SAVED_CALLBACKS","loggedRenderingChildrenWarning","_GLOBAL_PICTURE_ID","ensurePictureOptions","options","quality","undefined","mirror","console","warn","onPictureSaved","id","fastMode","ensureRecordingOptions","_onPictureSaved","nativeEvent","data","callback","CameraView","isModernBarcodeScannerAvailable","isAvailableAsync","getAvailableVideoCodecsAsync","getAvailablePictureSizesAsync","_cameraRef","current","getAvailablePictureSizes","getAvailableLensesAsync","getAvailableLenses","getSupportedFeatures","toggleRecordingAsyncAvailable","resumePreview","pausePreview","defaultProps","zoom","facing","enableTorch","mode","flash","_lastEvents","_lastEventsTimes","takePictureAsync","pictureOptions","pictureRef","takePictureRef","takePicture","launchScanner","barcodeTypes","dismissScanner","onModernBarcodeScanned","listener","addListener","recordAsync","recordingOptions","record","toggleRecordingAsync","toggleRecording","stopRecording","_onCameraReady","props","onCameraReady","_onAvailableLensesChanged","onAvailableLensesChanged","_onMountError","onMountError","_onResponsiveOrientationChanged","onResponsiveOrientationChanged","_onObjectDetected","type","JSON","stringify","Date","getTime","_setReference","ref","_cameraHandle","render","nativeProps","onBarcodeScanned","children","Object","assign"],"sources":["/home/user/rork-vibesync-458/node_modules/expo-camera/src/CameraView.tsx"],"sourcesContent":["import { Platform, UnavailabilityError, type EventSubscription } from 'expo-modules-core';\nimport { type Ref, Component, createRef } from 'react';\n\nimport {\n  CameraCapturedPicture,\n  CameraOrientation,\n  CameraPictureOptions,\n  CameraViewProps,\n  CameraRecordingOptions,\n  CameraViewRef,\n  ScanningOptions,\n  ScanningResult,\n  VideoCodec,\n  AvailableLenses,\n} from './Camera.types';\nimport ExpoCamera from './ExpoCamera';\nimport CameraManager from './ExpoCameraManager';\nimport { PictureRef } from './PictureRef';\nimport { ConversionTables, ensureNativeProps } from './utils/props';\n\nconst EventThrottleMs = 500;\n\nconst _PICTURE_SAVED_CALLBACKS: Record<number, CameraPictureOptions['onPictureSaved'] | undefined> =\n  {};\n\nlet loggedRenderingChildrenWarning = false;\nlet _GLOBAL_PICTURE_ID = 1;\n\nfunction ensurePictureOptions(options?: CameraPictureOptions): CameraPictureOptions {\n  if (!options || typeof options !== 'object') {\n    return {};\n  }\n\n  if (options.quality === undefined) {\n    options.quality = 1;\n  }\n\n  if (options.mirror) {\n    console.warn(\n      'The `mirror` option is deprecated. Please use the `mirror` prop on the `CameraView` instead.'\n    );\n  }\n\n  if (options.onPictureSaved) {\n    const id = _GLOBAL_PICTURE_ID++;\n    _PICTURE_SAVED_CALLBACKS[id] = options.onPictureSaved;\n    options.id = id;\n    options.fastMode = true;\n  }\n\n  return options;\n}\n\nfunction ensureRecordingOptions(options: CameraRecordingOptions = {}): CameraRecordingOptions {\n  if (!options || typeof options !== 'object') {\n    return {};\n  }\n\n  if (options.mirror) {\n    console.warn(\n      'The `mirror` option is deprecated. Please use the `mirror` prop on the `CameraView` instead.'\n    );\n  }\n\n  return options;\n}\n\nfunction _onPictureSaved({\n  nativeEvent,\n}: {\n  nativeEvent: { data: CameraCapturedPicture; id: number };\n}) {\n  const { id, data } = nativeEvent;\n  const callback = _PICTURE_SAVED_CALLBACKS[id];\n  if (callback) {\n    callback(data);\n    delete _PICTURE_SAVED_CALLBACKS[id];\n  }\n}\n\nexport default class CameraView extends Component<CameraViewProps> {\n  /**\n   * Property that determines if the current device has the ability to use `DataScannerViewController` (iOS 16+).\n   */\n  static isModernBarcodeScannerAvailable: boolean = CameraManager.isModernBarcodeScannerAvailable;\n  /**\n   * Check whether the current device has a camera. This is useful for web and simulators cases.\n   * This isn't influenced by the Permissions API (all platforms), or HTTP usage (in the browser).\n   * You will still need to check if the native permission has been accepted.\n   * @platform web\n   */\n  static async isAvailableAsync(): Promise<boolean> {\n    if (!CameraManager.isAvailableAsync) {\n      throw new UnavailabilityError('expo-camera', 'isAvailableAsync');\n    }\n\n    return CameraManager.isAvailableAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Queries the device for the available video codecs that can be used in video recording.\n   * @return A promise that resolves to a list of strings that represents available codecs.\n   * @platform ios\n   */\n  static async getAvailableVideoCodecsAsync(): Promise<VideoCodec[]> {\n    if (!CameraManager.getAvailableVideoCodecsAsync) {\n      throw new UnavailabilityError('Camera', 'getAvailableVideoCodecsAsync');\n    }\n\n    return CameraManager.getAvailableVideoCodecsAsync();\n  }\n\n  /**\n   * Get picture sizes that are supported by the device.\n   * @return Returns a Promise that resolves to an array of strings representing picture sizes that can be passed to `pictureSize` prop.\n   * The list varies across Android devices but is the same for every iOS.\n   */\n  async getAvailablePictureSizesAsync(): Promise<string[]> {\n    return (await this._cameraRef.current?.getAvailablePictureSizes()) ?? [];\n  }\n\n  /**\n   * Returns the available lenses for the currently selected camera.\n   *\n   * @return Returns a Promise that resolves to an array of strings representing the lens type that can be passed to `selectedLens` prop.\n   * @platform ios\n   */\n  async getAvailableLensesAsync(): Promise<string[]> {\n    return (await this._cameraRef.current?.getAvailableLenses()) ?? [];\n  }\n\n  /**\n   * Returns an object with the supported features of the camera on the current device.\n   */\n  getSupportedFeatures(): {\n    isModernBarcodeScannerAvailable: boolean;\n    toggleRecordingAsyncAvailable: boolean;\n  } {\n    return {\n      isModernBarcodeScannerAvailable: CameraManager.isModernBarcodeScannerAvailable,\n      toggleRecordingAsyncAvailable: CameraManager.toggleRecordingAsyncAvailable,\n    };\n  }\n\n  /**\n   * Resumes the camera preview.\n   */\n  async resumePreview(): Promise<void> {\n    return this._cameraRef.current?.resumePreview();\n  }\n\n  /**\n   * Pauses the camera preview. It is not recommended to use `takePictureAsync` when preview is paused.\n   */\n  async pausePreview(): Promise<void> {\n    return this._cameraRef.current?.pausePreview();\n  }\n\n  // Values under keys from this object will be transformed to native options\n  static ConversionTables = ConversionTables;\n\n  static defaultProps: CameraViewProps = {\n    zoom: 0,\n    facing: 'back',\n    enableTorch: false,\n    mode: 'picture',\n    flash: 'off',\n  };\n\n  _cameraHandle?: number | null;\n  _cameraRef = createRef<CameraViewRef>();\n  _lastEvents: { [eventName: string]: string } = {};\n  _lastEventsTimes: { [eventName: string]: Date } = {};\n\n  // @needsAudit\n  /**\n   * Takes a picture and saves it to app's cache directory. Photos are rotated to match device's orientation\n   * (if `options.skipProcessing` flag is not enabled) and scaled to match the preview.\n   * > **Note**: Make sure to wait for the [`onCameraReady`](#oncameraready) callback before calling this method.\n   * @param options An object in form of `CameraPictureOptions` type.\n   * @return Returns a Promise that resolves to `CameraCapturedPicture` object, where `uri` is a URI to the local image file on Android,\n   * iOS, and a base64 string on web (usable as the source for an `Image` element). The `width` and `height` properties specify\n   * the dimensions of the image.\n   *\n   * `base64` is included if the `base64` option was truthy, and is a string containing the JPEG data\n   * of the image in Base64. Prepend it with `'data:image/jpg;base64,'` to get a data URI, which you can use as the source\n   * for an `Image` element for example.\n   *\n   * `exif` is included if the `exif` option was truthy, and is an object containing EXIF\n   * data for the image. The names of its properties are EXIF tags and their values are the values for those tags.\n   *\n   * > On native platforms, the local image URI is temporary. Use [`FileSystem.copyAsync`](filesystem/#filesystemcopyasyncoptions)\n   * > to make a permanent copy of the image.\n   *\n   * > **Note:** Avoid calling this method while the preview is paused. On Android, this will throw an error. On iOS, this will take a picture of the last frame that is currently on screen.\n   */\n  async takePictureAsync(options: CameraPictureOptions & { pictureRef: true }): Promise<PictureRef>;\n  async takePictureAsync(options?: CameraPictureOptions): Promise<CameraCapturedPicture>;\n  async takePictureAsync(options?: CameraPictureOptions) {\n    const pictureOptions = ensurePictureOptions(options);\n\n    if (Platform.OS === 'ios' && options?.pictureRef) {\n      return this._cameraRef.current?.takePictureRef?.(options);\n    }\n    return this._cameraRef.current?.takePicture(pictureOptions);\n  }\n\n  /**\n   * On Android, we will use the [Google code scanner](https://developers.google.com/ml-kit/vision/barcode-scanning/code-scanner).\n   * On iOS, presents a modal view controller that uses the [`DataScannerViewController`](https://developer.apple.com/documentation/visionkit/scanning_data_with_the_camera) available on iOS 16+.\n   * @platform android\n   * @platform ios\n   */\n  static async launchScanner(options?: ScanningOptions): Promise<void> {\n    if (!options) {\n      options = { barcodeTypes: [] };\n    }\n    if (Platform.OS !== 'web' && CameraView.isModernBarcodeScannerAvailable) {\n      await CameraManager.launchScanner(options);\n    }\n  }\n\n  /**\n   * Dismiss the scanner presented by `launchScanner`.\n   * > **info** On Android, the scanner is dismissed automatically when a barcode is scanned.\n   * @platform ios\n   */\n  static async dismissScanner(): Promise<void> {\n    if (Platform.OS !== 'web' && CameraView.isModernBarcodeScannerAvailable) {\n      await CameraManager.dismissScanner();\n    }\n  }\n\n  /**\n   * Invokes the `listener` function when a bar code has been successfully scanned. The callback is provided with\n   * an object of the `ScanningResult` shape, where the `type` refers to the bar code type that was scanned and the `data` is the information encoded in the bar code\n   * (in this case of QR codes, this is often a URL). See [`BarcodeType`](#barcodetype) for supported values.\n   * @param listener Invoked with the [ScanningResult](#scanningresult) when a bar code has been successfully scanned.\n   *\n   * @platform ios\n   * @platform android\n   */\n  static onModernBarcodeScanned(listener: (event: ScanningResult) => void): EventSubscription {\n    return CameraManager.addListener('onModernBarcodeScanned', listener);\n  }\n\n  /**\n   * Starts recording a video that will be saved to cache directory. Videos are rotated to match device's orientation.\n   * Flipping camera during a recording results in stopping it.\n   * @param options A map of `CameraRecordingOptions` type.\n   * @return Returns a Promise that resolves to an object containing video file `uri` property and a `codec` property on iOS.\n   * The Promise is returned if `stopRecording` was invoked, one of `maxDuration` and `maxFileSize` is reached or camera preview is stopped.\n   * @platform android\n   * @platform ios\n   */\n  async recordAsync(options?: CameraRecordingOptions) {\n    const recordingOptions = ensureRecordingOptions(options);\n    return this._cameraRef.current?.record(recordingOptions);\n  }\n\n  /**\n   * Pauses or resumes the video recording. Only has an effect if there is an active recording. On `iOS`, this method only supported on `iOS` 18.\n   *\n   * @example\n   * ```ts\n   * const { toggleRecordingAsyncAvailable } = getSupportedFeatures()\n   *\n   * return (\n   *  {toggleRecordingAsyncAvailable && (\n   *    <Button title=\"Toggle Recording\" onPress={toggleRecordingAsync} />\n   *  )}\n   * )\n   * ```\n   */\n  async toggleRecordingAsync() {\n    return this._cameraRef.current?.toggleRecording();\n  }\n\n  /**\n   * Stops recording if any is in progress.\n   * @platform android\n   * @platform ios\n   */\n  stopRecording() {\n    this._cameraRef.current?.stopRecording();\n  }\n\n  _onCameraReady = () => {\n    if (this.props.onCameraReady) {\n      this.props.onCameraReady();\n    }\n  };\n\n  _onAvailableLensesChanged = ({ nativeEvent }: { nativeEvent: AvailableLenses }) => {\n    if (this.props.onAvailableLensesChanged) {\n      this.props.onAvailableLensesChanged(nativeEvent);\n    }\n  };\n\n  _onMountError = ({ nativeEvent }: { nativeEvent: { message: string } }) => {\n    if (this.props.onMountError) {\n      this.props.onMountError(nativeEvent);\n    }\n  };\n\n  _onResponsiveOrientationChanged = ({\n    nativeEvent,\n  }: {\n    nativeEvent: { orientation: CameraOrientation };\n  }) => {\n    if (this.props.onResponsiveOrientationChanged) {\n      this.props.onResponsiveOrientationChanged(nativeEvent);\n    }\n  };\n\n  _onObjectDetected =\n    (callback?: Function) =>\n    ({ nativeEvent }: { nativeEvent: any }) => {\n      const { type } = nativeEvent;\n      if (\n        this._lastEvents[type] &&\n        this._lastEventsTimes[type] &&\n        JSON.stringify(nativeEvent) === this._lastEvents[type] &&\n        new Date().getTime() - this._lastEventsTimes[type].getTime() < EventThrottleMs\n      ) {\n        return;\n      }\n\n      if (callback) {\n        callback(nativeEvent);\n        this._lastEventsTimes[type] = new Date();\n        this._lastEvents[type] = JSON.stringify(nativeEvent);\n      }\n    };\n\n  _setReference = (ref: Ref<CameraViewRef>) => {\n    if (ref) {\n      // TODO(Bacon): Unify these - perhaps with hooks?\n      if (Platform.OS === 'web') {\n        this._cameraHandle = ref as any;\n      }\n    }\n  };\n\n  render() {\n    const nativeProps = ensureNativeProps(this.props);\n    const onBarcodeScanned = this.props.onBarcodeScanned\n      ? this._onObjectDetected(this.props.onBarcodeScanned)\n      : undefined;\n\n    // @ts-expect-error\n    if (nativeProps.children && !loggedRenderingChildrenWarning) {\n      console.warn(\n        'The <CameraView> component does not support children. This may lead to inconsistent behaviour or crashes. If you want to render content on top of the Camera, consider using absolute positioning.'\n      );\n      loggedRenderingChildrenWarning = true;\n    }\n\n    return (\n      <ExpoCamera\n        {...nativeProps}\n        ref={this._cameraRef}\n        onCameraReady={this._onCameraReady}\n        onMountError={this._onMountError}\n        onBarcodeScanned={onBarcodeScanned}\n        onAvailableLensesChanged={this._onAvailableLensesChanged}\n        onPictureSaved={_onPictureSaved}\n        onResponsiveOrientationChanged={this._onResponsiveOrientationChanged}\n      />\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}