{"ast":null,"code":"import{Asset}from'expo-asset';import{Platform}from'expo-modules-core';import{PitchCorrectionQuality}from'./AV.types';export const _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS=500;export const _DEFAULT_INITIAL_PLAYBACK_STATUS={positionMillis:0,progressUpdateIntervalMillis:_DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,shouldPlay:false,rate:1.0,shouldCorrectPitch:false,volume:1.0,audioPan:0,isMuted:false,isLooping:false};export function getNativeSourceFromSource(source){let uri=null;let overridingExtension=null;let headers;if(typeof source==='string'&&true){return{uri:source,overridingExtension,headers};}const asset=_getAssetFromPlaybackSource(source);if(asset!=null){uri=asset.localUri||asset.uri;}else if(source!=null&&typeof source!=='number'&&'uri'in source&&typeof source.uri==='string'){uri=source.uri;}if(uri==null){return null;}if(source!=null&&typeof source!=='number'&&'overrideFileExtensionAndroid'in source&&typeof source.overrideFileExtensionAndroid==='string'){overridingExtension=source.overrideFileExtensionAndroid;}if(source!=null&&typeof source!=='number'&&'headers'in source&&typeof source.headers==='object'){headers=source.headers;}return{uri,overridingExtension,headers};}function _getAssetFromPlaybackSource(source){if(source==null){return null;}let asset=null;if(typeof source==='number'){asset=Asset.fromModule(source);}else if(source instanceof Asset){asset=source;}return asset;}export function assertStatusValuesInBounds(status){if(typeof status.rate==='number'&&(status.rate<0||status.rate>32)){throw new RangeError('Rate value must be between 0.0 and 32.0');}if(typeof status.volume==='number'&&(status.volume<0||status.volume>1)){throw new RangeError('Volume value must be between 0.0 and 1.0');}if(typeof status.audioPan==='number'&&(status.audioPan<-1||status.audioPan>1)){throw new RangeError('Pan value must be between -1.0 and 1.0');}}export async function getNativeSourceAndFullInitialStatusForLoadAsync(source,initialStatus,downloadFirst){const fullInitialStatus=initialStatus==null?_DEFAULT_INITIAL_PLAYBACK_STATUS:Object.assign({},_DEFAULT_INITIAL_PLAYBACK_STATUS,initialStatus);assertStatusValuesInBounds(fullInitialStatus);if(typeof source==='string'&&true){return{nativeSource:{uri:source,overridingExtension:null},fullInitialStatus};}const asset=_getAssetFromPlaybackSource(source);if(downloadFirst&&asset){await asset.downloadAsync();}const nativeSource=getNativeSourceFromSource(source);if(nativeSource===null){throw new Error(`Cannot load an AV asset from a null playback source`);}if(asset&&asset.localUri){nativeSource.uri=asset.localUri;}return{nativeSource,fullInitialStatus};}export function getUnloadedStatus(error=null){return Object.assign({isLoaded:false},error?{error}:null);}export const PlaybackMixin={async playAsync(){return this.setStatusAsync({shouldPlay:true});},async playFromPositionAsync(positionMillis,tolerances={}){return this.setStatusAsync({positionMillis,shouldPlay:true,seekMillisToleranceAfter:tolerances.toleranceMillisAfter,seekMillisToleranceBefore:tolerances.toleranceMillisBefore});},async pauseAsync(){return this.setStatusAsync({shouldPlay:false});},async stopAsync(){return this.setStatusAsync({positionMillis:0,shouldPlay:false});},async setPositionAsync(positionMillis,tolerances={}){return this.setStatusAsync({positionMillis,seekMillisToleranceAfter:tolerances.toleranceMillisAfter,seekMillisToleranceBefore:tolerances.toleranceMillisBefore});},async setRateAsync(rate,shouldCorrectPitch=false,pitchCorrectionQuality=PitchCorrectionQuality.Medium){return this.setStatusAsync({rate,shouldCorrectPitch,pitchCorrectionQuality});},async setVolumeAsync(volume,audioPan){return this.setStatusAsync({volume,audioPan});},async setIsMutedAsync(isMuted){return this.setStatusAsync({isMuted});},async setIsLoopingAsync(isLooping){return this.setStatusAsync({isLooping});},async setProgressUpdateIntervalAsync(progressUpdateIntervalMillis){return this.setStatusAsync({progressUpdateIntervalMillis});}};export*from'./AV.types';","map":{"version":3,"names":["Asset","Platform","PitchCorrectionQuality","_DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS","_DEFAULT_INITIAL_PLAYBACK_STATUS","positionMillis","progressUpdateIntervalMillis","shouldPlay","rate","shouldCorrectPitch","volume","audioPan","isMuted","isLooping","getNativeSourceFromSource","source","uri","overridingExtension","headers","asset","_getAssetFromPlaybackSource","localUri","overrideFileExtensionAndroid","fromModule","assertStatusValuesInBounds","status","RangeError","getNativeSourceAndFullInitialStatusForLoadAsync","initialStatus","downloadFirst","fullInitialStatus","Object","assign","nativeSource","downloadAsync","Error","getUnloadedStatus","error","isLoaded","PlaybackMixin","playAsync","setStatusAsync","playFromPositionAsync","tolerances","seekMillisToleranceAfter","toleranceMillisAfter","seekMillisToleranceBefore","toleranceMillisBefore","pauseAsync","stopAsync","setPositionAsync","setRateAsync","pitchCorrectionQuality","Medium","setVolumeAsync","setIsMutedAsync","setIsLoopingAsync","setProgressUpdateIntervalAsync"],"sources":["/home/user/rork-vibesync-458/node_modules/expo-av/src/AV.ts"],"sourcesContent":["import { Asset } from 'expo-asset';\nimport { Platform } from 'expo-modules-core';\n\nimport {\n  AVPlaybackSource,\n  AVPlaybackNativeSource,\n  AVPlaybackStatus,\n  AVPlaybackStatusToSet,\n  PitchCorrectionQuality,\n  AVPlaybackTolerance,\n} from './AV.types';\n\n// TODO add:\n//  disableFocusOnAndroid\n//  audio routes (at least did become noisy on android)\n//  pan\n//  pitch\n//  API to explicitly request audio focus / session\n//  API to select stream type on Android\n//  subtitles API\n\n/**\n * @hidden\n */\nexport const _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS: number = 500;\n\n// @needsAudit\n/**\n * The default initial `AVPlaybackStatusToSet` of all `Audio.Sound` objects and `Video` components is as follows:\n *\n * ```javascript\n * {\n *   progressUpdateIntervalMillis: 500,\n *   positionMillis: 0,\n *   shouldPlay: false,\n *   rate: 1.0,\n *   shouldCorrectPitch: false,\n *   volume: 1.0,\n *   isMuted: false,\n *   isLooping: false,\n * }\n * ```\n *\n * This default initial status can be overwritten by setting the optional `initialStatus` in `loadAsync()` or `Audio.Sound.createAsync()`.\n */\nexport const _DEFAULT_INITIAL_PLAYBACK_STATUS: AVPlaybackStatusToSet = {\n  positionMillis: 0,\n  progressUpdateIntervalMillis: _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  shouldPlay: false,\n  rate: 1.0,\n  shouldCorrectPitch: false,\n  volume: 1.0,\n  audioPan: 0,\n  isMuted: false,\n  isLooping: false,\n};\n\n// @needsAudit\n/**\n * @hidden\n */\nexport function getNativeSourceFromSource(\n  source?: AVPlaybackSource | null\n): AVPlaybackNativeSource | null {\n  let uri: string | null = null;\n  let overridingExtension: string | null = null;\n  let headers: AVPlaybackNativeSource['headers'];\n\n  if (typeof source === 'string' && Platform.OS === 'web') {\n    return {\n      uri: source,\n      overridingExtension,\n      headers,\n    };\n  }\n\n  const asset: Asset | null = _getAssetFromPlaybackSource(source);\n  if (asset != null) {\n    uri = asset.localUri || asset.uri;\n  } else if (\n    source != null &&\n    typeof source !== 'number' &&\n    'uri' in source &&\n    typeof source.uri === 'string'\n  ) {\n    uri = source.uri;\n  }\n\n  if (uri == null) {\n    return null;\n  }\n\n  if (\n    source != null &&\n    typeof source !== 'number' &&\n    'overrideFileExtensionAndroid' in source &&\n    typeof source.overrideFileExtensionAndroid === 'string'\n  ) {\n    overridingExtension = source.overrideFileExtensionAndroid;\n  }\n\n  if (\n    source != null &&\n    typeof source !== 'number' &&\n    'headers' in source &&\n    typeof source.headers === 'object'\n  ) {\n    headers = source.headers;\n  }\n  return { uri, overridingExtension, headers };\n}\n\nfunction _getAssetFromPlaybackSource(source?: AVPlaybackSource | null): Asset | null {\n  if (source == null) {\n    return null;\n  }\n\n  let asset: Asset | null = null;\n  if (typeof source === 'number') {\n    asset = Asset.fromModule(source);\n  } else if (source instanceof Asset) {\n    asset = source;\n  }\n  return asset;\n}\n\n// @needsAudit\n/**\n * @hidden\n */\nexport function assertStatusValuesInBounds(status: AVPlaybackStatusToSet): void {\n  if (typeof status.rate === 'number' && (status.rate < 0 || status.rate > 32)) {\n    throw new RangeError('Rate value must be between 0.0 and 32.0');\n  }\n  if (typeof status.volume === 'number' && (status.volume < 0 || status.volume > 1)) {\n    throw new RangeError('Volume value must be between 0.0 and 1.0');\n  }\n  if (typeof status.audioPan === 'number' && (status.audioPan < -1 || status.audioPan > 1)) {\n    throw new RangeError('Pan value must be between -1.0 and 1.0');\n  }\n}\n\n// @needsAudit\n/**\n * @hidden\n */\nexport async function getNativeSourceAndFullInitialStatusForLoadAsync(\n  source: AVPlaybackSource | null,\n  initialStatus: AVPlaybackStatusToSet | null,\n  downloadFirst: boolean\n): Promise<{\n  nativeSource: AVPlaybackNativeSource;\n  fullInitialStatus: AVPlaybackStatusToSet;\n}> {\n  // Get the full initial status\n  const fullInitialStatus: AVPlaybackStatusToSet =\n    initialStatus == null\n      ? _DEFAULT_INITIAL_PLAYBACK_STATUS\n      : {\n          ..._DEFAULT_INITIAL_PLAYBACK_STATUS,\n          ...initialStatus,\n        };\n  assertStatusValuesInBounds(fullInitialStatus);\n\n  if (typeof source === 'string' && Platform.OS === 'web') {\n    return {\n      nativeSource: {\n        uri: source,\n        overridingExtension: null,\n      },\n      fullInitialStatus,\n    };\n  }\n\n  // Download first if necessary.\n  const asset = _getAssetFromPlaybackSource(source);\n  if (downloadFirst && asset) {\n    // TODO we can download remote uri too once @nikki93 has integrated this into Asset\n    await asset.downloadAsync();\n  }\n\n  // Get the native source\n  const nativeSource: AVPlaybackNativeSource | null = getNativeSourceFromSource(source);\n\n  if (nativeSource === null) {\n    throw new Error(`Cannot load an AV asset from a null playback source`);\n  }\n\n  // If asset has been downloaded use the localUri\n  if (asset && asset.localUri) {\n    nativeSource.uri = asset.localUri;\n  }\n\n  return { nativeSource, fullInitialStatus };\n}\n\n// @needsAudit\n/**\n * @hidden\n */\nexport function getUnloadedStatus(error: string | null = null): AVPlaybackStatus {\n  return {\n    isLoaded: false,\n    ...(error ? { error } : null),\n  };\n}\n\n// @needsAudit\nexport interface AV {\n  /**\n   * Sets a new `AVPlaybackStatusToSet` on the `playbackObject`. This method can only be called if the media has been loaded.\n   * @param status The new `AVPlaybackStatusToSet` of the `playbackObject`, whose values will override the current playback status.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once the new status has been set successfully,\n   * or rejects if setting the new status failed. See below for details on `AVPlaybackStatus`.\n   */\n  setStatusAsync(status: AVPlaybackStatusToSet): Promise<AVPlaybackStatus>;\n\n  /**\n   * Gets the `AVPlaybackStatus` of the `playbackObject`.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject`.\n   */\n  getStatusAsync(): Promise<AVPlaybackStatus>;\n}\n\n// @needsAudit\n/**\n * On the `playbackObject` reference, the following API is provided.\n */\nexport interface Playback extends AV {\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: true })`.\n   *\n   * Playback may not start immediately after calling this function for reasons such as buffering. Make sure to update your UI based\n   * on the `isPlaying` and `isBuffering` properties of the `AVPlaybackStatus`.\n   */\n  playAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * Loads the media from `source` into memory and prepares it for playing. This must be called before calling `setStatusAsync()`\n   * or any of the convenience set status methods. This method can only be called if the `playbackObject` is in an unloaded state.\n   * @param source The source of the media.\n   * @param initialStatus The initial intended `AVPlaybackStatusToSet` of the `playbackObject`, whose values will override the default initial playback status.\n   * This value defaults to `{}` if no parameter is passed. For more information see the details on `AVPlaybackStatusToSet` type\n   * and the default initial playback status.\n   * @param downloadAsync If set to `true`, the system will attempt to download the resource to the device before loading.\n   * This value defaults to `true`. Note that at the moment, this will only work for `source`s of the form `require('path/to/file')` or `Asset` objects.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once it is loaded, or rejects if loading failed.\n   * The `Promise` will also reject if the `playbackObject` was already loaded. See below for details on `AVPlaybackStatus`.\n   */\n  loadAsync(\n    source: AVPlaybackSource,\n    initialStatus?: AVPlaybackStatusToSet,\n    downloadAsync?: boolean\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * Unloads the media from memory. `loadAsync()` must be called again in order to be able to play the media.\n   * > This cleanup function will be automatically called in the `Video` component's `componentWillUnmount`.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once it is unloaded, or rejects if unloading failed.\n   */\n  unloadAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: true, positionMillis, seekMillisToleranceAfter: tolerances.seekMillisToleranceAfter, seekMillisToleranceBefore: tolerances.seekMillisToleranceBefore })`.\n   *\n   * Playback may not start immediately after calling this function for reasons such as buffering. Make sure to update your UI based\n   * on the `isPlaying` and `isBuffering` properties of the `AVPlaybackStatus`.\n   * @param positionMillis The desired position of playback in milliseconds.\n   * @param tolerances The tolerances are used only on iOS ([more details](#what-is-seek-tolerance-and-why-would-i-want-to-use-it)).\n   */\n  playFromPositionAsync(\n    positionMillis: number,\n    tolerances?: AVPlaybackTolerance\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: false })`.\n   */\n  pauseAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: false, positionMillis: 0 })`.\n   */\n  stopAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * Replays the playback item. When using `playFromPositionAsync(0)` the item is seeked to the position at `0 ms`.\n   * On iOS this method uses internal implementation of the player and is able to play the item from the beginning immediately.\n   * @param status The new `AVPlaybackStatusToSet` of the `playbackObject`, whose values will override the current playback status.\n   * `positionMillis` and `shouldPlay` properties will be overridden with respectively `0` and `true`.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once the new status has been set successfully,\n   * or rejects if setting the new status failed.\n   */\n  replayAsync(status: AVPlaybackStatusToSet): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ positionMillis })`.\n   * @param positionMillis The desired position of playback in milliseconds.\n   * @param tolerances The tolerances are used only on iOS ([more details](#what-is-seek-tolerance-and-why-would-i-want-to-use-it)).\n   */\n  setPositionAsync(\n    positionMillis: number,\n    tolerances?: AVPlaybackTolerance\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ rate, shouldCorrectPitch, pitchCorrectionQuality })`.\n   * @param rate The desired playback rate of the media. This value must be between `0.0` and `32.0`. Only available on Android API version 23 and later and iOS.\n   * @param shouldCorrectPitch A boolean describing if we should correct the pitch for a changed rate. If set to `true`, the pitch of the audio will be corrected\n   * (so a rate different than `1.0` will timestretch the audio).\n   * @param pitchCorrectionQuality iOS time pitch algorithm setting, defaults to `Audio.PitchCorrectionQuality.Medium`.\n   * Using `Audio.PitchCorrectionQuality.Low` may cause automatic playback rate changes on iOS >= 17, as `AVAudioTimePitchAlgorithmLowQualityZeroLatency` is deprecated.\n   */\n  setRateAsync(\n    rate: number,\n    shouldCorrectPitch: boolean,\n    pitchCorrectionQuality?: PitchCorrectionQuality\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ volume, audioPan })`.\n   * Note: `audioPan` is currently only supported on Android using `androidImplementation: 'MediaPlayer'`\n   * @param volume A number between `0.0` (silence) and `1.0` (maximum volume).\n   * @param audioPan A number between `-1.0` (full left) and `1.0` (full right).\n   */\n  setVolumeAsync(volume: number, audioPan?: number): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ isMuted })`.\n   * @param isMuted A boolean describing if the audio of this media should be muted.\n   */\n  setIsMutedAsync(isMuted: boolean): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ isLooping })`.\n   * @param isLooping A boolean describing if the media should play once (`false`) or loop indefinitely (`true`).\n   */\n  setIsLoopingAsync(isLooping: boolean): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ progressUpdateIntervalMillis })`.\n   * @param progressUpdateIntervalMillis The new minimum interval in milliseconds between calls of `onPlaybackStatusUpdate`.\n   * See `setOnPlaybackStatusUpdate()` for details.\n   */\n  setProgressUpdateIntervalAsync(progressUpdateIntervalMillis: number): Promise<AVPlaybackStatus>;\n}\n\n/**\n * @hidden\n * A mixin that defines common playback methods for A/V classes, so they implement the `Playback`\n * interface.\n */\nexport const PlaybackMixin = {\n  async playAsync(): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ shouldPlay: true });\n  },\n\n  async playFromPositionAsync(\n    positionMillis: number,\n    tolerances: AVPlaybackTolerance = {}\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({\n      positionMillis,\n      shouldPlay: true,\n      seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n      seekMillisToleranceBefore: tolerances.toleranceMillisBefore,\n    });\n  },\n\n  async pauseAsync(): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ shouldPlay: false });\n  },\n\n  async stopAsync(): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ positionMillis: 0, shouldPlay: false });\n  },\n\n  async setPositionAsync(\n    positionMillis: number,\n    tolerances: AVPlaybackTolerance = {}\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({\n      positionMillis,\n      seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n      seekMillisToleranceBefore: tolerances.toleranceMillisBefore,\n    });\n  },\n\n  async setRateAsync(\n    rate: number,\n    shouldCorrectPitch: boolean = false,\n    pitchCorrectionQuality: PitchCorrectionQuality = PitchCorrectionQuality.Medium\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({\n      rate,\n      shouldCorrectPitch,\n      pitchCorrectionQuality,\n    });\n  },\n\n  async setVolumeAsync(volume: number, audioPan?: number): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ volume, audioPan });\n  },\n\n  async setIsMutedAsync(isMuted: boolean): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ isMuted });\n  },\n\n  async setIsLoopingAsync(isLooping: boolean): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ isLooping });\n  },\n\n  async setProgressUpdateIntervalAsync(\n    progressUpdateIntervalMillis: number\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ progressUpdateIntervalMillis });\n  },\n};\n\nexport * from './AV.types';\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}