{"ast":null,"code":"function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}import EventManager from'./EventManager';import{MouseButton}from'../../handlers/gestureHandlerCommon';import{EventTypes}from'../interfaces';import{PointerTypeMapping,calculateViewScale,tryExtractStylusData,isPointerInBounds}from'../utils';import{PointerType}from'../../PointerType';const POINTER_CAPTURE_EXCLUDE_LIST=new Set(['SELECT','INPUT']);export default class PointerEventManager extends EventManager{constructor(view){super(view);_defineProperty(this,\"trackedPointers\",new Set());_defineProperty(this,\"mouseButtonsMapper\",new Map());_defineProperty(this,\"lastPosition\",void 0);_defineProperty(this,\"pointerDownCallback\",event=>{if(!isPointerInBounds(this.view,{x:event.clientX,y:event.clientY})){return;}const adaptedEvent=this.mapEvent(event,EventTypes.DOWN);const target=event.target;if(!POINTER_CAPTURE_EXCLUDE_LIST.has(target.tagName)){target.setPointerCapture(adaptedEvent.pointerId);}this.markAsInBounds(adaptedEvent.pointerId);this.trackedPointers.add(adaptedEvent.pointerId);if(++this.activePointersCounter>1){adaptedEvent.eventType=EventTypes.ADDITIONAL_POINTER_DOWN;this.onPointerAdd(adaptedEvent);}else{this.onPointerDown(adaptedEvent);}});_defineProperty(this,\"pointerUpCallback\",event=>{if(this.activePointersCounter===0){return;}const adaptedEvent=this.mapEvent(event,EventTypes.UP);const target=event.target;if(!POINTER_CAPTURE_EXCLUDE_LIST.has(target.tagName)){target.releasePointerCapture(adaptedEvent.pointerId);}this.markAsOutOfBounds(adaptedEvent.pointerId);this.trackedPointers.delete(adaptedEvent.pointerId);if(--this.activePointersCounter>0){adaptedEvent.eventType=EventTypes.ADDITIONAL_POINTER_UP;this.onPointerRemove(adaptedEvent);}else{this.onPointerUp(adaptedEvent);}});_defineProperty(this,\"pointerMoveCallback\",event=>{const adaptedEvent=this.mapEvent(event,EventTypes.MOVE);const target=event.target;if(!target.hasPointerCapture(event.pointerId)&&!POINTER_CAPTURE_EXCLUDE_LIST.has(target.tagName)){target.setPointerCapture(event.pointerId);}const inBounds=isPointerInBounds(this.view,{x:adaptedEvent.x,y:adaptedEvent.y});const pointerIndex=this.pointersInBounds.indexOf(adaptedEvent.pointerId);if(inBounds){if(pointerIndex<0){adaptedEvent.eventType=EventTypes.ENTER;this.onPointerEnter(adaptedEvent);this.markAsInBounds(adaptedEvent.pointerId);}else{this.onPointerMove(adaptedEvent);}}else{if(pointerIndex>=0){adaptedEvent.eventType=EventTypes.LEAVE;this.onPointerLeave(adaptedEvent);this.markAsOutOfBounds(adaptedEvent.pointerId);}else{this.onPointerOutOfBounds(adaptedEvent);}}this.lastPosition.x=event.x;this.lastPosition.y=event.y;});_defineProperty(this,\"pointerCancelCallback\",event=>{const adaptedEvent=this.mapEvent(event,EventTypes.CANCEL);this.onPointerCancel(adaptedEvent);this.markAsOutOfBounds(adaptedEvent.pointerId);this.activePointersCounter=0;this.trackedPointers.clear();});_defineProperty(this,\"pointerEnterCallback\",event=>{const adaptedEvent=this.mapEvent(event,EventTypes.ENTER);this.onPointerMoveOver(adaptedEvent);});_defineProperty(this,\"pointerLeaveCallback\",event=>{const adaptedEvent=this.mapEvent(event,EventTypes.LEAVE);this.onPointerMoveOut(adaptedEvent);});_defineProperty(this,\"lostPointerCaptureCallback\",event=>{const adaptedEvent=this.mapEvent(event,EventTypes.CANCEL);if(this.trackedPointers.has(adaptedEvent.pointerId)){this.onPointerCancel(adaptedEvent);this.activePointersCounter=0;this.trackedPointers.clear();}});this.mouseButtonsMapper.set(0,MouseButton.LEFT);this.mouseButtonsMapper.set(1,MouseButton.MIDDLE);this.mouseButtonsMapper.set(2,MouseButton.RIGHT);this.mouseButtonsMapper.set(3,MouseButton.BUTTON_4);this.mouseButtonsMapper.set(4,MouseButton.BUTTON_5);this.lastPosition={x:-Infinity,y:-Infinity};}registerListeners(){this.view.addEventListener('pointerdown',this.pointerDownCallback);this.view.addEventListener('pointerup',this.pointerUpCallback);this.view.addEventListener('pointermove',this.pointerMoveCallback);this.view.addEventListener('pointercancel',this.pointerCancelCallback);this.view.addEventListener('pointerenter',this.pointerEnterCallback);this.view.addEventListener('pointerleave',this.pointerLeaveCallback);this.view.addEventListener('lostpointercapture',this.lostPointerCaptureCallback);}unregisterListeners(){this.view.removeEventListener('pointerdown',this.pointerDownCallback);this.view.removeEventListener('pointerup',this.pointerUpCallback);this.view.removeEventListener('pointermove',this.pointerMoveCallback);this.view.removeEventListener('pointercancel',this.pointerCancelCallback);this.view.removeEventListener('pointerenter',this.pointerEnterCallback);this.view.removeEventListener('pointerleave',this.pointerLeaveCallback);this.view.removeEventListener('lostpointercapture',this.lostPointerCaptureCallback);}mapEvent(event,eventType){var _PointerTypeMapping$g;const rect=this.view.getBoundingClientRect();const{scaleX,scaleY}=calculateViewScale(this.view);return{x:event.clientX,y:event.clientY,offsetX:(event.clientX-rect.left)/scaleX,offsetY:(event.clientY-rect.top)/scaleY,pointerId:event.pointerId,eventType:eventType,pointerType:(_PointerTypeMapping$g=PointerTypeMapping.get(event.pointerType))!==null&&_PointerTypeMapping$g!==void 0?_PointerTypeMapping$g:PointerType.OTHER,button:this.mouseButtonsMapper.get(event.button),time:event.timeStamp,stylusData:tryExtractStylusData(event)};}resetManager(){super.resetManager();this.trackedPointers.clear();}}","map":{"version":3,"names":["EventManager","MouseButton","EventTypes","PointerTypeMapping","calculateViewScale","tryExtractStylusData","isPointerInBounds","PointerType","POINTER_CAPTURE_EXCLUDE_LIST","Set","PointerEventManager","constructor","view","_defineProperty","Map","event","x","clientX","y","clientY","adaptedEvent","mapEvent","DOWN","target","has","tagName","setPointerCapture","pointerId","markAsInBounds","trackedPointers","add","activePointersCounter","eventType","ADDITIONAL_POINTER_DOWN","onPointerAdd","onPointerDown","UP","releasePointerCapture","markAsOutOfBounds","delete","ADDITIONAL_POINTER_UP","onPointerRemove","onPointerUp","MOVE","hasPointerCapture","inBounds","pointerIndex","pointersInBounds","indexOf","ENTER","onPointerEnter","onPointerMove","LEAVE","onPointerLeave","onPointerOutOfBounds","lastPosition","CANCEL","onPointerCancel","clear","onPointerMoveOver","onPointerMoveOut","mouseButtonsMapper","set","LEFT","MIDDLE","RIGHT","BUTTON_4","BUTTON_5","Infinity","registerListeners","addEventListener","pointerDownCallback","pointerUpCallback","pointerMoveCallback","pointerCancelCallback","pointerEnterCallback","pointerLeaveCallback","lostPointerCaptureCallback","unregisterListeners","removeEventListener","_PointerTypeMapping$g","rect","getBoundingClientRect","scaleX","scaleY","offsetX","left","offsetY","top","pointerType","get","OTHER","button","time","timeStamp","stylusData","resetManager"],"sources":["/home/user/rork-vibesync-458/node_modules/react-native-gesture-handler/lib/module/web/tools/PointerEventManager.ts"],"sourcesContent":["import EventManager from './EventManager';\nimport { MouseButton } from '../../handlers/gestureHandlerCommon';\nimport { AdaptedEvent, EventTypes, Point } from '../interfaces';\nimport {\n  PointerTypeMapping,\n  calculateViewScale,\n  tryExtractStylusData,\n  isPointerInBounds,\n} from '../utils';\nimport { PointerType } from '../../PointerType';\n\nconst POINTER_CAPTURE_EXCLUDE_LIST = new Set<string>(['SELECT', 'INPUT']);\n\nexport default class PointerEventManager extends EventManager<HTMLElement> {\n  private trackedPointers = new Set<number>();\n  private readonly mouseButtonsMapper = new Map<number, MouseButton>();\n  private lastPosition: Point;\n\n  constructor(view: HTMLElement) {\n    super(view);\n\n    this.mouseButtonsMapper.set(0, MouseButton.LEFT);\n    this.mouseButtonsMapper.set(1, MouseButton.MIDDLE);\n    this.mouseButtonsMapper.set(2, MouseButton.RIGHT);\n    this.mouseButtonsMapper.set(3, MouseButton.BUTTON_4);\n    this.mouseButtonsMapper.set(4, MouseButton.BUTTON_5);\n\n    this.lastPosition = {\n      x: -Infinity,\n      y: -Infinity,\n    };\n  }\n\n  private pointerDownCallback = (event: PointerEvent) => {\n    if (!isPointerInBounds(this.view, { x: event.clientX, y: event.clientY })) {\n      return;\n    }\n\n    const adaptedEvent: AdaptedEvent = this.mapEvent(event, EventTypes.DOWN);\n    const target = event.target as HTMLElement;\n\n    if (!POINTER_CAPTURE_EXCLUDE_LIST.has(target.tagName)) {\n      target.setPointerCapture(adaptedEvent.pointerId);\n    }\n\n    this.markAsInBounds(adaptedEvent.pointerId);\n    this.trackedPointers.add(adaptedEvent.pointerId);\n\n    if (++this.activePointersCounter > 1) {\n      adaptedEvent.eventType = EventTypes.ADDITIONAL_POINTER_DOWN;\n      this.onPointerAdd(adaptedEvent);\n    } else {\n      this.onPointerDown(adaptedEvent);\n    }\n  };\n\n  private pointerUpCallback = (event: PointerEvent) => {\n    // When we call reset on gesture handlers, it also resets their event managers\n    // In some handlers (like RotationGestureHandler) reset is called before all pointers leave view\n    // This means, that activePointersCounter will be set to 0, while there are still remaining pointers on view\n    // Removing them will end in activePointersCounter going below 0, therefore handlers won't behave properly\n    if (this.activePointersCounter === 0) {\n      return;\n    }\n\n    const adaptedEvent: AdaptedEvent = this.mapEvent(event, EventTypes.UP);\n    const target = event.target as HTMLElement;\n\n    if (!POINTER_CAPTURE_EXCLUDE_LIST.has(target.tagName)) {\n      target.releasePointerCapture(adaptedEvent.pointerId);\n    }\n\n    this.markAsOutOfBounds(adaptedEvent.pointerId);\n    this.trackedPointers.delete(adaptedEvent.pointerId);\n\n    if (--this.activePointersCounter > 0) {\n      adaptedEvent.eventType = EventTypes.ADDITIONAL_POINTER_UP;\n      this.onPointerRemove(adaptedEvent);\n    } else {\n      this.onPointerUp(adaptedEvent);\n    }\n  };\n\n  private pointerMoveCallback = (event: PointerEvent) => {\n    const adaptedEvent: AdaptedEvent = this.mapEvent(event, EventTypes.MOVE);\n    const target = event.target as HTMLElement;\n\n    // You may be wondering why are we setting pointer capture here, when we\n    // already set it in `pointerdown` handler. Well, that's a great question,\n    // for which I don't have an answer. Specification (https://www.w3.org/TR/pointerevents2/#dom-element-setpointercapture)\n    // says that the requirement for `setPointerCapture` to work is that pointer\n    // must be in 'active buttons state`, otherwise it will fail silently, which\n    // is lovely. Obviously, when `pointerdown` is fired, one of the buttons\n    // (when using mouse) is pressed, but that doesn't mean that `setPointerCapture`\n    // will succeed, for some reason. Since it fails silently, we don't actually know\n    // if it worked or not (there's `gotpointercapture` event, but the complexity of\n    // incorporating it here seems stupid), so we just call it again here, every time\n    // pointer moves until it succeeds.\n    // God, I do love web development.\n    if (\n      !target.hasPointerCapture(event.pointerId) &&\n      !POINTER_CAPTURE_EXCLUDE_LIST.has(target.tagName)\n    ) {\n      target.setPointerCapture(event.pointerId);\n    }\n\n    const inBounds: boolean = isPointerInBounds(this.view, {\n      x: adaptedEvent.x,\n      y: adaptedEvent.y,\n    });\n\n    const pointerIndex: number = this.pointersInBounds.indexOf(\n      adaptedEvent.pointerId\n    );\n\n    if (inBounds) {\n      if (pointerIndex < 0) {\n        adaptedEvent.eventType = EventTypes.ENTER;\n        this.onPointerEnter(adaptedEvent);\n        this.markAsInBounds(adaptedEvent.pointerId);\n      } else {\n        this.onPointerMove(adaptedEvent);\n      }\n    } else {\n      if (pointerIndex >= 0) {\n        adaptedEvent.eventType = EventTypes.LEAVE;\n        this.onPointerLeave(adaptedEvent);\n        this.markAsOutOfBounds(adaptedEvent.pointerId);\n      } else {\n        this.onPointerOutOfBounds(adaptedEvent);\n      }\n    }\n\n    this.lastPosition.x = event.x;\n    this.lastPosition.y = event.y;\n  };\n\n  private pointerCancelCallback = (event: PointerEvent) => {\n    const adaptedEvent: AdaptedEvent = this.mapEvent(event, EventTypes.CANCEL);\n\n    this.onPointerCancel(adaptedEvent);\n    this.markAsOutOfBounds(adaptedEvent.pointerId);\n    this.activePointersCounter = 0;\n    this.trackedPointers.clear();\n  };\n\n  private pointerEnterCallback = (event: PointerEvent) => {\n    const adaptedEvent: AdaptedEvent = this.mapEvent(event, EventTypes.ENTER);\n\n    this.onPointerMoveOver(adaptedEvent);\n  };\n\n  private pointerLeaveCallback = (event: PointerEvent) => {\n    const adaptedEvent: AdaptedEvent = this.mapEvent(event, EventTypes.LEAVE);\n\n    this.onPointerMoveOut(adaptedEvent);\n  };\n\n  private lostPointerCaptureCallback = (event: PointerEvent) => {\n    const adaptedEvent: AdaptedEvent = this.mapEvent(event, EventTypes.CANCEL);\n\n    if (this.trackedPointers.has(adaptedEvent.pointerId)) {\n      // In some cases the `pointerup` event is not fired, but `lostpointercapture` is.\n      // Here we simulate the `pointercancel` event to make sure the gesture handler stops tracking it.\n      this.onPointerCancel(adaptedEvent);\n\n      this.activePointersCounter = 0;\n      this.trackedPointers.clear();\n    }\n  };\n\n  public registerListeners(): void {\n    this.view.addEventListener('pointerdown', this.pointerDownCallback);\n    this.view.addEventListener('pointerup', this.pointerUpCallback);\n    this.view.addEventListener('pointermove', this.pointerMoveCallback);\n    this.view.addEventListener('pointercancel', this.pointerCancelCallback);\n\n    // onPointerEnter and onPointerLeave are triggered by a custom logic responsible for\n    // handling shouldCancelWhenOutside flag, and are unreliable unless the pointer is down.\n    // We therefore use pointerenter and pointerleave events to handle the hover gesture,\n    // mapping them to onPointerMoveOver and onPointerMoveOut respectively.\n    this.view.addEventListener('pointerenter', this.pointerEnterCallback);\n    this.view.addEventListener('pointerleave', this.pointerLeaveCallback);\n    this.view.addEventListener(\n      'lostpointercapture',\n      this.lostPointerCaptureCallback\n    );\n  }\n\n  public unregisterListeners(): void {\n    this.view.removeEventListener('pointerdown', this.pointerDownCallback);\n    this.view.removeEventListener('pointerup', this.pointerUpCallback);\n    this.view.removeEventListener('pointermove', this.pointerMoveCallback);\n    this.view.removeEventListener('pointercancel', this.pointerCancelCallback);\n    this.view.removeEventListener('pointerenter', this.pointerEnterCallback);\n    this.view.removeEventListener('pointerleave', this.pointerLeaveCallback);\n    this.view.removeEventListener(\n      'lostpointercapture',\n      this.lostPointerCaptureCallback\n    );\n  }\n\n  protected mapEvent(event: PointerEvent, eventType: EventTypes): AdaptedEvent {\n    const rect = this.view.getBoundingClientRect();\n    const { scaleX, scaleY } = calculateViewScale(this.view);\n\n    return {\n      x: event.clientX,\n      y: event.clientY,\n      offsetX: (event.clientX - rect.left) / scaleX,\n      offsetY: (event.clientY - rect.top) / scaleY,\n      pointerId: event.pointerId,\n      eventType: eventType,\n      pointerType:\n        PointerTypeMapping.get(event.pointerType) ?? PointerType.OTHER,\n      button: this.mouseButtonsMapper.get(event.button),\n      time: event.timeStamp,\n      stylusData: tryExtractStylusData(event),\n    };\n  }\n\n  public resetManager(): void {\n    super.resetManager();\n    this.trackedPointers.clear();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}