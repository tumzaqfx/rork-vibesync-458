{"ast":null,"code":"import GestureHandler from'./GestureHandler';import{TEST_MAX_IF_NOT_NAN}from'./utils';class DiscreteGestureHandler extends GestureHandler{get isDiscrete(){return true;}get shouldEnableGestureOnSetup(){return true;}shouldFailUnderCustomCriteria({x,y,deltaX,deltaY},{maxDeltaX,maxDeltaY,maxDistSq,shouldCancelWhenOutside}){if(shouldCancelWhenOutside){if(!this.isPointInView({x,y})){return true;}}return TEST_MAX_IF_NOT_NAN(Math.abs(deltaX),maxDeltaX)||TEST_MAX_IF_NOT_NAN(Math.abs(deltaY),maxDeltaY)||TEST_MAX_IF_NOT_NAN(Math.abs(deltaY*deltaY+deltaX*deltaX),maxDistSq);}transformNativeEvent({center:{x,y}}){const rect=this.view.getBoundingClientRect();return{absoluteX:x,absoluteY:y,x:x-rect.left,y:y-rect.top};}isGestureEnabledForEvent({minPointers,maxPointers,maxDeltaX,maxDeltaY,maxDistSq,shouldCancelWhenOutside},_recognizer,{maxPointers:pointerLength,center,deltaX,deltaY}){const validPointerCount=pointerLength>=minPointers&&pointerLength<=maxPointers;if(this.shouldFailUnderCustomCriteria(Object.assign({},center,{deltaX,deltaY}),{maxDeltaX,maxDeltaY,maxDistSq,shouldCancelWhenOutside})||!validPointerCount&&this.isGestureRunning){return{failed:true};}return{success:validPointerCount};}}export default DiscreteGestureHandler;","map":{"version":3,"names":["GestureHandler","TEST_MAX_IF_NOT_NAN","DiscreteGestureHandler","isDiscrete","shouldEnableGestureOnSetup","shouldFailUnderCustomCriteria","x","y","deltaX","deltaY","maxDeltaX","maxDeltaY","maxDistSq","shouldCancelWhenOutside","isPointInView","Math","abs","transformNativeEvent","center","rect","view","getBoundingClientRect","absoluteX","absoluteY","left","top","isGestureEnabledForEvent","minPointers","maxPointers","_recognizer","pointerLength","validPointerCount","Object","assign","isGestureRunning","failed","success"],"sources":["/home/user/rork-vibesync-458/node_modules/react-native-gesture-handler/lib/module/web_hammer/DiscreteGestureHandler.ts"],"sourcesContent":["/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport GestureHandler from './GestureHandler';\nimport { TEST_MAX_IF_NOT_NAN } from './utils';\n\nabstract class DiscreteGestureHandler extends GestureHandler {\n  get isDiscrete() {\n    return true;\n  }\n\n  get shouldEnableGestureOnSetup() {\n    return true;\n  }\n\n  shouldFailUnderCustomCriteria(\n    { x, y, deltaX, deltaY }: any,\n    { maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside }: any\n  ) {\n    if (shouldCancelWhenOutside) {\n      if (!this.isPointInView({ x, y })) {\n        return true;\n      }\n    }\n    return (\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaX), maxDeltaX) ||\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaY), maxDeltaY) ||\n      TEST_MAX_IF_NOT_NAN(\n        Math.abs(deltaY * deltaY + deltaX * deltaX),\n        maxDistSq\n      )\n    );\n  }\n\n  transformNativeEvent({ center: { x, y } }: any) {\n    // @ts-ignore FIXME(TS)\n    const rect = this.view!.getBoundingClientRect();\n\n    return {\n      absoluteX: x,\n      absoluteY: y,\n      x: x - rect.left,\n      y: y - rect.top,\n    };\n  }\n\n  isGestureEnabledForEvent(\n    {\n      minPointers,\n      maxPointers,\n      maxDeltaX,\n      maxDeltaY,\n      maxDistSq,\n      shouldCancelWhenOutside,\n    }: any,\n    _recognizer: any,\n    { maxPointers: pointerLength, center, deltaX, deltaY }: any\n  ) {\n    const validPointerCount =\n      pointerLength >= minPointers && pointerLength <= maxPointers;\n\n    if (\n      this.shouldFailUnderCustomCriteria(\n        { ...center, deltaX, deltaY },\n        {\n          maxDeltaX,\n          maxDeltaY,\n          maxDistSq,\n          shouldCancelWhenOutside,\n        }\n      ) ||\n      // A user probably won't land a multi-pointer tap on the first tick (so we cannot just cancel each time)\n      // but if the gesture is running and the user adds or subtracts another pointer then it should fail.\n      (!validPointerCount && this.isGestureRunning)\n    ) {\n      return { failed: true };\n    }\n\n    return { success: validPointerCount };\n  }\n}\n\nexport default DiscreteGestureHandler;\n"],"mappings":"AAEA,MAAO,CAAAA,cAAP,KAA2B,kBAA3B,CACA,OAASC,mBAAT,KAAoC,SAApC,CAEA,KAAe,CAAAC,sBAAf,QAA8C,CAAAF,cAAe,CAC7C,GAAV,CAAAG,UAAUA,CAAA,CAAG,CACf,MAAO,KAAP,CACD,CAE6B,GAA1B,CAAAC,0BAA0BA,CAAA,CAAG,CAC/B,MAAO,KAAP,CACD,CAEDC,6BAA6BA,CAC3B,CAAEC,CAAF,CAAKC,CAAL,CAAQC,MAAR,CAAgBC,MAAhB,CAD2B,CAE3B,CAAEC,SAAF,CAAaC,SAAb,CAAwBC,SAAxB,CAAmCC,uBAAnC,CAF2B,CAG3B,CACA,GAAIA,uBAAJ,CAA6B,CAC3B,GAAI,CAAC,KAAKC,aAAL,CAAmB,CAAER,CAAF,CAAKC,CAAL,CAAnB,CAAL,CAAmC,CACjC,MAAO,KAAP,CACD,CACF,CACD,MACE,CAAAN,mBAAmB,CAACc,IAAI,CAACC,GAAL,CAASR,MAAT,CAAD,CAAmBE,SAAnB,CAAnB,EACAT,mBAAmB,CAACc,IAAI,CAACC,GAAL,CAASP,MAAT,CAAD,CAAmBE,SAAnB,CADnB,EAEAV,mBAAmB,CACjBc,IAAI,CAACC,GAAL,CAASP,MAAM,CAAGA,MAAT,CAAkBD,MAAM,CAAGA,MAApC,CADiB,CAEjBI,SAFiB,CAHrB,CAQD,CAEDK,oBAAoBA,CAAC,CAAEC,MAAM,CAAE,CAAEZ,CAAF,CAAKC,CAAL,CAAV,CAAD,CAA4B,CAE9C,KAAM,CAAAY,IAAI,CAAG,KAAKC,IAAL,CAAWC,qBAAX,EAAb,CAEA,MAAO,CACLC,SAAS,CAAEhB,CADN,CAELiB,SAAS,CAAEhB,CAFN,CAGLD,CAAC,CAAEA,CAAC,CAAGa,IAAI,CAACK,IAHP,CAILjB,CAAC,CAAEA,CAAC,CAAGY,IAAI,CAACM,GAJP,CAAP,CAMD,CAEDC,wBAAwBA,CACtB,CACEC,WADF,CAEEC,WAFF,CAGElB,SAHF,CAIEC,SAJF,CAKEC,SALF,CAMEC,uBANF,CADsB,CAStBgB,WATsB,CAUtB,CAAED,WAAW,CAAEE,aAAf,CAA8BZ,MAA9B,CAAsCV,MAAtC,CAA8CC,MAA9C,CAVsB,CAWtB,CACA,KAAM,CAAAsB,iBAAiB,CACrBD,aAAa,EAAIH,WAAjB,EAAgCG,aAAa,EAAIF,WADnD,CAGA,GACE,KAAKvB,6BAAL,CAAA2B,MAAA,CAAAC,MAAA,IACOf,MAAL,EAAaV,MAAb,CAAqBC,MAAA,GACrB,CACEC,SADF,CAEEC,SAFF,CAGEC,SAHF,CAIEC,uBAJF,CAFF,GAWC,CAACkB,iBAAD,EAAsB,KAAKG,gBAZ9B,CAaE,CACA,MAAO,CAAEC,MAAM,CAAE,IAAV,CAAP,CACD,CAED,MAAO,CAAEC,OAAO,CAAEL,iBAAX,CAAP,CACD,CAzE0D,CA4E7D,cAAe,CAAA7B,sBAAf","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}