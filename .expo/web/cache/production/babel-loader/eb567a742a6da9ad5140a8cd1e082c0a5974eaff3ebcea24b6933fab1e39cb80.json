{"ast":null,"code":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.defaultRouteInfo=void 0;exports.getRouteInfoFromState=getRouteInfoFromState;const constants_1=require(\"../constants\");const getPathFromState_forks_1=require(\"../fork/getPathFromState-forks\");exports.defaultRouteInfo={unstable_globalHref:'',searchParams:new URLSearchParams(),pathname:'/',params:{},segments:[],pathnameWithParams:'/',isIndex:false};function getRouteInfoFromState(state){if(!state)return exports.defaultRouteInfo;let route=state.routes[0];if(route.name!==constants_1.INTERNAL_SLOT_NAME){throw new Error(`Expected the first route to be ${constants_1.INTERNAL_SLOT_NAME}, but got ${route.name}`);}state=route.state;const segments=[];const params=Object.create(null);while(state){route=state.routes[0];Object.assign(params,route.params);let routeName=route.name;if(routeName.startsWith('/')){routeName=routeName.slice(1);}segments.push(...routeName.split('/'));state=route.state;}let routeParams=route.params;while(routeParams&&'screen'in routeParams){if(typeof routeParams.screen==='string'){segments.push(...routeParams.screen.split('/'));}if(typeof routeParams.params==='object'&&!Array.isArray(routeParams.params)){routeParams=routeParams.params;}else{routeParams=undefined;}}if(route.params&&'screen'in route.params&&route.params.screen==='string'){segments.push(route.params.screen);}if(segments[segments.length-1]==='index'){segments.pop();}delete params['screen'];delete params['params'];const pathParams=new Set();const pathname='/'+segments.filter(segment=>{return!(segment.startsWith('(')&&segment.endsWith(')'));}).flatMap(segment=>{if(segment==='+not-found'){const notFoundPath=params['not-found'];pathParams.add('not-found');if(typeof notFoundPath==='undefined'){return[];}else if(Array.isArray(notFoundPath)){return notFoundPath;}else{return[notFoundPath];}}else if(segment.startsWith('[...')&&segment.endsWith(']')){let paramName=segment.slice(4,-1);if(paramName.endsWith('?')){paramName=paramName.slice(0,-1);}const values=params[paramName];pathParams.add(paramName);return values||[];}else if(segment.startsWith('[')&&segment.endsWith(']')){const paramName=segment.slice(1,-1);const value=params[paramName];pathParams.add(paramName);return value?[value]:[];}else{return[segment];}}).join('/');const searchParams=new URLSearchParams(Object.entries(params).flatMap(([key,value])=>{if(pathParams.has(key)){return[];}else if(Array.isArray(value)){return value.map(v=>[key,v]);}return[[key,value]];}));let hash;if(searchParams.has('#')){hash=searchParams.get('#')||undefined;searchParams.delete('#');}const searchParamString=searchParams.toString();let pathnameWithParams=searchParamString?pathname+'?'+searchParamString:pathname;pathnameWithParams=hash?pathnameWithParams+'#'+hash:pathnameWithParams;return{segments,pathname,params,unstable_globalHref:(0,getPathFromState_forks_1.appendBaseUrl)(pathnameWithParams),searchParams,pathnameWithParams,isIndex:false};}","map":{"version":3,"names":["exports","getRouteInfoFromState","constants_1","require","getPathFromState_forks_1","defaultRouteInfo","unstable_globalHref","searchParams","URLSearchParams","pathname","params","segments","pathnameWithParams","isIndex","state","route","routes","name","INTERNAL_SLOT_NAME","Error","Object","create","assign","routeName","startsWith","slice","push","split","routeParams","screen","Array","isArray","undefined","length","pop","pathParams","Set","filter","segment","endsWith","flatMap","notFoundPath","add","paramName","values","value","join","entries","key","has","map","v","hash","get","delete","searchParamString","toString","appendBaseUrl"],"sources":["/home/user/rork-vibesync-458/node_modules/expo-router/src/global-state/routeInfo.ts"],"sourcesContent":["import type { NavigationState, PartialState } from '@react-navigation/native';\n\nimport type { FocusedRouteState } from './router-store';\nimport { INTERNAL_SLOT_NAME } from '../constants';\nimport { appendBaseUrl } from '../fork/getPathFromState-forks';\n\nexport type UrlObject = {\n  unstable_globalHref: string;\n  pathname: string;\n  readonly params: Record<string, string | string[]>;\n  searchParams: URLSearchParams;\n  segments: string[];\n  pathnameWithParams: string;\n  isIndex: boolean;\n};\n\nexport const defaultRouteInfo: UrlObject = {\n  unstable_globalHref: '',\n  searchParams: new URLSearchParams(),\n  pathname: '/',\n  params: {},\n  segments: [],\n  pathnameWithParams: '/',\n  // TODO: Remove this, it is not used anywhere\n  isIndex: false,\n};\n\n/**\n * A better typed version of `FocusedRouteState` that is easier to parse\n */\ntype StrictState = (FocusedRouteState | NavigationState | PartialState<NavigationState>) & {\n  routes: {\n    key?: string;\n    name: string;\n    params?: StrictFocusedRouteParams;\n    path?: string;\n    state?: StrictState;\n  }[];\n};\n\ntype StrictFocusedRouteParams =\n  | Record<string, string | string[]>\n  | {\n      screen?: string;\n      params?: StrictFocusedRouteParams;\n    };\n\nexport function getRouteInfoFromState(state?: StrictState): UrlObject {\n  if (!state) return defaultRouteInfo;\n\n  let route = state.routes[0];\n  if (route.name !== INTERNAL_SLOT_NAME) {\n    throw new Error(`Expected the first route to be ${INTERNAL_SLOT_NAME}, but got ${route.name}`);\n  }\n\n  state = route.state;\n\n  const segments: string[] = [];\n  const params: UrlObject['params'] = Object.create(null);\n\n  while (state) {\n    route = state.routes[0];\n\n    Object.assign(params, route.params);\n\n    let routeName = route.name;\n    if (routeName.startsWith('/')) {\n      routeName = routeName.slice(1);\n    }\n\n    segments.push(...routeName.split('/'));\n    state = route.state;\n  }\n\n  /**\n   * If React Navigation didn't render the entire tree (e.g it was interrupted in a layout)\n   * then the state maybe incomplete. The reset of the path is in the params, instead of being a route\n   */\n  let routeParams: StrictFocusedRouteParams | undefined = route.params;\n  while (routeParams && 'screen' in routeParams) {\n    if (typeof routeParams.screen === 'string') {\n      segments.push(...routeParams.screen.split('/'));\n    }\n\n    if (typeof routeParams.params === 'object' && !Array.isArray(routeParams.params)) {\n      routeParams = routeParams.params;\n    } else {\n      routeParams = undefined;\n    }\n  }\n\n  if (route.params && 'screen' in route.params && route.params.screen === 'string') {\n    segments.push(route.params.screen);\n  }\n\n  if (segments[segments.length - 1] === 'index') {\n    segments.pop();\n  }\n\n  delete params['screen'];\n  delete params['params'];\n\n  const pathParams = new Set<string>();\n\n  const pathname =\n    '/' +\n    segments\n      .filter((segment) => {\n        return !(segment.startsWith('(') && segment.endsWith(')'));\n      })\n      .flatMap((segment) => {\n        if (segment === '+not-found') {\n          const notFoundPath = params['not-found'];\n\n          pathParams.add('not-found');\n\n          if (typeof notFoundPath === 'undefined') {\n            // Not founds are optional, do nothing if its not present\n            return [];\n          } else if (Array.isArray(notFoundPath)) {\n            return notFoundPath;\n          } else {\n            return [notFoundPath];\n          }\n        } else if (segment.startsWith('[...') && segment.endsWith(']')) {\n          let paramName = segment.slice(4, -1);\n\n          // Legacy for React Navigation optional params\n          if (paramName.endsWith('?')) {\n            paramName = paramName.slice(0, -1);\n          }\n\n          const values = params[paramName];\n          pathParams.add(paramName);\n\n          // Catchall params are optional\n          return values || [];\n        } else if (segment.startsWith('[') && segment.endsWith(']')) {\n          const paramName = segment.slice(1, -1);\n          const value = params[paramName];\n          pathParams.add(paramName);\n\n          // Optional params are optional\n          return value ? [value] : [];\n        } else {\n          return [segment];\n        }\n      })\n      .join('/');\n\n  const searchParams = new URLSearchParams(\n    Object.entries(params).flatMap(([key, value]) => {\n      // Search params should not include path params\n      if (pathParams.has(key)) {\n        return [];\n      } else if (Array.isArray(value)) {\n        return value.map((v) => [key, v]);\n      }\n      return [[key, value]];\n    })\n  );\n\n  let hash: string | undefined;\n  if (searchParams.has('#')) {\n    hash = searchParams.get('#') || undefined;\n    searchParams.delete('#');\n  }\n\n  // We cannot use searchParams.size because it is not included in the React Native polyfill\n  const searchParamString = searchParams.toString();\n  let pathnameWithParams = searchParamString ? pathname + '?' + searchParamString : pathname;\n  pathnameWithParams = hash ? pathnameWithParams + '#' + hash : pathnameWithParams;\n\n  return {\n    segments,\n    pathname,\n    params,\n    unstable_globalHref: appendBaseUrl(pathnameWithParams),\n    searchParams,\n    pathnameWithParams,\n    // TODO: Remove this, it is not used anywhere\n    isIndex: false,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}